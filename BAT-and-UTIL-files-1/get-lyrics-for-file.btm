@loadbtm on
@Echo Off
                            
                @rem ————————————————————————————————————————————————————————————————————————————————————————————————————— mer@
                @rem ————————————————————————————————————————————————————————————————————————————————————————————————————— mer@
                @rem ——————————————————————                                   ██                    —————————————————————— mer@
                @rem ——————————————————————                    █               █                    —————————————————————— mer@
                @rem ——————————————————————                    █               █                    —————————————————————— mer@
                @rem ——————————————————————    ████    █████  ████             █  ███ ███ ███ ██    —————————————————————— mer@
                @rem ——————————————————————   █    █  █     █  █               █   █   █    ██  █   —————————————————————— mer@
                @rem ——————————————————————   █    █  ███████  █     ███████   █   █   █    █       —————————————————————— mer@
                @rem ——————————————————————   █    █  █        █               █    █ █     █       —————————————————————— mer@
                @rem ——————————————————————    █████  █     █  █  █            █    █ █     █       —————————————————————— mer@
                @rem ——————————————————————        █   █████    ██           █████   █    █████     —————————————————————— mer@
                @rem ——————————————————————        █                                 █              —————————————————————— mer@
                @rem ——————————————————————     ████                                ██              —————————————————————— mer@
                @rem ————————————————————————————————————————————————————————————————————————————————————————————————————— mer@
                @rem ————————————————————————————————————————————————————————————————————————————————————————————————————— mer@


rem Basic initialization:
        @setdos /x0
        @setdos /x-5
        rem @setdos /c????
        @setdos /x0
        @echos %conceal_off%
        rem on break cancel - removed ... when things go bad sometimes we just want to skip that step so we still go through the motions and run our cleanup. Possible alternate method would be to cause ^Break to send us straight to :END/:Cleanup
        rem rem echo goaty α linish 27
        rem @call status-bar unlock
        rem rem echo goaty α linish 29
        @set DONT_MESS_WITH_MY_STATUS_BAR=1
        @set temporarily_disable_status_bar=1
        rem rem echo goaty α linish 32



rem TODOs/IDEAS:
rem Embedded todos still exist!
rem TODO check if lyric file is approved [somehow--see create-lyrics for ideas]
rem Is this still applicable?
                rem TODO: if cover song search fails, try with *current* artist instead of original artist
                rem       this will also help with songs that AREN’T covers but have composers.
                rem  So we will have to make a using_original flag that says if we flipped from artist to composer, and then if 
                rem the lyrics are rejected and that flag exists, go back to where we started. 
                rem where we started, we look at the using_original flag. 
                rem at this point, we are BEFORE where it was originally set -- very important
                rem if it’s already set, we DON’T bother changing the artist at all! and unset it!.
                rem basically gaslight our script like it never happened. then go on with our life.



rem ━━━━━ DOCUMENTATION: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem *** ADS tags used:
rem * TAG:                     * FILETYPE:  * VALID VALUES:       .........................   * MEANING:
rem   lyrics                     txt, srt     not_set, approved, not_approved, does_not_exist   for txt/srt files: The lyrics/subtitles have been approved as correct.  for srt: The karaoke transcription has been double-checked for correctness
rem   lyriclessness              audio        not_set, approved, not_approved                   for  audio  files: approved: This song does not have findable lyrics, so transcribe it using only the AI, without any priming from a lyric file
rem   is_instrumental            audio        True                                              True   == This song is an instrumental, do not try to transcribe it again.
rem   genius_searched_already    audio        True                                              True   == Genius search has already been tried
rem   genius_filename            audio        filename                                          string == Genius download was successfully performed, returning a filename representing the artist and title which may or may not be the correct one
rem   karaoke_failed             audio        True                                              True   == karaoke generation has failed and we should not waste our time trying again

:USAGE: USAGE: <this> {audio_filename} [optional mode]
:USAGE:                                 ^^^^^^^^^^^^^^
:USAGE:                                   \__ mode can be: 
:USAGE:                                           1) “SetVarsOnly” —— to just set the MAYBE_LYRICS_1/2/BROAD_SEARCH environment variables
:USAGE:                                           2)    “force”    —— to get lyrics for songs that are already in an approved-lyricLESSness state
:USAGE:                                           3)    “genius”   —— to ONLY perform the Genius.com/LyricsGenius.exe download
:USAGE: Forms of automation:
:USAGE:     if CONSIDER_ALL_LYRICS_APPROVED=1     //automatically approves lyrics at first prompt and reduces prompt from %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% to %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO% seconds
rem ━━━━━ DOCUMENTATION ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


:top
REM CONFIG: 2025: 
        iff not defined LOGS then                                                     %+ rem copy this line to create-srt-from-file as well
                mkdir c:\logs                                                         %+ rem copy this line to create-srt-from-file as well
                set logs=c:\logs                                                      %+ rem copy this line to create-srt-from-file as well
                if not isdir %logs% mkdir %logs%                                      %+ rem copy this line to create-srt-from-file as well
        endiff                                                                        %+ rem copy this line to create-srt-from-file as well
        set AUDIOFILE_TRANSCRIPTION_LOG_FILE=%LOGS%\audiofile-transcription.log       %+ rem copy this line to create-srt-from-file as well
rem CONFIG: EXTERNAL PROGRAMS:
        rem rem echo goaty α linish 69
        set DEFAULT_PLAYER_COMMAND=vlc.exe                                            %+ rem UPDATE THIS IN GET-KARAOKE TOO! ——> program we use to play audio files, i.e. VLCplayer, MPC, etc.
        set PROBER=ffprobe.exe                                                        %+ rem program we use to probe existing tag values for song title, artist, album, etc
        set PLAYER_COMMAND=vlc.exe --volume 200                                       %+ rem Command to run to play files with a media player
        set PLAYER_COMMAND=call preview-audio-file                                    %+ rem Command to run to play files with a media player
        set LYRIC_DOWNLOADER_1=lyricsgenius.exe                                       %+ rem LyricsGenius.exe is a Python package from github —— https://github.com/johnwmillr/LyricsGenius  ... There’s also this website, though I’m not sure if it’s the same thing: https://lyricsgenius.readthedocs.io/en/master/
        SET LYRIC_DOWNLOADER_1_EXPECTED_EXT=JSON                                      %+ rem LyricsGenius.exe downloads files in JSON format. And the output filename isn’t really specifiable, which creates issues. (Solution: Create temp file, run, see if latest file date-wise is the temp file you created or not, if not, then that’s the output file)
        set LYRIC_DOWNLOADER_1_SOURCE=Genius                                          %+ rem Where the LYRIC_DOWNLOADER gets its stuff from — Genius, SongText, etc
        set MOST_BYTES_THAT_LYRICS_COULD_BE=50000                                     %+ rem due to HTML, this is rather useless. Originally thought it was a chracter count of just the lyrics themselves.            
rem CONFIG: LYRIC-GOOGLE’ING BEHAVIOR:                                               
        set AUTOMATIC_HAND_EDITING_IF_GOOGLING=0                                      %+ rem It turns out that it’s annoying to have an empty TXT file opened up, Google and find no lyrics, then have the file be auto-deleted for being 0-bytes, then have the text editor complain that the file you have open no longer exists. It may make more sense to ask for hand editing AFTER googling... If we have results, yes to hand edit so we can paste them in. Otherwise, no.
        set SHOW_UNPROCESSED_LYRICS_ALSO=0                                            %+ rem 1=Show the lyrics we have in their unprocessed state prior to showing them in their processed state. Good for testing lyric-postprocessor.pl but annoying if you’re super impatient during this process
rem CONFIG: BEHAVIOR: LYRIC RETRIEVAL: DEFAULT ANSWERS:                              
        set LYRICLESSNESS_APPROVAL_CURRENT_DEFAULT_ANSWER=no                          %+ rem Default answer for whether to mark songs as lyriclessness ... If we discover a song is an instrumental, we flip this to “yes”
rem CONFIG: WAIT TIMES: DEFAULTS                                                     
        SET ADDITIONAL_HAND_EDIT_WAIT_TIME_IF_THEY_GOOGLED=220                        %+ rem Additional wait time to add on to last value in the event that they Googled the lyrics [to give time to check out the google results before the Yes/No prompt expires] ... One can get lost for several minutes searching through the google results, so best to extend this by several minutes....
        set LARGE_DOWNLOAD_WARNING_WAIT_TIME=0                                        %+ rem Wait time after announcing that the lyrics downloaded seemed larger than expected [pretty uselessi n practice]
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=180                                  %+ rem How long to show lyrics on the screen for them to get approval or not —— was 60 but running this while playing games made me miss the prompt so increased to 180
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO=4                               %+ rem How long to show lyrics on the screen for them to get approval or not —— if the environment variable says they are already pre-approved
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_FOR_FORCE_REGEN=10                   %+ rem How long to show lyrics on the screen for them to get approval or not when we are in force-regen mode and probably already did this
        set LYRIC_SELECT_FROM_FILELIST_WAIT_TIME=30                                   %+ rem how long to get an affirmative response on selecting a file from multilpe files [which can’t be done in automatic mode], before proceeding on 
        set WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH=0                                   %+ rem How long to wait after displaying the massaged artist/title prior to searching for the (if the 1st search with non-massaged failed). If set to 0, there will be no notice at all
        set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=60                  %+ rem how long to wait for “hand edit these lyrics?”-type questions
        set GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME=25                                     %+ rem how long to pause on “do you want to google the lyrics?”-type questions
        set LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS=800                            %+ rem give us 15 minutes to hand edit in case we get distracted
        set PAUSED_DEBUG_WAIT_TIME=5                                                  %+ rem how long to pause on debug statements we’re particularly focusing on
        SET APPROVE_LYRICLESS_SONGS_WAIT_TIME=18                                      %+ rem how long to pause on the prompt: “Do you want to approve “lyriclessness” status, and officially give up on finding lyrics for this song?”
rem CONFIG: WAIT TIMES: MODE-DEPENDENT:                                              
        REM DEPENDING ON CALLING SCRIPT:                                             
                iff "%PARENT_BAT%" == "get-lyrics" then                              
                        SET APPROVE_LYRICLESS_SONGS_WAIT_TIME=5                       %+ rem how long to pause on the prompt: “Do you want to approve “lyriclessness” status, and officially give up on finding lyrics for this song?”
                else                                                                 
                        SET APPROVE_LYRICLESS_SONGS_WAIT_TIME=22                      %+ rem how long to pause on the prompt: “Do you want to approve “lyriclessness” status, and officially give up on finding lyrics for this song?”
                endiff        
        rem IF LYRICS ARE PRE-APPROVED:
                rem rem echo goaty α linish 151
                iff "1" == "%CONSIDER_ALL_LYRICS_APPROVED%" then
                        set LARGE_DOWNLOAD_WARNING_WAIT_TIME=0                        %+ rem Wait time after announcing that the lyrics downloaded seemed larger than expected [pretty uselessi n practice]
                        set LYRIC_SELECT_FROM_FILELIST_WAIT_TIME=3                    %+ rem how long to get an affirmative response on selecting a file from multilpe files [which can’t be done in automatic mode], before proceeding on 
                        set WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH=0                   %+ rem How long to wait after displaying the massaged artist/title prior to searching for the (if the 1st search with non-massaged failed)
                        set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=2   %+ rem how long to wait for “hand edit these lyrics?”-type questions
                        set GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME=1                      %+ rem how long to pause on “do you want to google the lyrics?”-type questions
                        SET ADDITIONAL_HAND_EDIT_WAIT_TIME_IF_THEY_GOOGLED=1          %+ rem Additional wait time to add on to last value in the event that they Googled the lyrics [to give time to check out the google resuls before the Yes/No prompt expires]
                endiff
rem CONFIG: DEBUG:
        set DEBUG_VALUE_TRANSFER=0
        set DEBUG_TOKEN_PROCESSING=0    
        set DEBUG_DISPLAY_PROBE_RESULTS=1                             %+ rem whether we want to display the g values to the screen for debug purposes


rem ——————————————————————————————————————————————————————————————————————————————————————————

rem USAGE:
        rem rem echo goaty α linish 87
        iff "%1" == "" then
                echo.
                gosub divider
                %color_advice%
                echo USAGE: %0 {%italics_on%audio_file%italics_off%}
                echo                 ...where audio_file is the audio file who’s tags will be examined to obtain the artist name and song title
                echo.
                echo ALTERNATE USAGE: %0 {%italics_on%audio_file%italics_off%} SetVarsOnly —— sets the FILE_SONG and FILE_ARTIST / album / orig_artist environment variables for this song, but does nothing else
                gosub divider
                goto :END
        endiff

rem For testing the “divider” subroutine:      
        iff "%1" == "divider" then
                gosub divider
                goto :END
        endiff


rem SETUP: GRAB CALLING BAT FILE NAME, IF ANY:
        set PARENT_BAT=%@NAME[%_PBATCHNAME] %+ rem the calling BAT filename without path or extension i.e. “whatever” as opposed to “c:\bat\whatever.bat”

rem DEBUG: 
        rem call bigecho CONSIDER_ALL_LYRICS_APPROVED is %CONSIDER_ALL_LYRICS_APPROVED% 
        rem set SKIP_MANUAL_SELECTION=1 to skip the manual select part

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Remove any trash environment variables left over from a previously-aborted run which might interfere with the current run:
        rem rem echo goaty α linish 151
        rem unset /q LYRIC_RETRIEVAL_1_FAILED
        unset /q LD1_MASSAGED_ATTEMPT_1 WE_GOOGLED TRY_SELECTION_AGAIN ONLY_ONE_FILE_AND_IT_WAS_TRIED cover_original_attempt DO_NOT_ASK_TO_HAND_EDIT ALREADY_HAND_EDITED already_searched_for* GOOGLE_NOW ANSWER goto_download_with_lyric_downloader_1 goto_download_with_lyric*
        set FORCE_ASK_TO_APPROVE_LYRICLESSNESS=0
        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 1 >nul 
        set FORCE_HAND_EDIT=0
        unset /q DO_NOT_ASK_TO_HAND_EDIT
        set LYRICS_JUST_DISAPPROVED=0
        set JUST_APPROVED_LYRICLESSNESS=0
        set JUST_APPROVED_LYRICS=0
        set LYRICS_ACCEPTABLE=0
        set JUST_GENERATED_LYRICS=0
        set JUST_CONVERTED_LRC_TO_TEXT=0
        set JUST_RENAMED_TO_INSTRUMENTAL=0
        set FORCE_AI_ENCODE_FROM_LYRIC_GET=0
        set GOTO_END_AFTER_GET_LYRICS_CALLED=0
        set  found_broad_lyrics_branch_1=0
        set LYRIC_SUCCESS_CELEBRATION_DISPLAYED=0
        set debanded=0
        unset /q LYRIC_SEARCH_FAILED GENIUS_ONLY ABANDONED_SEARCH LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE GOTO_END did_not_go_to_end_169 lyric_downloader_initialized
        rem Leave this one for when we are calling get-lyrics from create-karaoke: unset /q LYRIC_STATUS
        rem Leave this one for when we are calling get-lyrics from create-karaoke: unset /q LYRICLESSNESS_STATUS
        set goto_END=0

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Force mode?
        rem rem echo goaty α linish 172
        set FORCE_REDOWNLOAD=0
        if "%1" == "force" (
                set FORCE_REDOWNLOAD=1 
                shift
        ) else (
                if "%1" == "force" .or.  "%2" == "force" .or.  "%3" == "force" .or.  "%4" == "force" .or.  "%5" == "force" (
                        set FORCE_REDOWNLOAD=1 
                )
        )
        if "1" == "%FORCE_REDOWNLOAD%" (
                unset /q last*
                unset /q already*
        )       
        rem echo FORCE_REDOWNLOAD is “%FORCE_REDOWNLOAD%”         %+ pause
     
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem VALIDATE ENVIRONMENT [once per session]:
        rem rem echo goaty α linish 189
        iff 1 ne %VALIDATED_GLVMS_ENV then
                call validate-in-path              %LYRIC_DOWNLOADER_1% %PROBER% %PLAYER_COMMAND% delete-zero-byte-files get-lyrics-with-lyricsgenius-json-processor.pl tail echos  divider unimportant success alarm unimportant debug warning error fatal_error advice  important important_less celebrate eset eset.bat eset-alias.bat insert-before-each-line.pl insert-before-each-line.py pause-alias google.bat google.py google.pl insert-before-each-line.py newspaper.bat print_with_columns.py print-with-columns.bat newspaper.bat srt2lrc.py change-single-quotes-to-double-apostrophes.py add-ADS-tag-to-file.bat remove-ADS-tag-from-file.bat display-ADS-tag-from-file.bat display-ADS-tag-from-file.bat approve-lyrics.bat disapprove-lyrics.bat display-lyric-status-for-file.bat review-lyrics.bat review-files.bat approve-lyric-file.bat disapprove-lyric-file.bat approve-subtitle-file.bat disapprove-subtitle-file.bat get-lyric-status.bat approve-LYRICLESSNESS_STATUS-file.bat disapprove-lyriclessness-for-file.bat unapprove-lyriclessness-for-file.bat cut.exe srt2txt.py lrc2txt.py rn.bat 
                rem  call unimportant               "Validated: lyric downloader, audio file prober"
                call validate-environment-variables BAT TEMP LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME LYRIC_SELECT_FROM_FILELIST_WAIT_TIME cool_question_mark ANSI_COLOR_BRIGHT_RED italics_on italics_off ANSI_COLOR_BRIGHT_YELLOW blink_on blink_off star ANSI_COLOR_GREEN ANSI_GREEN ansi_color_bright_green ansi_reset bright_on bright_off   underline_on underline_off    emoji_warning check EMOJI_MAGNIFYING_GLASS_TILTED_RIGHT EMOJI_red_QUESTION_MARK LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS ANSI_COLOR_WARNING_SOFT LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO ANSI_COLOR_DEBUG ansi_color_prompt ansi_color_orange CONNECTING_EQUALS connecting_minus bold_on bold_off italics_on italics_off blink_on blink_off ansi_colors_have_been_set LQ RQ EMOJI_DESKTOP_COMPUTER EMOJI_EAR CHECK NO
                call validate-functions             cool_text rainbow_string ansi_rgb
                call validate-plugin                StripANSI
                call checkeditor
                rem Default values to help portability:
                        if not defined ESCAPE                                        set                                            ESCAPE=%@CHAR[27]
                        if not defined ANSI_ESCAPE                                   set                                       ANSI_ESCAPE=%ESCAPE%[
                        if not defined ANSI_CURSOR_CHANGE_TO_DEFAULT                 set        ANSI_CURSOR_CHANGE_TO_DEFAULT=%ANSI_ESCAPE%0 q
                        if not defined ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING          set ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING=%ANSI_ESCAPE%1 q
                        if not defined ANSI_CURSOR_CHANGE_TO_BLOCK_STEADY            set ANSI_CURSOR_CHANGE_TO_BLOCK_STEADY=%ANSI_ESCAPE%2 q
                        if not defined ANSI_CURSOR_CHANGE_TO_UNDERLINE_BLINKING      set ANSI_CURSOR_CHANGE_TO_UNDERLINE_BLINKING=%ansi_escape%3 q
                        if not defined ANSI_CURSOR_CHANGE_TO_UNDERLINE_STEADY        set ANSI_CURSOR_CHANGE_TO_UNDERLINE_STEADY=%ansi_escape%4 q
                        if not defined ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_BLINKING   set ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_BLINKING=%ansi_escape%5 q
                        if not defined ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_STEADY     set ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_STEADY=%ansi_escape%6 q
                        rem TODO: ansi_color_yellow, bold on, bold off
                        if "%@ANSI_CURSOR_CHANGE_COLOR_WORD[]" == ""            function ANSI_CURSOR_CHANGE_COLOR_WORD=`%@char[27][ q%@char[27]]12;%1%@char[7]`                                
                        if not defined FILEMASK_AUDIO                                set FILEMASK_AUDIO=*.mp3;*.wav;*.rm;*.voc;*.au;*.mid;*.stm;*.mod;*.vqf;*.ogg;*.mpc;*.wma;*.mp4;*.flac;*.snd;*.aac;*.opus;*.ac3;*.dtshd
                set  VALIDATED_GLVMS_ENV=1
        endiff

        if not defined TRANSCRIBER_VALID_EXTENSIONS gosub "%BAT%\create-srt-from-file.bat" set_TRANSCRIBER_VALID_EXTENSIONS_AND_LOCK_FILE_NAME

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem VALIDATE PARAMETERS [every time]:
        rem rem echo goaty α linish 216
        setdos /x-4
        set  AUDIO_FILE=%@UNQUOTE["%1"]
        set  LRC_SIDECAR_FILENAME=%@NAME[%AUDIO_FILE].lrc
        set  SRT_SIDECAR_FILENAME=%@NAME[%AUDIO_FILE].srt
        set  TXT_SIDECAR_FILENAME=%@NAME[%AUDIO_FILE].txt
        set            LYRIC_FILE=%@NAME[%AUDIO_FILE].txt
        setdos /x0


        :process_audiofile_parameter_again
        rem rem echo goaty α linish 226
        setdos /x-4
        set  AUDIO_FILE_FULL=%@UNQUOTE[%@FULL["%AUDIO_FILE%"]]
        set  AUDIO_FILE_BASE=%@UNQUOTE[%@NAME["%AUDIO_FILE%"]]
        set  AUDIO_FILE_NAME=%@UNQUOTE[%@NAME["%AUDIO_FILE%"]]
        set  AUDIO_FILE_EXT=%@UNQUOTE[%@EXT["%AUDIO_FILE%"]]
        setdos /x0

        rem Audio file extension correction for common invocation mistakes (i.e. calling this on the JSON instead of the MP3/FLAC):
                iff     "%AUDIO_FILE_EXT%" == "json" then                                                                  %+ rem If we invoked a JSON accidentally:
                        set audio_file=%audio_file_base%.flac                                                              %+ rem   Try it with FLAC instead
                        set oops_was_json=1                                                                                %+ rem   And remember we tried...
                        goto :process_audiofile_parameter_again                                                            %+ rem   And go try again
                elseiff "%AUDIO_FILE_EXT%" == "flac" .and. not exist "%AUDIO_FILE%" .and. "1" == "%oops_was_json%" then    %+ rem If it was a JSON and the FLAC we tried failed:
                        set audio_file=%audio_file_base%.mp3                                                               %+ rem   Try it with mp3 instead
                        set oops_was_json=0                                                                                %+ rem   but don’t try it ever again
                        goto :process_audiofile_parameter_again                                                            %+ rem   ...Now Go try again!
                endiff


        rem Now see if it exists....
                if not exist "%AUDIO_FILE%"  call validate-environment-variable AUDIO_FILE "1ˢᵗ parameter to get-lyrics-for-file must be an audio file that exists! [PBATCHNAME=%@UNQUOTE["%_PBATCHNAME"]] [full command line=“%@UNQUOTE["%0"] %@UNQUOTE["%*"]”]"

        rem Get the folder that the song is in:
                setdos /x-4
                rem SONG_DIR=%@UNQUOTE[%@PATH["%AUDIO_FILE%"]]
                set SONG_DIR=%@UNQUOTE["%@PATH["%@UNQUOTE["%@FULL["%AUDIO_FILE%"]"]"]"]
                setdos /x0

        rem Validate the extension of the audio file:
                call validate-file-extension "%AUDIO_FILE%" %FILEMASK_AUDIO%


        rem Debug info:
                iff "False" == "True" then
                        echo        CWD                   is %_CWD
                        echo        AUDIO_FILE            is %AUDIO_FILE%
                        echo        AUDIO_FILE_FULL       is %AUDIO_FILE_FULL%
                        echo        @PATH["%AUDIO_FILE%"] is %@PATH["%AUDIO_FILE%"]
                        echo        if "%_CWD\" != "%SONG_DIR%"   pushd "%SONG_DIR%"
                        pause
                endiff

        if "%_CWD\" != "%SONG_DIR%"   pushd "%SONG_DIR%"

        rem Determine if GENIUS-ONLY get-lyric run, set GENIUS_ONLY appropriately:
                rem rem echo goaty α linish 271
                iff "%2" == "genius" .or. "%3" == "genius" .or. "%4" == "genius" .or. "%5" == "genius" then
                        set genius_only=1
                        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=8
                else
                        set genius_only=0
                endiff

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Skip if instrumental....
        rem echo [AA-D] get-lyrics: INITIAL lyric status ===== “%LYRIC_STATUS%”, INITIAL lyriclessness status ===== “%LYRICLESSNESS_STATUS%”
        rem rem echo goaty α linish 281
        iff 1 eq %@RegEx[instrumental,"%AUDIO_FILE%"] then
                gosub divider
                rem echo.
                call bigecho "%ansi_color_warning_soft%%emoji_warning% Instrumental encountered!%ansi_color_normal% %emoji_warning%"
                echo %ANSI_COLOR_WARNING%%emoji_warning% This is an instrumental track! %emoji_warning%%ansi_color_normal% %ansi_color_bright_yellow%%connecting_minus%%connecting_minus% %ansi_color_yellow%%audio_file%%ansi_color_normal%
                set FORCE_ASK_TO_APPROVE_LYRICLESSNESS=1
                set LYRICLESSNESS_APPROVAL_CURRENT_DEFAULT_ANSWER=yes
                goto :ask_to_approve_lyriclessness
        endiff


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Skip if already an approved-for-lyricLESSness song....
        rem set LYRICLESSNESS=%@ExecStr[TYPE "%@UNQUOTE["%AUDIO_FILE%"]:lyriclessness" >&>nul]   %+ rem Read lyriclessness status        
        rem ^^^^^ moved to beginning of file: call get-lyriclessness-status "%AUDIO_FILE%"
        rem  call get-lyriclessness-status "%AUDIO_FILE%" 🐐1 status=%RECEIVED_VALUE / %LYRICLESSNESS_STATUS
        rem echo %ansi_color_subtle%* LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, FORCE_REGEN=“%FORCE_REGEN%” , audio_file=“%audio_file%” %ansi_color_normal% %conceal_on%goat%conseal_off%
        rem echo  [EL-A] get-lyrics: INITIAL lyric status ===== “%LYRIC_STATUS%” .... LYRICLESSNESS_STATUS ==== “%LYRICLESSNESS_STATUS%” ............... FORCE_REDOWNLOAD=“%FORCE_REDOWNLOAD%”  ............. %%1=“%1” %%2=“%2”

        rem rem echo goaty α linish 300
        if "%LYRICLESSNESS_STATUS%"  == "APPROVED" goto :done_skip_if_already_approved_lyriclessness                                                                                                                                                               
        if "%FORCE_REDOWNLOAD%"      ==   "1"      goto :done_skip_if_already_approved_lyriclessness
        if "%1" == "force" .or. "%2" == "force"    goto :done_skip_if_already_approved_lyriclessness
        if "%3" == "force" .or. "%4" == "force"    goto :done_skip_if_already_approved_lyriclessness
        if "%5" == "force" .or. "%6" == "force"    goto :done_skip_if_already_approved_lyriclessness
                                                   goto :done_skip_if_already_approved_lyriclessness

                        rem if "" == "%LYRICLESSNESS_STATUS%" set LYRICLESSNESS_STATUS=APPROVED
                        :do_it_9024398042890234
                        rem not sure about this blank: echo.
                        gosub divider
                        echo %ansi_color_bright_yellow%%star% File already marked as lyric%underline_on%less%underline_off%. %italics_on%Not%italics_off% fetching lyrics.
                        echo %ansi_color_bright_white%%star% %faint_on%Filename: %italics_on%%AUDIO_FILE%%italics_off% %faint_off%
                        echo %ansi_color_advice%%@CHAR[55357]%@CHAR[56393] Add the “%bold_on%force%bold_off%” parameter to skip this check %@CHAR[55357]%@CHAR[56392]
                        gosub divider
                        iff "1" == "%FORCE_REDOWNLOAD%" then
                                echo %ansi_color_bright_yellow%%star% Forcing because you said so!%ansi_color_normal%
                                goto :done_skip_if_already_approved_lyriclessness
                        endiff
                        goto :END                                                    %+ pause "this shouldn’t happen!"

        :done_skip_if_already_approved_lyriclessness

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Skip if extension that can’t have lyrics:
        rem echo  [FL-A] get-lyrics: INITIAL lyric status ===== “%LYRIC_STATUS%” .... LYRICLESSNESS_STATUS ==== “%LYRICLESSNESS_STATUS%” ............... FORCE_REDOWNLOAD=“%FORCE_REDOWNLOAD%”  ............. %%1=“%1” %%2=“%2”
        rem rem echo goaty α linish 328
        iff "%AUDIO_FILE_EXT%" == "cmf" .or. "%AUDIO_FILE_EXT%" == "stm" .or. "%AUDIO_FILE_EXT%" == "s3m" .or. "%AUDIO_FILE_EXT%" == "mid" .or. "%AUDIO_FILE_EXT%" == "midi" then
                gosub divider
                echo %ANSI_COLOR_LESS_IMPORTANT%%EMOJI_WARNING% Files of extension “%italics_on%%AUDIO_FILE_EXT%%italics_off%” cannot have lyrics!%ANSI_COLOR_NORMAL%
                call approve-lyriclessness "%AUDIO_FILE%"
                set  JUST_APPROVED_LYRICLESSNESS=1
                set  LYRICLESSNESS_STATUS=APPROVED        
                goto :END
        endiff


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


rem Check if the lyrics are already approved...
        rem rem echo goaty α linish 432
        echo 🐐 [GL-A] INITIAL lyric         status ===== “%LYRIC_STATUS%”
        if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status
        echo 🐐 [GL-Z] INITIAL lyric         status ===== “%LYRIC_STATUS%”
        if "%LYRIC_STATUS%" == "APPROVED" (
                gosub divider
                echo Tracer we're here in approval-land right? [1]
                echo %ANSI_COLOR_WARNING%%EMOJI_CAUTION% Lyrics already approved: %faint_on%%LYRIC_FILE%%faint_off% %ansi_color_normal%``
                echo Tracer we're here in approval-land right? [2]
                goto :END
                set goto_end=1
        )
        if "1" == "%goto_end%" goto :END

        gosub "%BAT%\create-srt-from-file.bat" refresh_lyriclessness_status
        rem echo [GM]   INITIAL lyriclessness status ===== “%LYRICLESSNESS_STATUS%”
        if "%LYRICLESSNESS_STATUS%" != "APPROVED" goto :not_lyricless
                echo %ANSI_COLOR_WARNING_SOFT%%blink_on%%STAR2%%blink_off% Already marked %italics_on%lyric%underscore_on%less%underscore_off%%italics_off%!%ansi_color_normal% [force_regen=%force_regen%]
                if 1 ne %FORCE_REGEN% .and. "%1" !=  "force" .and. "%2" != "force" .and. "%3" !=  "force" .and. "1" != "%did_not_go_to_end_169%" goto :END
                set did_not_go_to_end_169=1
        :not_lyricless

rem Delete lyrics if they are zero bytes...
        if 0 eq %@FILESIZE["%LYRIC_FILE%"] (
                call warning "Deleting 0-byte lyric file: %faint_on%%LYRIC_FILE%%faint_off%" silent
                echo ray | *del /q "%LYRIC_FILE%"
                goto :top
        )

rem Catch our breath
        if "1" == "%goto_end%"      goto :END
        if not exist "%LYRIC_FILE%" goto :start_lyric_download_process
        rem call get-lyric-status "%LYRIC_FILE%" silent
        if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status

rem Skip if the lyrics are already approved:
    rem iff "%LYRIC_STATUS%" == "APPROVED"                             then
        rem rem echo goaty α linish 378
        iff "%LYRIC_STATUS%" == "APPROVED" .and. "%2" != "SetVarsOnly" then
                call success "Lyrics already approved for “%italics_on%%@name[%audio_file%]%italics_off%”!"
                set EDIT_KARAOKE_AFTER_CREATION_WAIT_TIME=10                 %+ rem 🐮 hard-coded value warning ... plus this is actually a value from create-srt-from-file
                set GOTO_END=1
                rem echo going to end [2q4] goto_end=“%GOTO_END%”
        endiff
        if "1" == "%goto_end%" goto :END

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem If we are in Genius-download-only mode, skip if we’ve already tried it for this song:
        rem goaty α linish 389
        iff "1" == "%GENIUS_ONLY%" then
                set GENIUS_SEARCHED_ALREADY=%@ExecStr[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already" >&>nul]`` 
                rem set GENIUS_SEARCHED_ALREADY=0 %+ rem FORCING A REDO OF OLD SEARCHES... LEAVE THIS OFF UNTIL PROJECT IS MORE COMPLETE.. LONGTERM  🐐

                rem echo what about: %@ExecStr[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"]`` 
                rem echo  Trying this: type `<`"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"
                rem echos Trying this: type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"
                rem type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"
                rem echo hmm %@EXECSTR[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"]
                rem set hmm1=%@EXECSTR[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"]
                set hmm2=%@EXECSTR[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already" >&>nul]
                rem echo hmm1? %hmm1
                rem echo hmm2? %hmm2
                echo.

                rem TODO fix this ’hmm2’ name stuff

                rem echo GENIUS_SEARCHED_ALREADY is “%GENIUS_SEARCHED_ALREADY%” for “%audio_file%”  🐻
                iff "%hmm2%" == "True" then
                        gosub divider
                        gosub DisplayAudioFileName
                        echo %star% %ansi_color_yellow%Already searched this file in genius-only mode. Skipping.%ansi_color_reset%
                        goto :END
                endiff
        endiff


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Check if we already have a TXT file in the same folder and shouldn’t even be running this:
        rem goaty α linish 419
        iff exist "%LYRIC_FILE%" .and. %@FILESIZE["%LYRIC_FILE%"] gt 0 then

                rem Warn that lyrics already exist:
                        rem echos  ``
                        iff 1 ne %JUST_GENERATED_LYRICS then
                                gosub divider
                                if "%LYRICLESSNESS_STATUS%" == "" call get-lyriclessness-status "%AUDIO_FILE%"
                                if "%LYRIC_STATUS%"         == "" call get-lyric-status         "%LYRIC_FILE%"

                                set NOT_APPROVED_STR=%ansi_color_red%NOT_APPROVED
                                echo %ansi_color_warning_soft%%star2% Current folder:            %ansi_color_bright_green%“%ansi_color_warning_soft%%faint_on%%[_CWP]%faint_off%%ansi_color_bright_green%”
                                echo %ansi_color_warning_soft%%star2% Lyrics already exist for:  “%emphasis%%AUDIO_FILE%%deemphasis%%ansi_color_bright_green%”
                                echo %ansi_color_warning_soft%%star2% Lyrics approval status:    “%emphasis%%@IF["" !=         "%LYRIC_STATUS%",%LYRIC_STATUS%,%NOT_APPROVED_STR%]%deemphasis%%ansi_color_bright_green%”
                                echo %ansi_color_warning_soft%%star2% Lyricless approval status: “%emphasis%%@IF["" != "%LYRICLESSNESS_STATUS%",%LYRICLESSNESS_STATUS%,%NOT_APPROVED_STR%]%deemphasis%%ansi_color_bright_green%”%ansi_color_normal%
                        endiff

                rem If we’re in “Genius” mode—which is for unattended mass/batch 1ˢᵗ-pass Genius downloads, 
                rem then abort. We don’t want unattended lyric-overwrites. Those are for when we are at the keyboard.
                rem This mode is for when we are asleep/unattended
                        if 1 eq %GENIUS_ONLY% goto :END





rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————
:start_lyric_download_process
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem Let user know what we’re about to do!
iff "%2" != "SetVarsOnly" then

        rem 2024/12/24: not sure that i want this now? it may depend on pbatchname tbh: call  divider
        echos %ANSI_RESET%
        iff "%@UNQUOTE[%PARENT_BAT%]" != "" then
                rem echo PBATCHNAME=“%_PBATCHNAME”
                gosub divider
        endiff
        setdos /x-4
        rem  bigecho "%STAR% Getting lyrics for “%@ansi_rgb[170,170,244]%italics_on%%audio_file%%italics_off%%ansi_color_normal%”"
        rem  ^^^^^^^^ decided to expand this into 2 lines to reduce line-wrap errors
        set quote_color=%ansi_color_bright_green%

        iff "%LYRICLESSNESS_STATUS%" == "APPROVED" then
                call warning "is this the infinite loop?!?!?!"
                goto :END
        endiff
        rem 

        set                         VERB=Getting                                               
        if   exist "%LYRIC_FILE%" set VERB=Aligning
        call bigecho "%STAR% %ansi_color_magenta%%VERB% lyrics for: %quote_color%“%@ansi_rgb[170,170,244]%italics_on%%ansi_color_yellow%%@NAME[%audio_file%]%italics_off%%quote_color%”%ansi_color_normal%"
        set  folder_value=%@PATH[%audio_file%]
        if "%folder_value%" == "" set  folder_value=%_CWP
        if "%folder_value%" != "" call bigecho "%STAR% %ansi_color_magenta%in: %quote_color%“%@ansi_rgb[170,170,244]%italics_on%%ansi_color_yellow%%folder_value%%italics_off%%quote_color%”%ansi_color_normal%"
        if 1 ne %DONT_MESS_WITH_MY_STATUS_BAR% call status-bar "%VERB% lyrics for: %@NAME[%audio_file%]"
        setdos /x0
        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[bright cyan]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%

endiff

rem DEBUG: echo pbatchname = %_PBATCHNAME  %+ pause
                      

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————


rem Get artist and song so we can use them to download lyrics:
        :start_probing
        if %DEBUG gt 0 .or. %DEBUG_VALUE_TRANSFER% gt 0 call unimportant "Probing file..."

        rem if "%LYRICLESSNESS_STATUS%" == "" call get-lyriclessness-status "%AUDIO_FILE%"
        if "%LYRICLESSNESS_STATUS%" == "" .and. exist "%@UNQUOTE["%AUDIO_FILE%"]" set LYRICLESSNESS_STATUS=%@EXECSTR[type <"%@unquote["%AUDIO_FILE%"]:lyriclessness" >&>nul]``
        rem echo 🦯 start_probing .. LYRICLESSNESS_STATUS is “%LYRICLESSNESS_STATUS%”

        rem if "%LYRICLESSNESS_STATUS%" == "APPROVED"

        goto :probe_faster
        
        
                :probe_slower
                timer /5 on >nul
                set       FILE_ALBUM=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=album  -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set      FILE_ARTIST=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=artist -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set        FILE_SONG=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=title  -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set FILE_ORIG_ARTIST=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=TOPE   -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set PROBED_FILE_ALBUM=%PROBED_FILE_ALBUM%
                set PROBED_FILE_ARTIST=%FILE_ARTIST%
                set PROBED_FILE_SONG=%FILE_SONG%
                set PROBED_FILE_ORIG_ARTIST=%FILE_ORIG_ARTIST%
                echos %ansi_color_yellow%
                timer /5 off %+ rem 0.946-.948
                :probe_slower_end
                
                
                

        :probe_faster
                rem timer /5 on >nul
                
                rem Handle undefined variables
                        set "probe_tit="
                        set "probe_art="
                        set "probe_alb="
                        set "probe_tpe="
                        set "probe_hmm="
                                                
                rem Skip if we already probed the file (for instance, in the outer-layer/LRC-creator):
                        set already_probed=0
                        iff "%last_file_probed%" == "%AUDIO_FILE%" .and. defined probe_output .and. "" != "%PROBE_OUTPUT%" then
                                if %DEBUG_VALUE_TRANSFER gt 0 (echo Skipping probe because we already probed %audio_file%)
                                goto :already_probed
                        endiff
                        
                rem Clear any previous leftover probe values:
                        set       FILE_ALBUM=
                        set      FILE_ARTIST=
                        set        FILE_SONG=
                        set FILE_ORIG_ARTIST=
                        
                rem Probe the file:                        
                        set delimeter_ascii=14

                        set PROBE_COMMAND=%PROBER% -v quiet -show_entries format_tags=title,artist,album,TOPE,composer -of compact=p=0:nk=0:s="%@CHAR[%delimeter_ascii%]"  "%AUDIO_FILE%"
                        if %DEBUG_VALUE_TRANSFER% gt 0 (echo PROBE_COMMAND=“%PROBE_COMMAND%”)

                        unset /q probe_output        
                        set probe_output=%@execstr[%PROBE_COMMAND% |:u8 change-single-quotes-to-double-apostrophes.py] %+ rem Must convert away the quotes before bandying this value about at the command line
                        if %DEBUG_VALUE_TRANSFER% gt 0 (echo  PROBE_OUTPUT=“%PROBE_OUTPUT%”)

                        set last_file_probed=%AUDIO_FILE%


                rem Split the string into tokens:
                        for /f "tokens=1-5 delims=%@CHAR[%delimeter_ascii%]" %%a in ("%probe_output%") do (
                                if %DEBUG_VALUE_TRANSFER gt 0 .or. %DEBUG_TOKEN_PROCESSING gt 0 (echo       %faint_on%%wrench% processing tokens (tit=%[faint_off]%%a %@ansi_move_left[1]%[faint_on]) (art=%[faint_off]%%b %@ansi_move_left[1]%[faint_on]) (alb=%[faint_off]%%c %@ansi_move_left[1]%[faint_on]) (tope=%[faint_off]%%d %@ansi_move_left[1]%[faint_on]) (hmm=%[faint_off]%e %@ansi_move_left[1]%[faint_on])%[faint_off])
                                set "probe_tit=%%a"
                                set "probe_art=%%b"
                                set "probe_alb=%%c"
                                set "probe_tpe=%%d"
                                set "probe_hmm=%%e"
                        )

                rem It doesn’t count if it matches the a/b/c/d/e var we already had outside of the split ... those are urnelated single-letter environment variables
                        if "%probe_tit" == "%a" set probe_tit=
                        if "%probe_art" == "%b" set probe_art=
                        if "%probe_alb" == "%c" set probe_alb=
                        if "%probe_tpe" == "%d" set probe_tpe=
                        if "%probe_hmm" == "%e" set probe_hmm=

                rem Save post-probed values for auditing
                        unset /q PROBED*
                        set PROBED_FILE_SONG=%probe_tit%
                        set PROBED_FILE_ARTIST=%probe_art%
                        set PROBED_FILE_ALBUM=%probe_alb%
                        set PROBED_FILE_ORIG_ARTIST_TOPE=%probe_tpe%
                        set PROBED_FILE_ORIG_ARTIST_HMMM=%probe_hmm%

                rem Untested attempt to copmensate for original artist/composer difference in mp3/flac tags:
                        if "" == "%probe_tpe" .and. "" != "%probe_hmm%" (set probe_tpe=%probe_hmm%)
                        
                rem Transfer values over to our variables:         
                        for %%tmpVarName in (probe_tit, probe_art, probe_alb, probe_tpe, probe_hmm) do (
                                set value=%[%tmpvarname]                                
                                set LEFT_NIN=%@left[ 9,%value%]
                                set LEFT_TEN=%@left[10,%value%]
                                set LEFT_ELV=%@left[11,%value%]
                                set LEFT_THI=%@left[13,%value%]

                                if %DEBUG_VALUE_TRANSFER gt 0 (echo %newline%! %%tmpVarName  is %lq%%TmpVarName%%rq% is %lq%%value%%rq% %+ echo    left_nin is %lq%%left_nin%%rq%%+ echo    left_ten is %lq%%left_ten%%rq% %+ echo    left_elv is %lq%%left_elv%%rq% %+ echo    left_thi is %lq%%left_thi%%rq%)
             
                                if "%LEFT_TEN%" == "tag:TITLE=" (
                                        if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_SONG=%@right[%@eval[%@len[%value]-10],%value])
                                        set FILE_SONG=%@right[%@eval[%@len[%value]-10],%value]
                                ) else (
                                        if "%LEFT_ELV%" == "tag:ARTIST=" (
                                                set FILE_ARTIST=%@right[%@eval[%@len[%value]-11],%value]
                                                if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ARTIST=%@right[%@eval[%@len[%value]-11],%value])
                                        ) else (
                                                if "%LEFT_TEN%" == "tag:ALBUM=" (
                                                        set tmpvalue=%@right[%@eval[%@len[%value]-10],%value]
                                                        set FILE_ALBUM=%tmpvalue%
                                                        if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ALBUM=%lq%%tmpvalue%%rq%)
                                                ) else (
                                                        if "%LEFT_THI%" == "tag:COMPOSER=" (
                                                                set FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-13],%value]
                                                                if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-13],%value])
                                                        ) else (
                                                                if "%LEFT_NIN%" == "tag:TOPE=" (
                                                                        set FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-9],%value]
                                                                        if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-9],%value])
                                                                )
                                                        )
                                                )
                                        )
                                )
                        )                        
                        iff 1 eq %DEBUG_DISPLAY_PROBE_RESULTS% then
                                color bright red on black
                                echo    🔬 probed song: %probe_tit%
                                echo    🔬 probed band: %probe_art%
                                echo    🔬 probed albm: %probe_alb%
                                echo    🔬 probed tope: %probe_tpe%
                                echo    🔬 probed hmmm: %probe_hmm%
                                %color_normal%
                        endiff                                

        rem If we didn’t get a title, use the filename after the number, i.e. “01_Time.flac" ——> “Time"
                if "" == "%FILE_SONG%" (set FILE_SONG=%@rereplace[[\d]+_,,%@name["%AUDIO_FILE%"]])

        rem If we didnt’ get an artist, but the filename is a " - " type name, then get the aprt before the " - "                
                iff "" == "%FILE_ARTIST%" .and. 1 eq  %@RegEx[ \- ,"%AUDIO_FILE%"] then
                        echo       Attempting to create file_artist from audio filename.... 🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕 
                        set FILE_ARTIST=%@UNQUOTE[%@ReReplace[[0-9]+_,,%@ReReplace[ \- .*$,,"%AUDIO_FILE%"]]]
                endiff

        rem If we didn’t get an original artist, also check fo the Composer tag which is the only place it would likely be in a FLAC file...
                rem NO! ffprobe does some voodoo behind the scenes making this unnecessary: if "" == "%FILE_ORIG_ARTIST%" (set FILE_ORIG_ARTIST=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=Composer -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py])

        rem “Title” is better than “Song”, but we are doing both for ease-of-remembrance
                set FILE_TITLE=%FILE_SONG%

        rem Done probing!                
                if %DEBUG gt 0 call unimportant "Probing done"         
                :already_probed


rem Update window title:
        if %DEBUG gt 0 call unimportant "setting window title to “%FILE_ARTIST% – %FILE_SONG%”"
        set title=%FILE_ARTIST% – %FILE_SONG%
        title %title%
        if %vebose gt 0 call unimportant "Title set" 

rem Back up original values of these variables because we change them as we try various different ways of searching:
        set      FILE_ARTIST_INITIAL=%FILE_ARTIST%
        set FILE_ORIG_ARTIST_INITIAL=%FILE_ORIG_ARTIST%
        set       FILE_ALBUM_INITIAL=%FILE_ALBUM%
        set        FILE_SONG_INITIAL=%FILE_SONG%
        set       FILE_TITLE_INITIAL=%FILE_SONG%
        if %vebose gt 0 call unimportant "Original values saved" 


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem Temp file we sometimes use to hold files-to-review to be reviewed in
        set TMPREVIEWFILE=%temp%\review-file.%_datetime.%_PID.txt

rem If we are in the special mode where we ONLY set environment variables, go to that section:
        if "%2" == "SetVarsOnly" (goto :SetVarsOnly_skip_to_1)

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem Debug info:
        rem call unimportant                    "input file exists: %1"
        if 1 eq %DEBUG_DISPLAY_PROBE_RESULTS% gosub debug "Retrieved:%TAB%   artist=“%FILE_ARTIST%”%TAB%%tab%%tab%%tab%        title=“%FILE_SONG%”%TAB%%tab%%tab%%tab%        album=“%FILE_ALBUM%”%TAB%%tab%%tab%%tab%  orig artist=“%FILE_ORIG_ARTIST%”%tab%%tab%  probe_tpe=“%probe_tpe%”"
        if %vebose gt 0 call unimportant "Debug info printed" 

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem First things first——If it’s a cover song, and we know the original artist, we should search for lyrics by the original artist.
rem However, FLAC files don’t have an original artist tag, just “Composer”, and people put both types of values in them.
rem So we have to suspend this practice and compensate some other way later.
        iff "%FILE_ARTIST%" != "%FILE_ORIG_ARTIST%" .and. "" != "%FILE_ORIG_ARTIST%" then
                rem set FILE_ARTIST=%FILE_ORIG_ARTIST%
                set IS_POTENTIALLY_COVER_SONG=1
        else                
                set IS_POTENTIALLY_COVER_SONG=0
        endiff                
        
        if 1 eq %DEBUG_DISPLAY_PROBE_RESULTS%  echo IS_POTENTIALLY_COVER_SONG=%IS_POTENTIALLY_COVER_SONG% .... FILE_ARTIST = %FILE_ARTIST% ... FILE_ORIG_ARTIST = %FILE_ORIG_ARTIST  🎸  %+ rem e


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem Set potential filenames in our %LYRICS% repository, which can be matched 2 different ways: 
        :SetVarsOnly_skip_to_1
        set MAYBE_SUBDIR_LETTER=%@LEFT[1,%file_artist]
        set              MAYBE_LYRICS_1=%lyrics\%MAYBE_SUBDIR_LETTER%\%file_artist% - %zzzzzzz%%@ReReplace[',_,%file_song%].txt
        set MAYBE_LYRICS_1_BROAD_SEARCH=%lyrics\%MAYBE_SUBDIR_LETTER%\%file_artist% - %@LEFT[3,%@ReReplace[',_,%file_song]]*.txt
        set              MAYBE_LYRICS_2=%lyrics\%MAYBE_SUBDIR_LETTER%\%@NAME[%AUDIO_FILE].txt
        rem if %vebose gt 0 call unimportant "Broad lyric search parameters generated" 

rem Also, subtitle files that may exist?
        set MAYBE_SRT_1=%@PATH[%maybe_lyrics_1]%@NAME[%MAYBE_LYRICS_1].lrc
        set MAYBE_SRT_2=%@PATH[%maybe_lyrics_2]%@NAME[%MAYBE_LYRICS_2].lrc
        rem rem gosub debug "Maybe_Srt_1 == “%maybe_srt_1”" %+ call debug "Maybe_Srt_2 == “%maybe_srt_2”"
        rem if %vebose gt 0 call unimportant "Broad LRC search parameters generated" 
        rem rem pause

        if "%2" == "SetVarsOnly" (goto :SetVarsOnly_skip_to_2)


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————
             
rem If we have set CONSIDER_ALL_LYRICS_APPROVED=1, then auto-approve lyrics at this first prompt, and reduce the time-wait on that prompt:
        iff "1" == "%CONSIDER_ALL_LYRICS_APPROVED%" then
                rem echo - %italics_on%Automatic%italics_off% acceptance of lyrics at prompt#1 turned %blink_on%on%blink_off% %ANSI_COLOR_NORMAL%
                set DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1=yes
                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
                set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
        else
                rem echo %ANSI_COLOR_DEBUG%%STAR% %italics_on%Automatic%italics_off% acceptance of lyrics at prompt#1 turned %blink_on%off%blink_off% %ANSI_COLOR_NORMAL%
                set DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1=no
        endiff
        
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Check if we already have a LRC/SRT file but no TXT file

        :Check_Again
        iff not exist "%LYRIC_FILE%" .or. %@FILESIZE["%LYRIC_FILE%"] eq 0 then
                rem echo iff not exist "%LYRIC_FILE%" .or. @FILESIZE["%LYRIC_FILE%"] eq 0 happened ...........
                rem iff exist "%SRT_SIDECAR_FILENAME%" .or. exist "%LRC_SIDECAR_FILENAME%" then
                rem         rem echo Karaoke file(s) exist, but not TXT
                rem         call warning_soft "Karaoke exists without lyrics file for “%emphasis%%italics_on%%AUDIO_FILE%%italics_off%%deemphasis%”"
                rem endiff                
                rem set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=10  %+ rem 🐮 hard-coded value warning
                iff exist "%SRT_SIDECAR_FILENAME%" then                
                        call warning_soft   "%italics_on%SRT%italics_off% exists, but not TXT"
                        call less_important "Converting SRT file to TXT"
                        call srt2txt.bat "%SRT_SIDECAR_FILENAME%" silent
                        unset /q LYRIC_STATUS
                        set  JUST_GENERATED_LYRICS=1
                        rem call create-srt-from-file postprocess_lrc_srt_files
                        goto :Check_Again
                endiff
                iff exist "%LRC_SIDECAR_FILENAME%" .and. "1" != "%JUST_CONVERTED_LRC_TO_TEXT%" then
                        call warning_soft "%italics_on%LRC%italics_off% exists...but no lyrics: ‘%italics_on%%LRC_SIDECAR_FILENAME%%italics_off’%"
                        call warning_soft "Converting %italics_on%LRC%italics_off% file to %italics_on%TXT%italics_off%: ‘%italics_on%%TXT_SIDECAR_FILENAME%%italics_off’%"
                        rem  LRC to TXT conversion is trivial enough to handle with cut.exe:
                        call lrc2txt.bat "%LRC_SIDECAR_FILENAME%" silent
                        unset /q LYRIC_STATUS
                        set JUST_GENERATED_LYRICS=1
                        set JUST_CONVERTED_LRC_TO_TEXT=1
                        rem call create-srt-from-file postprocess_lrc_srt_files                        
                        goto :Check_Again
                endiff
        endiff                


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Check if we already have approved lyrics:
                
        iff exist "%LYRIC_FILE%" .and. %@FILESIZE["%LYRIC_FILE%"] gt 0 then
                rem Get lyric pre-approval status
                        rem if  "%LYRIC_STATUS%" == "" call get-lyric-status "%LYRIC_FILE%" silent
                        if  "%LYRIC_STATUS%" == "" gosub refresh_lyric_status       
                        iff "%LYRIC_STATUS%" == "APPROVED" then 
                                gosub divider
                                call success "Lyrics are already approved!"
                                set LYRICS_ACCEPTABLE=1
                                set LYRIC_ACCEPTANCE_PROMPT_TO_USE=yes
                                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
                                set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
                                set GOTO_END=1
                        elseiff "1" == "%FORCE_REGEN" then 
                                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_FOR_FORCE_REGEN%
                        else                        
                                set LYRICS_ACCEPTABLE=0
                                set LYRIC_ACCEPTANCE_PROMPT_TO_USE=%DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%
                                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME%
                                set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME%
                        endiff                   
                        if "1" == "%GOTO_END%" goto :END

                rem Display lyrics:
                        rem @gosub divider
                        rem @call bigecho %ansi_color_bright_white%%star% %underline_on%Current lyrics%underline_off%:
                        rem don’t set a color: echos %ANSI_COLOR_GREEN%
                        rem (type "%LYRIC_FILE%" |:u8 unique-lines -A -L) |:u8 print-with-columns

                        gosub set_postprocessed_lyrics "%LYRIC_FILE%"
                        if "1" == "%SHOW_UNPROCESSED_LYRICS_ALSO%" call review-file   -wh  -st    "%LYRIC_FILE%"           "%underline_on%Current lyrics%underline_off% (not processed)"
                                                                   call review-file   -wh  -stU   "%postprocessed_lyrics%" "%underline_on%Current lyrics%underline_off% (processed)"

                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[purple]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                        rem removed 2022/12/11 
                        @gosub divider

                rem Get lyric approval status:
                        rem No let’s not do this yet! unset /q lyric_status
                        rem %LYRIC_STATUS%" == "" call      get-lyric-status "%LYRIC_FILE%" silent
                        if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status
                        iff    "%lyric_status%" == "APPROVED" then
                                set LYRICS_ACCEPTABLE=1
                                set LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED=1
                                goto :have_acceptable_lyrics_now_or_at_the_very_least_are_done
                        else                                
                                set LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED=0
                        endiff

                rem Get original Genius JSON-file download name, which we store as an ADS tag attached the downloaded lyricfile:
                        set   PREVIOUS_GENIUS_FILENAME=%@ExecStr[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_filename" >&>nul]`` 

                rem Display the filename again in case the lyrics were so long / text zoomed in so large / columns so wide print_with_columns couldn’t fit it on the screen such that it scrolled off and we lost track of what song we are even looking at, and need to be reminded
                        iff "%PREVIOUS_GENIUS_FILENAME%" !=  "" then
                                set AUDIO_FILE_TO_DISPLAY=%@UNQUOTE[%@REPLACE[-,,%@REPLACE[ ,,"%AUDIO_FILE%"]]]
                                set AUDIO_FILE_TO_DISPLAY_NAME=%@ReReplace[[0-9]+_,,%@UNQUOTE[%@NAME["%AUDIO_FILE_TO_DISPLAY%"]]]
                                set AUDIO_FILE_TO_DISPLAY_NAME_LENGTH=%@LEN[%AUDIO_FILE_TO_DISPLAY_NAME]
                                set ARTIST_NAME_SCRUNCHED=%@UNQUOTE[%@REPLACE[ ,,"%FILE_ARTIST%"]]
                                set ARTIST_NAME_SCRUNCHED_LENGTH=%@LEN[%ARTIST_NAME_SCRUNCHED%]
                                set AUDIO_FILE_DISPLAY_LENGTH_WITH_SPACER=%@EVAL[%ARTIST_NAME_SCRUNCHED_LENGTH% + 4 + %AUDIO_FILE_TO_DISPLAY_NAME_LENGTH%]
                                set tmpSpacer=%@REPEAT[ ,%@EVAL[%ARTIST_NAME_SCRUNCHED_LENGTH+1]]``
                                if "%@LEFT[5,"%AUDIO_FILE_TO_DISPLAY_NAME%"]" == "%@LEFT[5,"%PREVIOUS_GENIUS_FILENAME%"]" set tmpSpacer=``
                                SET FILENAME_GENIUS_LENGTH=%@LEN["%PREVIOUS_GENIUS_FILENAME%"]
                                set LENGTHIEST=%@MAX[%FILENAME_GENIUS_LENGTH%,%AUDIO_FILE_DISPLAY_LENGTH_WITH_SPACER%]
                                set MAGIC_COLUMN=%@EVAL[%LENGTHIEST% + 21] 
                                set MOVEITMOVEIT=%@ANSI_MOVE_TO_COL[%MAGIC_COLUMN%]%ansi_color_bright_yellow%
                        else
                                set AUDIO_FILE_TO_DISPLAY=%AUDIO_FILE%
                                set AUDIO_FILE_TO_DISPLAY_NAME=%@NAME["%AUDIO_FILE_TO_DISPLAY%"]
                        endiff

                        gosub DisplayAudioDirectory

                rem Display the Genius JSON-file download name, if one was previously fetched:
                        iff "%PREVIOUS_GENIUS_FILENAME%" !=  "" then
                                echos %MOVEITMOVEIT%%@CHAR[10229]   %blink_on%Are these more%blink_off%
                                echo.
                                echos %ansi_color_prompt%%star% %ansi_color_bright_yellow%Genius filename%ansi_color_yellow%:%ansi_color_prompt%  “%italics_on%%blink_off%%ansi_color_green%%PREVIOUS_GENIUS_FILENAME%%ansi_color_prompt%%blink_off%%italics_off%”
                                echos %MOVEITMOVEIT%%@CHAR[10229]  %blink_on%or less the same%blink_off%?
                        endiff
                        echo.

                rem Ask if the lyrics are good
                        iff "1" == "%LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE%" .or. "1" == "%FORCE_REGEN%" then
                                set LYRIC_ACCEPTANCE_PROMPT_TO_USE=yes
                                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_FOR_FORCE_REGEN%
                                unset /q LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE
                        endiff
                        :Ask_Again_p
                        echo %emoji_red_question_mark%%ANSI_COLOR_PROMPT%%EMOJI_QUESTION_MARK% We %italics_on%already have%italics_off% these. Are they acceptable?
                        call AskYn "Acceptable?%conceal_on%1%conceal_off%[%ANSI_COLOR_bright_green%H%ANSI_COLOR_PROMPT%%connecting_equals%Yes+%ansi_color_bright_green%h%ansi_color_prompt%and-edit,%ANSI_COLOR_bright_green%P%ansi_color_prompt%lay,%ANSI_COLOR_bright_green%G%ANSI_COLOR_PROMPT%oogle,%ansi_color_bright_green%L%ansi_color_prompt%yricless(%ansi_color_green%Z%ansi_color_prompt%%connecting_equals%All),e%ansi_color_bright_green%D%ansi_color_prompt%it band/tit,d%ansi_color_bright_green%O%ansi_color_prompt%wnload,%ansi_color_bright_green%I%ansi_color_prompt%=inst(%ansi_color_bright_green%X%ansi_color_prompt%=All)]" %LYRIC_ACCEPTANCE_PROMPT_TO_USE%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE% DHILOPXZ H:Yes_but_hand-edit_them_first,L:Mark_as_lyricless!!,Z:Mark_everything_here_as_lyricless,P:Play_file_it_and_see,G:Google_for_better,D:eDit_the_artist/song_instead,O:dOwnload_new_lyrics_nOw,I:mark_instrumental,X:mark_all_as_insturmentals
                        set HOLD_ANSWER=%ANSWER%
                        rem echo 🎨 goto_download_with_lyric_downloader_1 is "%goto_download_with_lyric_downloader_1%" 
                        rem                        if  "1" == "%goto_download_with_lyric_downloader_1%" goto download_with_lyric_downloader_init                                                                                                                                                                                                                                  
                        if "%HOLD_ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" goto download_with_lyric_downloader_init

                        gosub check_for_answer_of_D_to_eset_artist_and_song
                        if "D" == "%HOLD_ANSWER%" goto download_with_lyric_downloader_init
                        gosub check_for_answer_of_G
                        if  "1" == "%GOOGLE_NOW%" goto Google_Now
                        iff "Y" == "%HOLD_ANSWER%" then
                                set LYRICS_APPROVED=1
                        else
                                gosub check_for_answer_of_I
                                gosub check_for_answer_of_L
                                rem 
echo Just got back from check_for_answer_of_L called from near the end of get-lyrics 📚📚📚📚📚 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”
                                if "1" == "%GOTO_END%" (goto :END)
                                gosub check_for_answer_of_P
                        endiff
                        if "P" == "%HOLD_ANSWER%" (goto Ask_Again_p)
                        if "I" == "%HOLD_ANSWER%" (set  goto_end=1)
                        if "X" == "%HOLD_ANSWER%" (set  goto_end=1)
                        if "1" == "%GOTO_END%"    (goto END)
                        
                rem Since the question we just asked included option to hand-edit, let’s suppress asking that question later:
                        set  DO_NOT_ASK_TO_HAND_EDIT=1
                        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 2 >nul 
                        set  FORCE_HAND_EDIT=0
                        
                rem If the lyrics are good, set them as so. if they are not, warn:                        
                        iff "%ANSWER%" == "Y" .or. "%ANSWER%" == "H" then                        
                                rem if "%LYRIC_STATUS%" == "" call get-lyric-status "%LYRIC_FILE%" silent
                                if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status
                                echo %check% %ansi_color_success%Approving lyrics...%ansi_color_normal% %conceal_on%DEF%conceal_off%
                                iff "%LYRIC_STATUS%" != "APPROVED" then
                                        set JUST_APPROVED_LYRICS=1
                                        call  approve-lyrics "%LYRIC_FILE%" >nul
                                        gosub approve_lyrics_done
                                endiff                                        
                                set JUST_APPROVED_LYRICS=1
                                set LYRICS_ACCEPTABLE=1
                                iff "%ANSWER%" != "H" then
                                        set DO_NOT_ASK_TO_HAND_EDIT=1
                                        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 3 >nul 
                                        set  FORCE_HAND_EDIT=0
                                endiff
                                iff "%ANSWER%" == "H" then
                                        set DO_NOT_ASK_TO_HAND_EDIT=0
                                        gosub debug "Setting FORCE_HAND_EDIT=1 .... instance #2 ... answer=“%ANSWER%”"
                                        set  FORCE_HAND_EDIT=1
                                        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 4 >nul 
                                endiff                                        
                                goto :have_acceptable_lyrics_now_or_at_the_very_least_are_done
                        else
                                set LYRICS_ACCEPTABLE=0
                                rem echo %ansi_color_warning_soft%%star% Not using them, so let’s remove them and try downloading...%ansi_color_normal%
                                rem if exist "%LYRIC_FILE%" (ren  /q "%LYRIC_FILE%" "%LYRIC_FILE%.%_datetime.666.bak")
                                echo %ansi_color_warning_soft%%star% Not using them...%ansi_color_normal%
                                rem gosub divider
                                goto :End_Of_Check_To_See_If_We_Already_Had_Them
                        endiff                     
        endiff
        :End_Of_Check_To_See_If_We_Already_Had_Them
        if %vebose gt 0 call unimportant ":End_Of_Check_To_See_If_We_Already_Had_Them" 
        if "1" == "%GOTO_END%" (goto :END)
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━



rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem Check if we have one in our lyric repository already, via 2 different filenames, and then manual selection:
        rem gosub debug "(10) Checking[hh] for %MAYBE_LYRICS_1%" silent
        if "%MAYBE_LYRICS_1%" == "%LAST_MAYBE_LYRICS_1%" goto :MaybeLyrics1_END
        set LAST_MAYBE_LYRICS_1=%MAYBE_LYRICS_1%
        iff "1" != "%LYRICS_ACCEPTABLE%" .and. exist "%MAYBE_LYRICS_1%" .and. %@FILESIZE["%MAYBE_LYRICS_1%"] gt 0 .and. "1" != %GENIUS_ONLY% then
                set PROCESS_MAYBE_1=1
        else
                set PROCESS_MAYBE_1=0
        endiff

        rem iff "1" == "%LYRICS_ACCEPTABLE%" .and. exist "%MAYBE_LYRICS_1%" .and. %@FILESIZE["%MAYBE_LYRICS_1%"] gt 0 .and. "1" != %GENIUS_ONLY% then
        if "1" != "%PROCESS_MAYBE_1%" goto :endiff_991
                @gosub divider
                @call less_important "Found possible lyrics (type 1) at %emphasis%%maybe_lyrics_1%%deemphasis%!%conceal_on%3838%conceal_off%"
                @call less_important "Let’s review them..."
                rem @gosub divider
                rem @call bigecho %ANSI_COLOR_IMPORTANT_LESS%%star% %underscore_on%Let’s review:%underscore_off%%ANSI_RESET%
                rem (type "%MAYBE_LYRICS_1%" |:u8 unique-lines -A -L) |:u8 print-with-columns
                call review-file -wh "%MAYBE_LYRICS_1%" 
                echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[bright cyan]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                gosub divider
                gosub DisplayAudioFileName
                :Ask_Again_p_12
                call AskYn "These good? (e%ansi_color_bright_green%D%ansi_color_prompt%it band/song,%ansi_color_bright_green%P%ansi_color_prompt%lay,%ansi_color_bright_green%H%ansi_color_prompt%and-edit,%ansi_color_bright_green%L%ansi_color_prompt%yric give-up(%ansi_color_bright_green%Z%ansi_color_prompt%=all),I=%ansi_color_bright_green%I%ansi_color_prompt%nstr(%ansi_color_bright_green%X%ansi_color_prompt%=All),d%ansi_color_bright_green%O%ansi_color_prompt%/l)" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% DHILOPXZ H:Yes_but_hand_edit_first,L:No!_Marking_as_lyricless,I:Mark_the_track_as_an_instrumental_track,P:Play_the_file,Z:mark_all_songs_in_folder_as_lyricless,D:edit_artist/song_name,O:dOwnload_lyrics_nOw,X:mark_all_as_instrumental
                        echo [A] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        set SAVED_ANSWER=%ANSWER%
                        if "%ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" goto download_with_lyric_downloader_init
                        echo [B] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        gosub check_for_answer_of_D_to_eset_artist_and_song
                        rem echo 🎨 goto_download_with_lyric_downloader_1 is "%goto_download_with_lyric_downloader_1%" 
                        echo [C] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        gosub check_for_answer_of_P
                        gosub check_for_answer_of_L
                        echo [E] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        if  "L" == "%SAVED_ANSWER%"   goto :END
                        gosub check_for_answer_of_I
                        echo [G] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        rem echo answer=“%answer%”,goto_end=“%goto_end%”
                        if "1" == "%GOTO_END%" goto :END
        :endiff_991
        if  "1" == "%goto_END%"          goto :END
        if  "1" == "%ABANDONED_SEARCH%"  goto :END
        if  "L" == "%ANSWER%"            goto :END
        if  "P" == "%ANSWER%"            goto :Ask_Again_p_12
        if  "1" == "%goto_download_with_lyric_downloader_1%" goto download_with_lyric_downloader_init
        iff "1" == "%PROCESS_MAYBE_1%" then
                rem call AskYn "%conceal_on%2%conceal_off%Do %italics_on%these%italics_off% look acceptable (%ansi_color_bright_green%H%ansi_color_prompt%=Yes+%ansi_color_bright_green%H%ansi_color_prompt%and-edit,%ansi_color_bright_green%L%ansi_color_prompt%=No! Give up/%ansi_color_bright_green%L%ansi_color_prompt%yriclessness)" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% HL H:Yes_but_hand_edit_first,L:No!_Marking_as_lyricless
                iff "%ANSWER%" == "Y" .or. "%ANSWER%" == "H" then
                        *copy /q "%MAYBE_LYRICS_1%" "%LYRIC_FILE%" >nul
                        iff exist "%LYRIC_FILE%" then
                                call approve-lyrics "%LYRIC_FILE%"
                                set LYRICS_ACCEPTABLE=1
                                set LYRIC_STATUS=APPROVED
                        endiff
                        set LYRIC_STATUS=APPROVED
                        if not exist "%LYRIC_FILE%" (call error "Well. This shouldn’t happen. #9234092340" %+ beep %+ pause %+ call exit-maybe)
                        echo [1] about to call edit_lyrics_now_if_we_answered_H 🐐
                        if "%ANSWER%" == "H" gosub edit_lyrics_now_if_we_answered_H H
                        set DO_NOT_ASK_TO_HAND_EDIT=1
                        set    JUST_APPROVED_LYRICS=1
                        set       LYRICS_ACCEPTABLE=1
                        goto :have_acceptable_lyrics_now_or_at_the_very_least_are_done
                else
                        set LYRICS_ACCEPTABLE=0
                        call warning_soft "Not using potential lyric file #1, then..."
                        goto :MaybeLyrics2
                endiff
        endiff
        rem echo 🐐 Trace LS1 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
        :MaybeLyrics1_END

        :MaybeLyrics2
        rem gosub debug "(11) Checking[ii] for %MAYBE_LYRICS_2%" silent
        iff exist "%MAYBE_LYRICS_2%" .and. %@FILESIZE["%MAYBE_LYRICS_2%"] gt 0  .and. 1 ne %GENIUS_ONLY% then
                set PROCESS_MAYBE_2=1
        else
                set PROCESS_MAYBE_2=0
        endiff
        rem exist "%MAYBE_LYRICS_2%" .and. %@FILESIZE["%MAYBE_LYRICS_2%"] gt 0  .and. 1 ne %GENIUS_ONLY% then
        iff "1" == "%PROCESS_MAYBE_2%" then
                call less_important "Found possible lyrics (type 2) at %emphasis%%maybe_lyrics_2%%emphasis%!%conceal_on%7272%conceal_off%"
                call less_important "Let’s review them:"
                rem gosub divider
                rem @call bigecho %ANSI_COLOR_IMPORTANT_LESS%Let’s review!%ANSI_RESET%
                rem (type "%MAYBE_LYRICS_2%" |:u8 unique-lines -A -L) |:u8 print-with-columns
                call review-file -wh "%MAYBE_LYRICS_2%" "%ANSI_COLOR_IMPORTANT_LESS%Let’s review!%ANSI_RESET%"
                echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[bright cyan]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                gosub divider
                gosub DisplayAudioFileName
                call AskYn "%conceal_on%3%conceal_off%Do these look acceptable" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% H H:Yes_but_hand-edit_first
                echo goat1 so answer is "%ANSWER%"
                iff "%ANSWER%" == "Y" .or. "%ANSWER%" == "H" then
                        echo goat1 so answer is "%ANSWER%"
                        *copy "%MAYBE_LYRICS_2%" "%LYRIC_FILE%"
                        unset /q LYRIC_STATUS
                        rem about to call edit_lyrics_now_if_we_answered_H 🐐
                        gosub edit_lyrics_now_if_we_answered_H H
                        iff "%ANSWER%" == "Y" then
                                set LYRICS_ACCEPTABLE=1
                                set DO_NOT_ASK_TO_HAND_EDIT=1
                        endiff
                        rem if "%ANSWER%" == "H" echo should we ask if post-hand-edited  are good here?? 🚄
                        goto :have_acceptable_lyrics_now_or_at_the_very_least_are_done
                else
                        echo goat1 wait, if answer is "%ANSWER%" whya re we here?
                         set LYRICS_ACCEPTABLE=0
                         call warning_soft "Not using potential lyric file #2, then..."
                endiff
        endiff
        echo 🐐 Trace LS3 -- LYRICLESSNESS_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRIC_STATUS%”, goto_END=“%GOTO_END%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”
        if "1" != "%FORCE_REDOWNLOAD%" .and. ("%LYRICLESSNESS_STATUS%" == "APPROVED" .or. "%GOTO_END%" == "1") goto :END

rem If we still didn’t find anything acceptable, but have potentially matching files in our lyric repository, let us select one manually:
        :TrySelectingSomethingFromOurLyricsArchive
        set TRY_SELECTION_AGAIN=0
        set do_block_1008=0
        if exist "%MAYBE_LYRICS_1_BROAD_SEARCH%" .and. %SKIP_MANUAL_SELECTION ne 1 .and. 1 ne %GENIUS_ONLY% (set do_block_1008=1)

        if "1" != "%do_block_1008%" goto :do_not_do_block_1008
                echo 🐐 entering do_block_1008
                rem gosub debug "(12) Checking[jj] for %MAYBE_LYRICS_1_BROAD_SEARCH%" 
                set  file_count=%@files["%MAYBE_LYRICS_1_BROAD_SEARCH%"]
                if "%file_count%" == "1" .and. "1" != "%found_broad_lyrics_branch_1%" goto :true_1010 %+ rem else:
                                                                                      goto :false_1010
                        :true_1010
                        if "%ONLY_ONE_FILE_AND_IT_WAS_TRIED%" == "1" goto :End_Of_Local_Lyric_Archive_Selection
                        gosub divider
                        rem  less_important "Found lyrics in %italics_on%local%italics_off% lyric repository of: %faint_on%%LYRICS%%faint_off%"
                        rem  less_important "%Blink_on%Copying file from our %italics_on%LYRIC%italics_off% repository...%blink_off%"
                        set expanded=%@unquote[%@expand["%MAYBE_LYRICS_1_BROAD_SEARCH%"]]
                        if "%expanded%" == "%maybe_lyrics_1%" (
                                echo Skipping checking maybe_lyrics_1_broad_search because expanded is same as maybe_lyrics_1 which is %lq%%expanded%%rq%
                                goto :Nevermind_about_this_1 
                        )
                        if %@CKSUM["%expanded%"] == %@CKSUM["%maybe_lyrics_1%"] (
                                echo Skipping checking maybe_lyrics_1_broad_search because expanded has same checksome as maybe_lyrics_1 which is %@CKSUM["%expanded%"] for %lq%%expanded%%rq% and %@CKSUM["%maybe_lyrics_1%"] for %lq%%maybe_lyrics_1%%rq%
                                goto :Nevermind_about_this_1
                        )

                        if "%[already_tried_potential_lyrics_%expanded%]" == "1" echo - DEBUG: not going thru whole process again because we already dealt with %expanded% !
                        if "%[already_tried_potential_lyrics_%expanded%]" == "1" goto :Nevermind_about_this_1
                        call less_important "Found possible lyrics (type 3) at %emphasis%%expanded%%deemphasis%!"
                                call less_important "Let’s review them..."
                                set  found_broad_lyrics_branch_1=1
                                *copy /Ns "%expanded%" "%TMPREVIEWFILE%" >nul
                                set already_tried_potential_lyrics_%expanded%=1
                                unset /q LYRIC_STATUS
                                set ONLY_ONE_FILE_AND_IT_WAS_TRIED=1
                        :Nevermind_about_this_1
                        goto :endif_1010
                :else:
                        :false_1010
                        set tmptitle=%_title
                        call bigecho %ANSI_COLOR_SUCCESS%%STAR% %underline_on%Choose %italics_on%one%italics_off%%underline_off%?:
                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[yellow]%ANSI_CURSOR_CHANGE_TO_UNDERLINE_BLINKING%   
                        rem echo         %star%%star%song is %FILE_SONG% by %FILE_ARTIST%
                        dir /b "%MAYBE_LYRICS_1_BROAD_SEARCH%" |:u8 insert-before-each-line.py "        %@REPEAT[%EMOJI_red_QUESTION_MARK,2] "
                        unset /q ANSWER
                        :Ask_Again_p_13
                        gosub DisplayAudioFileName
                        rem  AskYn "%underline_on%Select%underline_off% from %file_count% files, for “%italics_on%%blink_on%%FILE_SONG%%blink_off%%italics_off%” by “%italics_on%%FILE_ARTIST%%italics_off%” [I=rename as instrumental]" no %LYRIC_SELECT_FROM_FILELIST_WAIT_TIME% LI L:Mark_this_one_as_lyricLESS,I:rename_file_as_instrumental
                        call AskYn "%underline_on%Select%underline_off% from one of these %file_count% file%@IF[%file_count% gt 1,s,]? [%ansi_green%I%ansi_color_prompt%=instrumental(%ansi_color_bright_green%X%ansi_color_prompt%=All),%ansi_green%P%ansi_color_prompt%=Play,%ansi_green%L%ansi_color_prompt%=Lyrics unfindable(%ansi_color_bright_green%Z%ansi_color_prompt%=all),e%ansi_color_bright_green%D%ansi_color_prompt%it names]" no %LYRIC_SELECT_FROM_FILELIST_WAIT_TIME% DLIOPXZ L:Mark_this_one_as_lyricLESS,Z:Mark_all_as_lyricless,I:rename_file_as_instrumental,P:play_it!!!!,O:dOwnlOad_nOw_already!!,X:rename_all_songs_as_instrumental,D:edit_names
                        SET LAST_ANSWER=%ANSWER%
                        echo GOATCHEESE001 LAST_ANSWER=“%LAST_ANSWER%”
                        gosub check_for_answer_of_D
                        gosub check_for_answer_of_I
                        rem this one may be redundant now that we added check_for_answer_of_I, so let’s suspend it: gosub rename_audio_file_as_instr_if_answer_was_I
                        if  "I" == "%LAST_ANSWER%"   goto :END
                        gosub check_for_answer_of_L
                        echo GOATCHEESE005 LAST_ANSWER=“%LAST_ANSWER%”
                        gosub check_for_answer_of_P
                        if  "L" == "%LAST_ANSWER%"   goto :END
                        echo GOATCHEESE007 LAST_ANSWER=“%LAST_ANSWER%”
                        if  "O" == "%LAST_ANSWER%"   goto download_with_lyric_downloader_init
                        if  "P" == "%LAST_ANSWER%"   goto Ask_Again_p_13
                        if  "1" == "%goto_END%"      goto END
                        iff "N" == "%LAST_ANSWER%"   then
                                call less_important "Skipping selecting from potential files..."
                                goto :End_Of_Local_Lyric_Archive_Selection
                        elseiff "%answer%" == "Y" then
                                rem Moved this to earlier so the variable is always present: set TMPREVIEWFILE=%temp%\review-file.%_datetime.%_PID.txt
                                rem 2025/01/17 tried to remove this: cls
                                rem in favor of this:
                                rem if "" == "%file_count%" set file_count=10
                                rem set repeat_amount=%@EVAL[%file_count + 10]
                                rem repeat %repeat_amount% echo.
                                rem and it created screen glitches due to what @select leaves behind. So no.
                                rem ━━━━━━━━━━━━━━━━
                                repeat 15 echo.
                                cls
                                echos %@RANDFG_SOFT[]
                                title %file_song% - %file_artist%
                                select *copy /Ns  ("%MAYBE_LYRICS_1_BROAD_SEARCH%") "%TMPREVIEWFILE%"
                                unset /q LYRIC_STATUS
                                rem gosub debug  "copied “%MAYBE_LYRICS_1_BROAD_SEARCH%” to sidecar location"
                        endiff
                        if "1" == "%goto_END%" goto :END
                        if ""  != "%tmptitle%" title %tmptitle%
                :endif_1010
                :done_1010
                if "1" == "%goto_END%" goto :END
        :do_not_do_block_1008
        if "1" == "%goto_END%" goto :END
        rem echo 🐐 Trace LS4 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”


rem Now we have gotten past the “Select from existing filelist” part

        rem This next if block got complicated so we broke it down:
                iff exist "%TMPREVIEWFILE%" .and. %@FILESIZE["%TMPREVIEWFILE%"] gt 0 then
                        set do_block_1088=1
                else
                        set do_block_1088=0
                endiff

        rem Now that we’ve broken it down... here we go:

        if "0" == "%do_block_1088%" goto :end_of_block_1088
                rem echo 🐐 Trace LS-B-4.1 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                if %DEBUG gt 0 (gosub debug "TMPREVIEWFILE of size %@FILESIZE[%TMPREVIEWFILE%] exists: %TMPREVIEWFILE%")
                call review-file -wh "%TMPREVIEWFILE%" "Lyrics from local repo"
                gosub divider
                gosub DisplayAudioFileName
                :ask_if_these_are_acceptible_1
                call  AskYn "These %italics_on%%underline_on%local repo%underline_off%%italics_off% lyrics good?%conceal_on%4%conceal_off%[%ANSI_GREEN%H%ANSI_COLOR_PROMPT%%connecting_equals%edit lyr,%ANSI_COLOR_PROMPT%e%ansi_color_bright_green%D%ansi_color_prompt%it band/tit,d%ansi_color_bright_green%O%ansi_color_prompt%wnload,%ANSI_GREEN%L%ANSI_COLOR_PROMPT%=%ANSI_GREEN%L%ANSI_COLOR_PROMPT%yricless,%ANSI_GREEN%I%ANSI_COLOR_PROMPT%=Instr(%ansi_color_green%X%ansi_color_prompt%=all),%ANSI_color_bright_GREEN%G%ANSI_COLOR_PROMPT%oogle,%ANSI_GREEN%P%ANSI_COLOR_PROMPT%lay%%ansi_color_prompt%]" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% ADGHILOPXZ H:Yes_but_hand-edit_first,C:change_artist_or_song_name_first,O:dOwnload_now,L:Mark_as_lyricless!!!,Z:Mark_all_as_lyricless,I:Rename_as_instrumental,P:Play_it!,G:Google_for_better_lyrics,X:mark_all_as_instrumental
                echo [111] Just got back from 🌭🌭🌭🌭🌭 situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%” -- - LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” -- - LYRIC_STATUS=“%LYRIC_STATUS%” 🐐 Trace LS-B-4.2 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                gosub check_for_answer_of_L
                rem  [222] Just got back from 🌭🌭🌭🌭🌭 situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%” -- - LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” -- - LYRIC_STATUS=“%LYRIC_STATUS%” 🐐 Trace LS-B-4.2 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                if  "L" == "%ANSWER%"                                goto END
                echo [333] Just got back from 🌭🌭🌭🌭🌭 situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%” -- - LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” -- - LYRIC_STATUS=“%LYRIC_STATUS%” 🐐 Trace LS-B-4.2 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                gosub check_for_answer_of_D_to_eset_artist_and_song
                gosub check_for_answer_of_G
                gosub check_for_answer_of_P
                gosub rename_audio_file_as_instr_if_answer_was_I
                if  "O" == "%ANSWER%"                                goto download_with_lyric_downloader_init
                if  "1" == "%goto_download_with_lyric_downloader_1%" goto download_with_lyric_downloader_init
                if  "P" == "%ANSWER%"                                goto ask_if_these_are_acceptible_1
                if  "1" == "%GOTO_END%"                              goto END
                if  "1" == "%GOOGLE_NOW%"                            goto Google_Now
                iff "Y" == "%ANSWER%" .or. "%ANSWER%" == "C" .or. "%ANSWER%" == "H" then
                        *copy /q "%TMPREVIEWFILE%" "%LYRIC_FILE%" >nul
                        gosub edit_lyrics_now_if_we_answered_H H
                        unset /q LYRIC_STATUS
                        iff not exist "%LYRIC_FILE%" then
                                call error "LYRIC_FILE of %italics_on%%LYRIC_FILE%%italics_off% doesn’t exist and should"
                        else 
                                set LYRICS_ACCEPTABLE=1
                                set JUST_APPROVED_LYRICS=1
                        endiff
                        rem echo [3] about to call edit_lyrics_now_if_we_answered_H 🐐
                        gosub edit_lyrics_now_if_we_answered_H C
                        set   DO_NOT_ASK_TO_HAND_EDIT=1

                        goto :have_acceptable_lyrics_now_or_at_the_very_least_are_done
                else
                        iff "%ANSWER%" == "L" then
                                set LYRICLESSNESS_STATUS=APPROVED
                        else
                                rem echo 🐐 Trace LS-B2-4.2 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                                set LYRICS_ACCEPTABLE=0
                                call important_less "We have rejected this set of lyrics    %faint_on%(file_count=“%file_count%”)%faint_off%"
                                rem echo.
                                rem instead of this: goto :End_Of_Local_Lyric_Archive_Selection
                                rem if we go back to the beginning, we can allow trying of multiple 
                                rem                                 files before finally giving up
                                rem This seemed to not workgoto: TrySelectingSomethingFromOurLyricsArchive
                                iff "1" == "%file_count%" then
                                        rem Don’t try it again. But also don’t mark it 0.n
                                else
                                        set TRY_SELECTION_AGAIN=1
                                endiff
                        endiff
                endiff
        :else:
                rem It seems we did not select/copy a file and must move on to the next step
                rem or that the file we selected is 0 bytes andn ot useful
        :endiff:
        :end_of_block_1088
        rem echo 🐐 Trace LS5-A -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, goto_end=“%goto_end%”
        if "1" != "%FORCE_REDOWNLOAD%" .and. ("1" == "%goto_END%" .or. "%LYRICLESSNESS_STATUS%" == "APPROVED") goto :END

        iff "%TRY_SELECTION_AGAIN%" == "1" then
                set TRY_SELECTION_AGAIN=2                               %+ rem Recursion stopgap
                goto :TrySelectingSomethingFromOurLyricsArchive
        endiff
        :End_Of_Local_Lyric_Archive_Selection
        unset /q ONLY_ONE_FILE_AND_IT_WAS_TRIED
        unset /q TRY_SELECTION_AGAIN
        rem echo 🐐 Trace LS5-B -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem But wait! If a TXT file exists, and it  IS approved, we should continue as normal.
rem       But if a TXT file exists, and it NOT approved, we should ask before overwriting it.
rem                         It could be a hand-edited txt file that’s years old and has value.
        iff "%LYRIC_STATUS%" == "" then
                echo %ansi_color_orange%[refresh_lyric_status "%@UNQUOTE[%LYRIC_FILE%]"]%ansi_color_normal%
                gosub  refresh_lyric_status "%@UNQUOTE[%LYRIC_FILE%]"                                           
                echo %ansi_color_orange%[/refresh_lyric_status]%ansi_color_normal%
        endiff
                                                                           
        echo %ANSI_COLOR_DEBUG%- DEBUG: TXT_FILE=“%TXT_FILE%”,LYRIC_FILE=“%LYRIC_FILE%”[%@IF[exist "%LYRIC_FILE%",exists,does not exist]],TXT_SIDECAR_FILENAME=“%TXT_SIDECAR_FILENAME%”,LYRIC_STATUS=“%LYRIC_STATUS%”,LYRIClessness_STATUS=“%LYRIClessness_STATUS%”, last_file_to_get_lyric_status_of=“%last_file_to_get_lyric_status_of%”, goto_end="%goto_end%"
        rem pause
        set goto_end=0
        iff not exist "%LYRIC_FILE%"          goto keep_on_truckin_1295
        if "%LYRIC_STATUS%" == "APPROVED"     goto have_acceptable_lyrics_now_or_at_the_very_least_are_done
        if "%LYRIC_STATUS%" == "NOT_APPROVED" goto download_with_lyric_downloader_init
        rem At this point, the lyric_file isn’t approved or not_approved. “NOT_SET” is the technical value.
        rem Since it’s neutral——neither declared unapproved-and-replaceable nor approved-and-irreplaceable——
        rem we must ask for it’s fate. But we should default to “NO” for our answer——because it could be a
        rem previously-hand-edited file from years ago that we care about very much:
                echo lyric_file exists with status %lyric_status%: %lyric_file%
                call AskYN "Download new lyrics over existing TXT file [A=Approve them instead]" no 30 AIX A:approve_them_instead,I:mark_as_instrumental,X:mark_all_as_instrumentals
                        rem Do instrumental marking if told to:
                                if "%ANSWER%" == "I" .or. "%ANSWER%" == "X" (
                                        gosub check_for_answer_of_I
                                        set abort_karaoke_kreation=1
                                        set goto_end=1
                                )
                        rem Completely abort on “N”:
                                if "%ANSWER%" == "N" (
                                        set abort_karaoke_kreation=1
                                        set goto_end=1
                                )
                        rem On “A”, approve the lyrics, then continue:
                                if "%ANSWER%" == "A" (
                                        call  approve-lyrics "%LYRIC_FILE%"
                                        gosub approve_lyrics_done
                                        set goto_end=1
                                )
                        rem On “Y”, download new lyrics:
                                if "%ANSWER%" == "Y" (
                                        set goto_end=0
                                        goto download_with_lyric_downloader_init
                                )
                        rem If we hit “N” / otherwise decided we’re done, let user know why:
                                echo 🐑🐑🐑 goto_end is “%goto_end%”, LYRIC_STATUS=“%LYRIC_STATUS%”
                                if "1" != "%goto_end%" .or. "APPROVED" == "%LYRIC_STATUS%" goto keep_on_truckin_1295
                                        echo %ansi_color_warning_soft%%star2% Okay then... We’re done, I guess.
                                        echo %ansi_color_warning_soft%%star2% You didn’t %italics_on%approve%italics_off% the above lyrics
                                        echo %ansi_color_warning_soft%%star2% But you %italics_on%also didn’t approve%italics_off% downloading new lyrics to overwrite them
                                        echo %ansi_color_warning_soft%%star2% We are at an impasse.
                                        rem this made doubles when called from get-lyrics-here: gosub divider
                                goto :end
                :keep_on_truckin_1295
                if "1" == "%GOTO_END%" (goto :END)


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem Download the lyrics using LYRIC_DOWNLOADER_1: SETUP: —————————————————————————————————————————————————————————————————
rem Set the values that we will use when using LYRIC_DOWNLOADER_1 the first time [they get changed during subsequent download attempts]:
        rem Don’t go here unless we haven’t performed our first search yet; otherwise goto :download_with_lyric_downloader_1 instead
        :download_with_lyric_downloader_init
                *setdos /x0
                *setdos /x-9
                if "1" == "%lyric_downloader_initialized%" goto :done_with_download_with_lyric_downloader_init
                        set        FILE_SONG_TO_USE=%FILE_SONG%
                        set       FILE_TITLE_TO_USE=%FILE_SONG%          
                        set      FILE_ARTIST_TO_USE=%FILE_ARTIST%
                        set FILE_ORIG_ARTIST_TO_USE=%FILE_ORIG_ARTIST%
                        set       FILE_ALBUM_TO_USE=%FILE_ALBUM%
                        set lyric_downloader_initialized=1
                        rem gosub debug "🎨🎨🎨[40] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
        :done_with_download_with_lyric_downloader_init
        

rem Download the lyrics using LYRIC_DOWNLOADER_1: BEGIN: ——————————————————————————————————————————————————————————————————
        :download_with_lyric_downloader_1
        echo 🌧🌧🌧 got to %italics_on%download_with_lyric_downloader_1%italics_off% with %italics_on%FILE_SONG_TO_USE%italics_off%=“%FILE_SONG_TO_USE%” and %italics_on%FILE_ARTIST_TO_USE%italics_off%=“%FILE_ARTIST_TO_USE%”

        set current_search=%FILE_SONG_TO_USE% :::: %FILE_ARTIST_TO_USE%``
        rem echo %ANSI_COLOR_DEBUG% -DEBUG: current_search set to %ansi_color_orange%"%current_search%"%ansi_color_normal% goat666
        iff "%current_search%" == "%last_search%" .and. "%FIRST_SEARCH_COMPLETE%" != "1" then
                echo %ansi_color_warning_soft%%NO% Skipping search because current_search is the same as last_search of “%LAST_SEARCH%”%ansi_color_normal%
                goto :skip_this_search
        endiff

        set   already_searched_for_this=%[already_searched_for_%file_song_to_use%_%file_artist_to_use%]
        iff "%already_searched_for_this%" == "1" then
                echos %ansi_color_bright_red%%NO% %blink_on%Skipping%ansi_color_bright_red% search because we’ve already searched for %ansi_color_warning_soft%“%blink_on%%ansi_color_green%%file_song_to_use%%ansi_color_warning_soft%” 
                if "" != "%file_artist_to_use%" echos  %blink_on%%ansi_color_bright_red%by %ansi_color_warning_soft%“%ansi_color_green%%blink_on%%file_artist_to_use%%ansi_color_warning_soft%”%blink_off%%ansi_color_normal%
                echo.
                goto :skip_this_search
        endiff

        rem Create a tiny file so we don’t accidentally do anything latest-file based with any pre-existing files in the folder,
        rem Because later we are doing things with the latest file, but if a failure happens, the latest file could be something
        rem already in the folder.  To prevent that, *this* will be the latest file:
                 >"__"          

        rem Create our command:
                set                               LYRIC_RETRIEVAL_COMMAND=%LYRIC_DOWNLOADER_1% song "%FILE_SONG_TO_USE%" "%FILE_ARTIST_TO_USE%" --save
                rem  %ANSI_COLOR_DEBUG- COMMAND: %LYRIC_RETRIEVAL_COMMAND%%ANSI_COLOR_NORMAL%
                
                iff "1" == "%cover_original_attempt%" then
                        set blink_maybe=%blink_on%
                else                        
                        set blink_maybe=%blink_off%
                endiff

                gosub divider nonewline                                    
                rem gosub debug "🎨🎨🎨[50] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
                echos %BIG_OFF%%@ANSI_CURSOR_COLOR_BY_WORD[yellow]
                echo %BIG_OFF%%ANSI_COLOR_IMPORTANT_LESS%%STAR% Searching %italics_on%%LYRIC_DOWNLOADER_1_SOURCE%%italics_off% for %ansi_color_important%“%ansi_color_important_less%%italics_on%%FILE_SONG_TO_USE%%italics_off%%ansi_color_important%”%ansi_color_important_less%%@IF["" != "%FILE_ARTIST_TO_USE%", by ,]%ansi_color_important%%italics_off%%blink_maybe%%FILE_ARTIST_TO_USE%%blink_off%%ansi_color_important_less%...%italics_off%%ANSI_RESET%%conceal_on%[1119]%conceal_off%
                set last_search=%FILE_SONG_TO_USE% :::: %FILE_ARTIST_TO_USE%``
                set      already_searched_for_%[file_song_to_use]_%[file_artist_to_use]=1     %+ rem Attach the fact that we’ve performed a Genius search for this file temporarily to the current environemnt session                
                echo True>"%@UNQUOTE["%audio_file%"]:genius_searched_already"                 %+ rem Attach the fact that we’ve performed a Genius search for this file permanently to the file itself using ADS tag


        rem Store original environment variable value for PYTHONIOENCODING:            
                if defined PYTHONIOENCODING (set PYTHONIOENCODING_OLD=%PYTHONIOENCODING%)
                set PYTHONIOENCODING=utf-8

        rem Run our command, with a “y” answer to overwrite:
                echos %ANSI_COLOR_RUN%
                set LAST_LYRIC_RETRIEVAL_COMMAND=%LYRIC_RETRIEVAL_COMMAND%
                rem  LYRIC_RETRIEVAL_COMMAND=“%LYRIC_RETRIEVAL_COMMAND%”
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            " |:u8 copy-move-post.py whisper)    %+ rem temporarily disabling this until we get that leak fixed ... actually i don’t thik it was related to that leak but making this one moment color cycle really isn’t important
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            ")
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            " |:u8 strip-ansi |:u8 highlight "Wrote \b.*.json" |:u8 gr -v q.*].*#CF5500)
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            " |:u8 strip-ansi |:u8 highlight       "\b.*.json" |:u8 gr -v q.*].*#CF5500) %+ rem CF5500 is just a kludge for something else   not working right at the moment
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "          "   |:u8 strip-ansi |:u8 highlight       "\b.*.json" |:u8 gr -v q.*].*#CF5500) %+ rem CF5500 is just a kludge for something else not working right at the moment and i’m not even sure if it’s still happening or not
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "          "   |:u8 strip-ansi |:u8 highlight       "\b.*.json") %+ rem CF5500 is just a kludge for something else not working right at the 

*setdos /x-89
                    ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 %BAT%\insert-before-each-line.py "          "   |:u8 %BAT%\strip-ansi |:u8 %BAT%\highlight       "\b.*.json") 
*setdos /x0

                call errorlevel "Problem retrieving lyrics in %0"
                echos %@ANSI_CURSOR_COLOR_BY_WORD[yellow]


        rem Restore original environment variable value for PYTHONIOENCODING:            
                iff   defined    PYTHONIOENCODING_OLD then
                          set    PYTHONIOENCODING=%PYTHONIOENCODING_OLD%
                else
                        unset /q PYTHONIOENCODING
                endiff

        rem Set flag:
                set FIRST_SEARCH_COMPLETE=1

        rem Get the most latest file so we can examine it to see if it’s the lyrics we just tried to download or not:
                setdos /x0
                echo set LATEST_FILE= @EXECSTR[dir /b /odt ║:u8 tail -1]
                     set LATEST_FILE=%@EXECSTR[dir /b /odt |:u8 tail -1]

        rem Generate the proper post-downlaoder intermediate filename for our freshly-downloaded lyrics, and if it already exists, back it up:
                rem PREFERRED_LATEST_FILE_NAME=%SONG_DIR%%@NAME[%AUDIO_FILE].%@EXT[%LATEST_FILE]``
                set PREFERRED_LATEST_FILE_NAME=%SONG_DIR%%@UNQUOTE[%@NAME["%AUDIO_FILE%"].]json
                rem echo PREFERRED_LATEST_FILE_NAME is %PREFERRED_LATEST_FILE_NAME 🍕🍕🍕
                set LFEXT=%@EXT[%LATEST_FILE]`` %+ rem latest file extension
                rem   st "%PREFERRED_LATEST_FILE_NAME%" .and. ("%LFEXT%" != "json" .or. "%LFEXT%" != "txt") (ren /q "%PREFERRED_LATEST_FILE_NAME%" "%PREFERRED_LATEST_FILE_NAME%.%_datetime.777.bak">nul)  %+ rem maintanance warning: if we ever download extensions other than JSON/TXT we need to update this
                if exist "%PREFERRED_LATEST_FILE_NAME%" .and. ("%LFEXT%" == "json" .or. "%LFEXT%" == "txt") (ren /q "%PREFERRED_LATEST_FILE_NAME%" "%PREFERRED_LATEST_FILE_NAME%.%_datetime.777.bak">nul)  %+ rem maintanance warning: if we ever download extensions other than JSON/TXT we need to update this
                rem pause "pause 1"
                rem echo 🐐 Trace LT1 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”

        rem See if our latest file is the expected extension [which would indicate download sucess] or not:              
                if not exist %LATEST_FILE% set MYSIZEY=0
                if     exist %LATEST_FILE% set MYSIZEY=%@FILESIZE[%LATEST_FILE]
                set  MYNAMEY=%@CAPS[%@ReReplace[_, ,%@ReReplace[lyrics_,,%@NAME[%LATEST_FILE%]]]]
                iff %MYSIZEY% gt %MOST_BYTES_THAT_LYRICS_COULD_BE% then  
                        rem echos             ``
                        rem echos %@ANSI_MOVE_TO_COL[0]       %@ANSI_MOVE_TO_COL[0]``
                        @echos %@ANSI_MOVE_TO_COL[0]               %@ANSI_MOVE_TO_COL[11]``
                        echo %ansi_color_warning%%emoji_warning% Caution! Download is %MYSIZEY%b, larger than threshold of %MOST_BYTES_THAT_LYRICS_COULD_BE%b %emoji_warning%%ansi_color_normal%
                        if 0 lt %LARGE_DOWNLOAD_WARNING_WAIT_TIME (call pause-for-x-seconds %LARGE_DOWNLOAD_WARNING_WAIT_TIME%)
                endiff
                iff "%@EXT[%LATEST_FILE]" == "%LYRIC_DOWNLOADER_1_EXPECTED_EXT%" then
                        echos %ANSI_COLOR_GREEN%%@ANSI_CURSOR_COLOR_BY_WORD[green]
                        *ren /q "%LATEST_FILE%" "%PREFERRED_LATEST_FILE_NAME%" >nul
                else
                        rem (It should be the "__" file if nothing generated)
                        rem call warning "The latest file is not a JSON? It is %LATEST_FILE% .. Does this mean lyrics didn’t download?"
                        echos %@ANSI_CURSOR_COLOR_BY_WORD[red]
                        @echos             %@ANSI_MOVE_TO_COL[0]               %@ANSI_MOVE_TO_COL[11]``
                        rem nah gosub divider
                        @call warning_soft " No lyrics downloaded%conceal_on%5%conceal_off%" silent
                        rem echo %@ANSI_CURSOR_COLOR_BY_WORD[red]%ANSI_COLOR_WARNING_SOFT%%STAR2% No lyrics downloaded%conceal_on%5%conceal_off% %ansi_color_normal%
                        rem echo dir audiofile? 🐐 %+ dir %audio_file%
                        rem Stop here if “genius” command line option was given:
                                rem Maybe don’t do this just yet.... if 1 eq %GENIUS_ONLY goto :END

                        rem set LYRIC_RETRIEVAL_1_FAILED=1
                        rem goto :Cleanup
                        rem Actually, just continue...We will try again with different values
                        rem No actually...skip forward,but not to cleanup
                        goto :skip_from_nothing_downloaded
                endiff
                echos %ANSI_RESET%

        rem We are about to make a TXT file.  If it exists, better back it up first:
                if exist "%LYRIC_FILE%" (ren /q "%LYRIC_FILE" "%LYRIC_FILE%.%_datetime.888.bak">nul)
                rem pause "pause 2"

        rem Create TXT file out of the JSON we downloaded, using our Perl postprocessor:
                echos %ANSI_COLOR_RUN%
                get-lyrics-with-lyricsgenius-json-processor.pl <"%PREFERRED_LATEST_FILE_NAME%" >:u8"%LYRIC_FILE%" 

                rem pause "pause 3"

        rem Delete zero-byte txt files, so that if we created an empty file, we don’t leave useless trash laying around:
                call delete-zero-byte-files *.txt silent >nul

        rem At this point, our SONG.txt should exist!  If it doesn’t, then we rejected all our downloads.
                if not exist "%LYRIC_FILE%" .or. %@FILESIZE["%LYRIC_FILE%"] eq 0 goto :then_block_1455
                                                                                 goto :else_block_1464
                        :then_block_1455
                                @echos             ``
                                @call warning "%conceal_on%Q%conceal_off% No lyrics downloaded!%conceal_on%Q%conceal_off%" silent
                                rem set LYRIC_RETRIEVAL_1_FAILED=1

                                rem At this point, if we’ve given the “genius” command-line option, we’re done. This is all we’re doing.
                                        if "1" == "%GENIUS_ONLY%" goto :END
                        goto :endif_1570
                rem else
                        :else_block_1464
                                rem pause "pause 3c"
                                rem @gosub divider
                                rem call bigecho %star% %ansi_color_bright_white%%underline_on%Downloaded lyrics%underline_off%:
                                echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[purple]%ANSI_CURSOR_CHANGE_TO_BLOCK_steady%   
                                @rem  %ANSI_COLOR_BRIGHT_YELLOW%
                                rem echo.
                                rem (type "%LYRIC_FILE%" |:u8 unique-lines -A -L) |:u8 print-with-columns
                                rem pause "pause 3c1"
                                rem echo call review-file "%LYRIC_FILE%" "Downloaded lyrics"


                                rem OLD:
                                rem call review-file -wh -st "%LYRIC_FILE%" "Downloaded lyrics"
                                rem NEW:
                                        gosub set_postprocessed_lyrics
                                        if exist "%TXT_FILE%"          call review-file -wh -st  "%TXT_FILE%"        "Lyrics"
                                        if exist "%LYRIC_FILE%"        call review-file -wh -st  "%LYRIC_FILE%"      "Lyrics"              
                                        if exist "%%PROCESSED_LYRICS%" call review-file -wh -stB "%PROCESSED_LYRICS" "Lyrics (processed)"
                                        rem xist "%SRT_FILE%"          call review-file -wh -stU "%SRT_FILE%"        "Transcription"


                                rem pause "pause 3c2"
                                @gosub divider
                                iff "%GENIUS_FILANAME%" !=  "" then
                                        set spacer=                  ``
                                else
                                        unset /q spacer
                                endiff
                                echo %ansi_color_important_less%%star% Directory is: %SPACER%%italics_on%%[_CWP]%[italics_off]
                                echo %ansi_color_important_less%%star% Filename  is: %SPACER%%ansi_color_green%%italics_on%%blink_on%%@unquote[%@NAME["%AUDIO_FILE%"]]%blink_off%.%faint_on%%@EXT["%AUDIO_FILE%"]%faint_off%%italics_off%

                                rem Display total downloaded this session:
                                        if "" == "%NUM_DOWNLOADED_THIS_SESSION%" set NUM_DOWNLOADED_THIS_SESSION=0
                                        set NUM_DOWNLOADED_THIS_SESSION=%@EVAL[%NUM_DOWNLOADED_THIS_SESSION% + 1]
                                        rem PARENT_BAT=get-lyrics at this point
                                        if %NUM_DOWNLOADED_THIS_SESSION% gt 1 echo %ANSI_COLOR_IMPORTANT%%check1% Downloaded this session: %bold_on%%NUM_DOWNLOADED_THIS_SESSION%%bold_off%%ANSI_COLOR_NORMAL%

                                        call bigecho %STAR% %ANSI_COLOR_GREEN%Downloaded: %bold_on%“%bold_off%%[blink_on]%[italics_on]%[MYNAMEY]%[italics_off]%[blink_off]%bold_on%”%bold_off%
                                        set  LYRIC_STATUS=NOT_SET

                                rem Store the Genius filename as an ADS tag, because the filename is AN AMAZINGLY GOOD SANITY CHECK for whether they were the right lyrics or not —— particularly with music you aren’t familiar with and dno’t recognize the lyrics to right away. They could be lyrics to a totally different song! You’d never know!
                                        echo %[MYNAMEY]>"%@UNQUOTE["%AUDIO_FILE%"]:genius_filename"
                                                                                           
                                rem At this point, if we’ve given the “genius” command-line option, we’re done. This is all we’re doing.
                                        if 1 eq %GENIUS_ONLY goto :END
                                        
                                :try_it_again_1220
                                rem  bigecho %ansi_color_red%%COOL_QUESTION_MARK%Are the lyrics good?%COOL_QUESTION_MARK%
                                call bigecho %ansi_color_red%%COOL_QUESTION_MARK%Are the lyrics good for %bold_on%“%bold_off%%ansi_color_green%%[italics_on]%[FILE_song_TO_USE]%[italics_off]%ansi_color_red%%bold_on%”%bold_off%%ansi_color_red%...
                                call bigecho %ansi_color_red%%COOL_QUESTION_MARK%...by %bold_on%“%bold_off%%[italics_on]%ansi_color_green%%[FILE_artist_TO_USE]%[italics_off]%ansi_color_red%%bold_on%”%bold_off% ...
                                unset /q ANSWER
                                @call AskYn "Are they good? [D%ANSI_COLOR_PROMPT%%CONNECTING_EQUALS%e%ansi_color_bright_green%D%ansi_color_prompt%it artist/song,%ANSI_COLOR_bright_green%H%ANSI_COLOR_PROMPT%%CONNECTING_EQUALS%Hand-edit lyrics,%ANSI_COLOR_bright_green%L%ANSI_COLOR_PROMPT%%CONNECTING_EQUALS%Lyrics Unfindable(%ansi_color_bright_green%Z%ansi_color_prompt%=all),%ANSI_COLOR_bright_green%I%ansi_color_prompt%=Instrumental(%ansi_color_bright_green%X%ansi_color_prompt%=All),%ANSI_COLOR_bright_green%P%ansi_color_prompt%=Play]" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% DEGILPXZ D:Edit_artist_and_song_name,G:Google_for_some_lyrics,H:Yes_but_hand_edit_them,L:No_and_Mark_As_Lyricless,Z:Mark_all_as_lyricless,I:rename_as_instrumental,P:play_it_baby,X:mark_all_files_as_instrumental
                                set hold_answer_main=%ANSWER%

                                if  "D" == "%ANSWER%"     gosub hand_edit_artist_and_song
                                set answer=%hold_answer_main%
                                gosub check_for_answer_of_I
                                set answer=%hold_answer_main%
                                if  "I" == "%ANSWER%"  goto  END
                                gosub check_for_answer_of_P
                                set answer=%hold_answer_main%
                                gosub check_for_answer_of_G
                                set answer=%hold_answer_main%
                                gosub check_for_answer_of_L
                                set answer=%hold_answer_main%
                                if  "1" == "%LYRIC_SUCCESS_CELEBRATION_DISPLAYED%" goto END
                                        echo [JGB-001] Just got back from 🍒🍒🍒🍒🍒🍒🍒 check_for_answer_of_L situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%” ... 
                                iff "L" == "%ANSWER%" goto :END
                                iff "Y" == "%ANSWER%" .or. "%ANSWER%" == "H" then
                                        gosub check_for_answer_of_H
                                        rem oops this waqsn’t happening and it turns out we don’t need it: *del /q "%LYRIC_FILE%" >nul
                                        iff "Y" == "%ANSWER%" .and. "APPROVED" != "%LYRIC_STATUS%" then
                                                set LYRIC_STATUS=APPROVED
                                                echo [JGB-001-A-01] iff "Y" == "%ANSWER%" .and. "APPROVED" != "%LYRIC_STATUS%" 
                                                call  approve-lyrics "%LYRIC_FILE%" >nul
                                                gosub approve_lyrics_done
                                                echo [JGB-001-A-03] iff "Y" == "%ANSWER%" .and. "APPROVED" != "%LYRIC_STATUS%" 
                                        endiff
                                        set    LYRICS_ACCEPTABLE=1
                                        set JUST_APPROVED_LYRICS=1
                                        set DO_NOT_ASK_TO_HAND_EDIT=1
                                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[green]
                                        goto have_acceptable_lyrics_now_or_at_the_very_least_are_done
                                endiff
                                iff "N" == "%ANSWER%" .or. "L" == "%ANSWER%" then
                                        rem Continue on but delete the file to indicate its rejection
                                        set LYRICS_ACCEPTABLE=0
                                        if exist "%LYRIC_FILE%" ren  /q "%LYRIC_FILE%" "%LYRIC_FILE%.%_datetime.999.bak"
                                endiff                                
                                iff "%ANSWER%" == "H" then                        
                                        gosub debug "You hit h (#1) . Rejecting hand editing question and going straight to hand editing"
                                        gosub debug "Setting FORCE_HAND_EDIT=1 .... instance #3"
                                        set FORCE_HAND_EDIT=1
                                        goto :hand_edit_lyrics_right_now_without_asking
                                else                                
                                        set DO_NOT_ASK_TO_HAND_EDIT=1
                                endiff
                                if  "P" == "%ANSWER%"     (goto :try_it_again_1220        )
                                if  "1" == "%GOOGLE_NOW%" (goto :Google_Now               )
                                if  "1" == "%GOTO_END%"   (goto :END                      )
                        goto :endif_1570
                rem endiff
                :endif_1570

                rem Debug:
                        rem pause "pause 4"
                        echo 🐐 Trace LT2 -- LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, answer=“%ANSWER%”, JUST_APPROVED_LYRICS=“%JUST_APPROVED_LYRICS%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”
                
                rem Redundant?
                        if "1" == "%JUST_APPROVED_INSTRUMENTAL%" goto END
                        if "1" == "%JUST_APPROVED_LYRICS%" .and. "Y" == "%ANSWER%" goto have_acceptable_lyrics_now_or_at_the_very_least_are_done


                :end_of_massage_attempt
                :skip_from_nothing_downloaded


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


rem Get massaged names for next section’s check:
        :skip_this_search
        :massage_the_probe_info
        rem Massage some problematic subsets of these fields:
        rem 1) Remove things in parenthesis
        rem 2) remove "The "
                rem Let’s test with functions!
                rem function massageLyricGetValueOLD=`%@ReReplace["\([^\)]*\)",,%@ReReplace[^The ,,%1$]]`
                function massageLyricGetValue=`%@ReReplace[^.*My Little Pony.*$,My Little Pony,%@ReReplace["[\(\[][^\)\]]*[\)\]]",,%@ReReplace[^The ,,%1$]]]`

                rem      FILE_ARTIST_MASSAGED=%@UNQUOTE[%@ReReplace[ & h[ie][sr] orche?s?t?r?a?,,%@ReReplace[ minus .*$,,%@ReReplace[:.*$,,%@massageLyricGetValue["%FILE_ARTIST%"]]]]]
                set      FILE_ARTIST_MASSAGED=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%@ReReplace[[ \-]+$,,%@ReReplace[^[Tt][Hh][Ee] ,,%@ReReplace[❟* *with .*,,%@ReReplace[ & .*,,%@ReReplace[ minus .*$,,%@ReReplace[:.*$,,%@massageLyricGetValue["%FILE_ARTIST%"]]]]]]]]]
                set FILE_ORIG_ARTIST_MASSAGED=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%@massageLyricGetValue["%FILE_ORIG_ARTIST%"]]]
                set       FILE_ALBUM_MASSAGED=%@UNQUOTE[%@massageLyricGetValue["%FILE_ALBUM%"]]
                set        FILE_SONG_MASSAGED=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%@ReReplace[.* [\/]  ,,%@ReReplace[ *[oc][pl][eo][ns]e?ing theme,,%@ReReplace[ aka .*$,,%@UNQUOTE["%@massageLyricGetValue["%FILE_SONG%"]"]]]]]]
                set       FILE_TITLE_MASSAGED=%FILE_SONG_MASSAGED%
                
                rem gosub debug "(13) Massaged: %TAB%   artist=%italics_on%%FILE_ARTIST_MASSAGED%=%italics_off%%newline%%TAB%%tab%%tab%%tab%         title=%italics_on%%FILE_SONG_MASSAGED%=%italics_off%%newline%%TAB%%tab%%tab%%tab%         album=%italics_on%%FILE_album_MASSAGED%=%italics_off%"


rem try again if massaged names exist (that is, if the massaged names are different than the original names):        
        if 1 eq LD1_MASSAGED_ATTEMPT_1 (goto :Already_Did_Massaged)
        iff "%FILE_SONG_MASSAGED%" == "" .and. "%FILE_ARTIST_MASSAGED%" == "" then
                echo %ANSI_COLOR_WARNING_SOFT%%STAR% Couldn’t get file *AND* artist! %ANSI_COLOR_NORMAL%
                goto :skip_for_empty_filename_and_artist
        endiff
        
        rem echo iff "1" != "%LD1_MASSAGED_ATTEMPT_1%" .and. ("%FILE_SONG_MASSAGED%" != "%FILE_SONG%" .or. "%FILE_artist_MASSAGED%" != "%FILE_artist%" .or. "%FILE_ORIG_ARTIST_MASSAGED%" != "%FILE_ORIG_ARTIST%") then %+ pause
        iff "1" != "%LD1_MASSAGED_ATTEMPT_1%" .and. ("%FILE_SONG_MASSAGED%" != "%FILE_SONG%" .or. "%FILE_artist_MASSAGED%" != "%FILE_artist%" .or. "%FILE_ORIG_ARTIST_MASSAGED%" != "%FILE_ORIG_ARTIST%") then 
                gosub divider
                set suppress_next_divider=1
                rem            %ANSI_COLOR_WARNING_SOFT%%STAR%  Let’s try downloading with the massaged names (%ansi_color_bright_green%%italics_on%%FILE_ARTIST_MASSAGED%%italics_off%%ansi_reset% - %ansi_color_bright_cyan%%italics_on%%FILE_SONG_MASSAGED%%italics_off%%ANSI_COLOR_WARNING_SOFT%)...%ANSI_RESET% %STAR%
                echo %ANSI_COLOR_WARNING_SOFT%%STAR% Let’s try downloading with the massaged names (%ansi_color_bright_green%%italics_on%%FILE_ARTIST_MASSAGED%%italics_off%%ansi_reset% - %ansi_color_bright_cyan%%italics_on%%FILE_SONG_MASSAGED%%italics_off%%ANSI_COLOR_WARNING_SOFT%)...%ANSI_RESET% %STAR%
                if 0 lt %WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH (call pause-for-x-seconds %WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH%)
                set FILE_SONG_TO_USE=%FILE_SONG_MASSAGED%
                set FILE_ARTIST_TO_USE=%FILE_ARTIST_MASSAGED%
                *setdos /x-8-5
                set FILE_ARTIST_TO_USE=%@ReReplace[^[Tt][Hh][Ee] ,,%@UNQUOTE[%FILE_ARTIST_TO_USE%]]
                *setdos /x0
                rem gosub debug "🎨🎨🎨[10] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
                set LD1_MASSAGED_ATTEMPT_1=1
                goto :download_with_lyric_downloader_init
        endiff
        :Already_Did_Massaged
        if exist "%LYRIC_FILE" (ren /q "%LYRIC_FILE" "%LYRIC_FILE%.%_datetime.555.bak">nul)
        rem gosub divider
        rem Continue on... We have failed so far.  (DON’T do this here: goto :end_of_massage_attempt)
        unset /q LD1_MASSAGED_ATTEMPT_1
        rem echo 🐐 Trace LT3 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem If we’ve still failed, and it’s a cover song, let’s try with the original artist:
        iff %cover_original_attempt% eq 1 then
                rem Skip it if we already attempted this
        elseiff 1 eq %IS_POTENTIALLY_COVER_SONG%  then
                rem 1ˢᵗ we started with original, so if that fails we’d try initial: set FILE_ARTIST_TO_USE=%FILE_ARTIST_INITIAL%
                rem 2ⁿᵈ we started with  initial, so if that fails we’d try original...
                set FILE_ARTIST_TO_USE=%FILE_ORIG_ARTIST%
                set cover_original_attempt=1
                rem gosub debug "🎨🎨🎨[20] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
                goto :download_with_lyric_downloader_init
        endiff                
        
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem If we’ve still failed, and the artist has “feat” like “Michael Jacksonfeat Metallica”, strip and try again:
        if "" == "%FILE_ARTIST_TO_USE%" goto :feat_stuff_done
                iff 1 eq %@Regex[ feat\.? ,"%FILE_ARTIST_TO_USE%"] then
                        echo %ANSI_COLOR_DEBUG%- DEBUG: “Feat\.” is in the %italics_on%FILE_ARTIST_TO_USE%italics_off% of “%FILE_ARTIST_TO_USE%”
                        set  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[ feat\.? .*$,,"%FILE_ARTIST_TO_USE%"]]
                        set  varname=already_tried_featured_with_%file_artist_to_use%
                        set  already_tried_featured_for_this_one=%[%VARNAME%]
                        iff "%already_tried_featured_for_this_one%" != "1" then
                                echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried de-feat.-ing this one                        
                                set  %VARNAME%=1
                                goto :download_with_lyric_downloader_init
                        else
                                echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried de-feat.-ing this one                        
                        endiff
                else
                        rem echo featured no!
                endiff
        :feat_stuff_done        

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem If we’ve still failed, and the artist has “The” at the beginning, strip and try again:
        if "" == "%FILE_ARTIST_TO_USE%" goto :the_stuff_done
        *setdos /x-5
        echo 🐐 file_artist_to_use is “%file_artist_to_use%”
        set REGEX_VALUE="%@RegEx[^THE,%@UPPER[%file_artist_to_use%]]"  
echo    [DE-THE] REGEX_VALUE=“%REGEX_VALUE%”
echo    [DE-THE] if "0" eq"%%@RegEx[^THE ,%@UPPER[%file_artist_to_use%]]" goto :the_stuff_done goat
echo    [DE-THE] if "0" eq "%@RegEx[^THE ,%@UPPER[%file_artist_to_use%]]" goto :the_stuff_done goat
        if          "0" eq "%@RegEx[^THE ,%@UPPER[%file_artist_to_use%]]" goto :the_stuff_done
                echo %ANSI_COLOR_DEBUG%- DEBUG: “The ” is in the %italics_on%FILE_ARTIST_TO_USE%italics_off% of “%FILE_ARTIST_TO_USE%”
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[^The ,,"%FILE_ARTIST_TO_USE%"]]
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[[Tt][Hh][Ee] ,,"%FILE_ARTIST_TO_USE%"]] didn’t work
                set  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%FILE_ARTIST_TO_USE%]]
                set  varname=already_tried_the_with_%file_artist_to_use%
                set   already_tried_the_for_this_one=%[%VARNAME%]
                iff "%already_tried_the_for_this_one%" != "1" then
                        echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried de-The-ing this one %dash% this is the first one
                        set  %VARNAME%=1
                        goto :download_with_lyric_downloader_init
                else
                        echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried de-The-ing this one, so we won’t try again
                endiff
        :the_stuff_done

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━————————————————————————————————

rem If we’ve still failed, and the artist has “ @ ” in it, it’s probably a badly named live track i.e. “For Whom The Bell Tolls @ RFK Stadium”:

        if "" == "%FILE_ARTIST_TO_USE%" goto :at_stuff_done
        *setdos /x-5
        echo 🐐 file_artist_to_use is “%file_artist_to_use%”
echo    if "0" eq "%@RegEx[ @ ,%@UPPER[%file_artist_to_use%]]" goto :at_stuff_done goat
        if "0" eq "%@RegEx[ @ ,%@UPPER[%file_artist_to_use%]]" goto :at_stuff_done
                echo %ANSI_COLOR_DEBUG%- DEBUG: “ @ ” is in the %italics_on%FILE_ARTIST_TO_USE%italics_off% of “%FILE_ARTIST_TO_USE%”
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[^The ,,"%FILE_ARTIST_TO_USE%"]]
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[[Tt][Hh][Ee] ,,"%FILE_ARTIST_TO_USE%"]] didn’t work
                set  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[ \@ .*$,,%FILE_ARTIST_TO_USE%]]
                echo %ANSI_COLOR_DEBUG%- DEBUG: “ @ ” remove attemped: %italics_n%FILE_ARTIST_TO_USE%italics_off%=“%FILE_ARTIST_TO_USE%”
                set  varname=already_tried_at_with_%file_artist_to_use%
                set   already_tried_at_for_this_one=%[%VARNAME%]
                iff "%already_tried_at_for_this_one%" != "1" then
                        echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried de-@-ing this one %dash% this is the first one
                        set  %VARNAME%=1
                        goto download_with_lyric_downloader_init
                else
                        echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried de-@-ing this one, so we won’t try again
                endiff
        :at_stuff_done

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem Still nothing? Let’s try removing the band name altogether (de-band-name’ing)...  [less annoying for vintage than modern stuff it seems]

        if "" == "%FILE_ARTIST_TO_USE%" goto noband_stuff_done
                *setdos /x-5
                echos 🐐 file_artist_to_use was “%file_artist_to_use%”
                unset /q file_artist_to_use
                echo  but is now “%file_artist_to_use%”
                iff "%debanded%" != "1" then
                        echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried no-band-ing this one %dash% this is the first one [varname=%varname%] [file_artist=“%file_artist%”]
                        set  debanded=1
                        goto download_with_lyric_downloader_init
                else
                        echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried no-band-ing this one, so we won’t try again [varname=%varname%]  [file_artist=“%file_artist%”]
                endiff
        :noband_stuff_done


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem At this point, if we’ve given the “genius” command-line option, we’re done. This is all we’re doing.        //20250307 moved this one block up

        if 1 eq %GENIUS_ONLY% goto :END
        if 1 eq %GOTO_END%    goto :END

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━————————————————————————————————

rem If we *do* have a downloaded file, we’re at the very least ready to proceed to the post-lyrics section:

        :skip_for_empty_filename_and_artist
        iff exist "%LYRIC_FILE%" (goto have_acceptable_lyrics_now_or_at_the_very_least_are_done)


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem If we still don’t have a downloaded file, let us manually edit the song and artist name if we want

        rem 🌈 Q: rainbow divider here? A: No, it already happens. .... No it doesn’t???? Not always??? Not if this is the 1ˢᵗ attempt, anyway....
        if 1 eq %GENIUS_ONLY  (goto :Skip_Hand_Editing)
        gosub divider 
        rem echo %ANSI_COLOR_UNIMPORTANT%- DEBUG: Initial LYRICLESSNESS_STATUS IS “%LYRICLESSNESS_STATUS%”
        iff "%LYRICLESSNESS_STATUS%" == "APPROVED" then
                echo *** Lyriclessness status is “%LYRICLESSNESS_STATUS%”, so we are aborting ***       
                goto :END
        endiff
        :requestion_1325
        unset /q answer
        rem echo 🐐 %%_CWP is “%_CWP”
        unset /q GOOGLE_NOW
        call AskYN "Change artist/song? (%ansi_green%L%ansi_color_prompt%=Lyrics unfindable(%ansi_color_bright_green%Z%ansi_color_prompt%=All),%ansi_green%N%ansi_color_prompt%=ai %italics_on%%ansi_green%N%ansi_color_prompt%ow%italics_off%,G=%ansi_green%G%ansi_color_prompt%oogle,A=lyrics g%ansi_color_bright_green%O%ansi_color_prompt%od!,%ansi_green%I%ansi_color_prompt%nstr.(%ansi_green%X%ansi_color_prompt%=ALL),%ansi_green%P%ansi_color_prompt%lay)" no %HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME% ADGILNOPXZ L:Mark_as_lyricless!!!!,Z:Mark_all_as_lyricless,N:AI_encode_NOW_without_lyrics,G:Google_for_the_lyrics,A:the_lyrics_are_good_actually!,I:rename_it_as_an_instrumental_file,P:play_the_file,X:Mark_all_songs_in_folder_as_instrumental,O:download_lyrics_with_genius,D:eDit_and_change_song_title_and_artist
                rem “Y”/“N” answers:
                        if "N" == "%ANSWER%"                        goto  did_not_want_to_change_artist_song
                        if "Y" == "%ANSWER%" .or. "D" == "%ANSWER%" gosub eset_fileartist_and_filesong
                        if "Y" == "%ANSWER%" .or. "D" == "%ANSWER%" goto  download_with_lyric_downloader_init

                rem “A” for “approve lyrics because I forgot/wasn’t around to say ‘Y’ for the previous [a]pproval prompt”
                        echo - DEBUG: answer was “%ANSWER%” [0i94239023], 
                        iff "%answer%" == "A" then
                                set   LYRICS_ACCEPTABLE=1
                                gosub approve_lyrics_done
                        endiff
                        if  "%answer%" == "A" goto  have_acceptable_lyrics_now_or_at_the_very_least_are_done

                rem “L”:
                        if "L" == "%ANSWER%" set LYRICS_ACCEPTABLE=0
                        gosub check_for_answer_of_L
                        if "1" == "%goto_END%"         goto :END
                        if "1" == "%ABANDONED_SEARCH%" goto :END

                rem “O/G/X/P/I”:
                        gosub check_for_answer_of_O
                        if "%ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" goto :download_with_lyric_downloader_init

                        gosub check_for_answer_of_G
                        if "1" == "%GOOGLE_NOW%" goto :Google_Now

                        gosub check_for_answer_of_X
                        if  "%answer%" == "N" (goto :Skip_Hand_Editing)

                        gosub check_for_answer_of_P
                        if  "%answer%" == "P" (goto :requestion_1325)

                        gosub rename_audio_file_as_instr_if_answer_was_I
                        if "%goto_end%" == "1" goto :end

                rem echo Just got back from 🌶🌶 🌶🌶 🦆🦆 🦆🦆 situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%”
                rem 2025/02/15 adding answer==L to this one to fix infinite loop bug:                                                
                iff "%answer%" == "L" then
                        set SOLELY_BY_AI=1
                        rem TODO: right now, if you are ONLY getting lyrics, and you answer "A" for 
                        rem               for "AI encode now", you just end up back at the prompt. 
                        rem       This is technically correct, but it’s a bit jarring to tell it 
                        rem               to do something and have it do nothing!
                        iff "%PARENT_BAT%" != "create-srt-from-file" then
                                echo.
                                call warning_soft "I know you said to AI encode now... But you need to be running the get-karaoke commands to do that, and you’re just running get-lyric commands"
                                call warning_soft "The %italics_on%PARENT_BAT%italics_off% var is set to “%PARENT_BAT%”"
                                call warning_soft "Okay... Let’s try calling create-srt from get-lyrics and see how that plays out... beta idea!"
                                set FORCE_AI_ENCODE_FROM_LYRIC_GET=1
                                call create-srt-from-file "%AUDIO_FILE%"
                                set  GOTO_END_AFTER_GET_LYRICS_CALLED=1
                        endiff
                        goto :END
                else
                        echo ----`>` Answer is not A! >nul
                endiff
                if "1" eq "%goto_END%" (goto :END)

        rem 🤔 remind us of filename
        rem echo [GL] by the wayyyyyyyyy. lyriclessness status is “%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%” ******************************************************************
        if "" == "%LYRICLESSNESS_STATUS%" set LYRICLESSNESS_STATUS=%@ExecStr[TYPE "%@UNQUOTE["%AUDIO_FILE%"]:lyriclessness" >&>nul]         %+ rem get the song’s lyriclessness approval status
        rem echo [GL] by the woooooooooo. lyriclessness status is “%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”  ******************************************************************
        if "%LYRICLESSNESS_STATUS%" == "APPROVED" .or. "%LYRIC_STATUS%" == "APPROVED" .or. "1" == "%LYRIC_SUCCESS_CELEBRATION_DISPLAYED%" goto :Skip_Hand_Editing

                echo %ansi_color_important_less%%star% Directory: %italics_on%%[_CWP]%[italics_off]
                echo %ansi_color_important_less%%star% Filename:  %italics_on%%@NAME[%AUDIO_FILE]%italics_off%

        :hand_edit_artist_and_song
        echo Trace about to eset_fileartist_and_filesong 🥩 🥩 🥩🥩 🥩🥩🥩
        gosub eset_fileartist_and_filesong
        goto  download_with_lyric_downloader_init
        :Skip_Hand_Editing
        :end_of_lyric_downloader_1
        :did_not_want_to_change_artist_song
rem Download the lyrics using LYRIC_DOWNLOADER_1: END: —————————————————————————————————————————————————————————————————————————————————————


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————


rem Ask to Google the lyrics if we haven’t approved them yet:
        :ask_to_hand_edit_lyrics
        rem Nah? I think nah (2024/12/10): gosub divider
        iff "1" == "%GENIUS_ONLY%" .or. "%LYRICLESSNESS_STATUS%" == "APPROVED" .or. "%LYRIC_STATUS%" == "APPROVED" then
                goto skip_all_the_googling
        endiff

        call AskYN "%[italics_on]Google%[italics_off] for some lyrics (%ansi_color_bright_green%L%ansi_color_prompt%=Lyricless[%ansi_color_bright_green%Z%ansi_color_prompt%=All],e=e%ansi_color_bright_green%D%ansi_color_prompt%it names)" no %GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME% DILZ L:Mark_this_as_lyricless_insteaed,Z:Mark_all_as_lyricless,I:No_just_mark_it_as_instrumental,D:edit_song_and_artist
        rem echo Just got back from 🚩🚩🚩 situation 🚩 and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%”
        if "N" == "%ANSWER%"                                gosub END
        iff "%answer%" == "A" then
                set LYRICS_ACCEPTABLE=1
                gosub approve_lyrics_done
                goto  have_acceptable_lyrics_now_or_at_the_very_least_are_done
        endiff
        gosub check_for_answer_of_I
        gosub check_for_answer_of_L
        if "D" == "%ANSWER%"                                gosub eset_fileartist_and_filesong
        if "D" == "%ANSWER%"                                goto  download_with_lyric_downloader_1
        if "1" == "%goto_download_with_lyric_downloader_1%" goto  download_with_lyric_downloader_1
        if "1" == "%goto_END%"                              goto  END

        :Google_Now
        iff "%answer%" == "Y" .or. "1" == "%GOOGLE_NOW%" then
                set      FILE_ARTIST_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_ARTIST_INITIAL%"]"]]
                set FILE_ORIG_ARTIST_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_ORIG_ARTIST_INITIAL%"]"]]
                set        FILE_SONG_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_SONG_INITIAL%"]"]]
                set       FILE_ALBUM_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_ALBUM_INITIAL%"]"]]
                
                rem These are original values:
                        rem Lived experience says either search is insufficient; we need both:
                          google.py "%FILE_ARTIST_INITIAL_FOR_GOOGLE%" "%FILE_SONG_INITIAL_FOR_GOOGLE%" +lyrics                    
                          google.py  %FILE_ARTIST_INITIAL_FOR_GOOGLE%   %FILE_SONG_INITIAL_FOR_GOOGLE%   lyrics                    
                          iff 1 eq %cover_original_attempt% then
                                  google.py "%FILE_ORIG_ARTIST_INITIAL%"       "%FILE_SONG_INITIAL_FOR_GOOGLE%" +lyrics                    
                                  google.py  %FILE_ORIG_ARTIST_INITIAL%         %FILE_SONG_INITIAL_FOR_GOOGLE%   lyrics                    
                          endiff
                          
                rem Track that we have googled:
                        set WE_GOOGLED=1
                        gosub debug "Setting FORCE_HAND_EDIT=1 .... instance #1"
                        set FORCE_HAND_EDIT=1
                        
                rem Increase wait time if we googled:
                        set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%@EVAL[%HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME + %ADDITIONAL_HAND_EDIT_WAIT_TIME_IF_THEY_GOOGLED%]

                goto :post_googling_for_lyrics_point
        else
                rem Track that we have not googled:
                        set WE_GOOGLED=0
        endiff
        :skip_all_the_googling


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————


:have_acceptable_lyrics_now_or_at_the_very_least_are_done

rem echo 🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂 Have_acceptable_lyrics_now_or_at_the_very_least_are_done 🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂 LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%” >nul


echos %ANSI_CURSOR_CHANGE_TO_underline_BLINKING%                                                        %+ rem Update cursor


rem echo 🐐 checking[K] iff 1 eq LYRICS_ACCEPTABLE=%LYRICS_ACCEPTABLE .or. 1 eq LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED=%LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED then ..... LYRIC_STATUS=“%LYRIC_STATUS%”
iff 1 eq %LYRICS_ACCEPTABLE .or. 1 eq %LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED then
        rem echo 🐐 inside first if -         iff exist "%LYRIC_FILE%" .and. "1" == JUST_APPROVED_LYRICS="%JUST_APPROVED_LYRICS%" then
        iff exist "%LYRIC_FILE%" .and. "1" == "%JUST_APPROVED_LYRICS%" then
                rem echo 🐐 inside second if
                rem if "" == "%LYRIC_STATUS%" call get-lyric-status "%LYRIC_FILE%" silent
                rem gosub refresh_lyric_status
                if "" == "%LYRIC_STATUS%" gosub refresh_lyric_status
                rem echo 🐐 LYRIC_STATUS is “%LYRIC_STATUS%”

                iff "%LYRIC_STATUS%" != "APPROVED" then
                        rem echo 🐐 inside first third if
                        echo %check% %ansi_color_success%Approving lyrics...%ansi_color_normal% %conceal_on%ABC%conceal_off%
                        call approve-lyrics "%LYRIC_FILE%" >nul
                        set LYRICS_ACCEPTABLE=1
                        set LYRIC_STATUS=APPROVED
                        gosub approve_lyrics_done
rem     echo 🍉iff ("1" != "`%`LYRICS_FETCHED`%`" .and. "1" != "`%`JUST_APPROVED_LYRICS`%`") .or. ("1" == "`%`FORCE_ASK_TO_APPROVE_LYRICLESSNESS`%`" .and. "`%`LYRICLESSNESS_STATUS`%`" != "APPROVED") then
               iff ("1" != "%LYRICS_FETCHED%" .and. "1" != "%JUST_APPROVED_LYRICS%" .and. "1" != "%LYRICS_ACCEPTABLE%") .or. ("1" == "%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED") then
                        set LYRIC_STATUS=APPROVED
                        set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=8 %+ rem 🐮 hard-coded value warning
                endiff                                     
        else
                set LYRIC_STATUS=NOT_APPROVED
        endiff
                
        iff exist "%LRC_SIDECAR_FILENAME%" then
                set LYRIC_STATUS_BACKUP=%LYRIC_STATUS%
                rem do not gosub refresh_lyric_status here because it assumes LYRIC_FILE
                call get-lyric-status "%LRC_SIDECAR_FILENAME%" silent
                iff "%LYRIC_STATUS%" != "APPROVED" then
                        echo %check% %ansi_color_success%Approving LRC file...%ansi_color_normal% %conceal_on%GHI%conceal_off%
                        call   approve-lyrics "%LRC_SIDECAR_FILENAME%" >nul
                        set LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
                        gosub approve_lyrics_done
                endiff
                set LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
        endiff                

        iff exist "%SRT_SIDECAR_FILENAME%" then
                set LYRIC_STATUS_BACKUP=%LYRIC_STATUS%
                rem do not gosub refresh_lyric_status here because it assumes LYRIC_FILE
                call get-lyric-status "%SRT_SIDECAR_FILENAME%" silent
                iff "%LYRIC_STATUS%" != "APPROVED" then
                        echo %check% %ansi_color_success%Approving SRT file...%ansi_color_normal%
                        call   approve-lyrics "%SRT_SIDECAR_FILENAME%" >nul
                        set LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
                        gosub approve_lyrics_done
                endiff
                set LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
        endiff                
else
        rem echo         ...we’re in the else of that if...GOAT
        gosub AskAboutInstrumental
endiff
rem echo     ...we’re done with that if...GOAT

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem Final chance to hand edit the lyrics, but skip it if we already opted to search Google to save us the hassle:
        rem i THINK this is where to put this:
                :post_googling_for_lyrics_point

        rem Decide whether we are even asking:
                rem DEBUG:  echo DO_NOT_ASK_TO_HAND_EDIT=%DO_NOT_ASK_TO_HAND_EDIT% ... ALREADY_HAND_EDITED=%ALREADY_HAND_EDITED%, WE_GOOGLED=%WE_GOOGLED, AUTOMATIC_HAND_EDITING_IF_GOOGLING=%AUTOMATIC_HAND_EDITING_IF_GOOGLING, FORCE_HAND_EDIT=%FORCE_HAND_EDIT% 
                if "1" == "%FORCE_HAND_EDIT%"                                                (goto :hand_edit_lyrics_right_now_without_asking)
                if "1" == "%WE_GOOGLED%" .and. "%AUTOMATIC_HAND_EDITING_IF_GOOGLING%" == "1" (goto :hand_edit_lyrics_right_now_without_asking)
                if "1" == "%DO_NOT_ASK_TO_HAND_EDIT%" .or. "1" == "%ALREADY_HAND_EDITED%"    (goto :reject_hand_editing_question_entirely)
                
        rem Ask if we are supposed to:   
                rem echo 🌴 iff "1" != GENIUS_ONLY="%GENIUS_ONLY%" .and. "1" != ALREADY_HAND_EDITED="%ALREADY_HAND_EDITED%" then and. LYRICLESSNESS_STATUS="%LYRICLESSNESS_STATUS%" != "APPROVED" then         🐐
                iff "1" != "%GENIUS_ONLY%" .and. "1" != "%ALREADY_HAND_EDITED%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED" then         
                        call AskYN "Hand-edit our%conceal_on%H%conceal_off%lyrics" no %HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME%
                endiff
                
        rem Do the hand-editing, if we have decided to:                
                :hand_edit_lyrics_right_now_without_asking
                iff "%answer%" == "Y" .or. "1" == "%FORCE_HAND_EDIT%" .or. ("%WE_GOOGLED%" == "1" .and. "%AUTOMATIC_HAND_EDITING_IF_GOOGLING%" == "1") then
                        rem Create 0-byte file for us to edit:
                                if not exist "%LYRIC_FILE%" >:u8"%LYRIC_FILE%"

                        rem Edit the file if we have decided to....
                                rem echo [4] about to call edit_lyrics_now_if_we_answered_H 🐐 ... answer=“%ANSWER%”
                                gosub edit_lyrics_now_if_we_answered_H Y force
        
                        iff exist "%LYRIC_FILE%"  then
                                call review-file -wh "%LYRIC_FILE%" "%italics_on%Post%italics_off%-hand-edited lyrics"                        
                                gosub divider                
                                call AskYn "Are the post-hand-edited lyrics now acceptable" yes %HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME%
                                     echo GOAT001 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     if "%answer%" == "N" set LYRICS_ACCEPTABLE=0
                                     if "%answer%" == "N" set LYRIC_STATUS=NOT APPROVED
                                     if "%answer%" == "N" set goto_end=0
                                     echo GOAT002 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     rem   nswer%" == "Y" .and. "%LYRIC_STATUS%" !=  "APPROVED" (call approve-lyrics  "%LYRIC_FILE%" %+ call display-lyric-status  "%LYRIC_FILE%")
                                     if "%answer%" == "Y" .and. "%LYRIC_STATUS%" !=  "APPROVED" (call approve-lyrics  "%LYRIC_FILE%" )
                                     echo GOAT003 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     if "%answer%" == "Y" gosub approve_lyrics_done
                                     echo GOAT004 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     if "%answer%" == "Y" set goto_end=1
                                     echo GOAT005 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     if "%answer%" == "Y" goto END
                                     echo GOAT006 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                        else
                                echo Not sure if we need an else here ? >nul
                        endiff
                        rem 
                        echo 🐐 okay right here[19Y], LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” ... goto_end=“%goto_end%”
                        if "Y" == "%answer%"   goto :END
                        if "1" == "%goto_end%" goto :END
                else
                        rem This made no sense, and leaving this here as a reminder to prevent this idea from creeping up erroneously a 2ⁿᵈ time:
                                rem call AskYN "Are the lyrics %italics_on%still%italics_off% good (why would we ask this here?)" no %HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME%
                                rem         iff "%answer%" == "Y" then 
                                rem                 set LYRICS_ACCEPTABLE=1
                                rem         else                        
                                rem                 set LYRICS_ACCEPTABLE=0
                                rem         endiff
                
                endiff

                echo 🐐 okay right here[19Z], LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” ... goto_end=“%goto_end%”
                if "Y" == "%answer%"   goto :END
                if "1" == "%goto_end%" goto :END
                rem if     exist "%LYRIC_FILE%" echo %@randfg_soft[]🐐🐐 lyric file exists! [goto_end=%goto_end%] [lyric_status=“%lyric_status%”]"
                rem if not exist "%LYRIC_FILE%" echo %@randfg_soft[]🐐🐐 lyric file DOESN’T exists! [goto_end=%goto_end%] [lyric_status=“%lyric_status%”]"
                if "%1" == "%goto_end%" goto :END

                :nexty_next_next
                unset /q WE_GOOGLED

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem TODO: Perhaps a prompt to reject the lyrics here {and delete the file}, i needed that in at least 1 case. it would have to default to 0

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

:reject_hand_editing_question_entirely

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————

rem Mark the lyric file as approved/disapproved, using windows Alternate Data Streams:


        iff exist "%LYRIC_FILE%" .and. 1 ne %LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED then
                rem echo LYRIC_STATUS is %LYRIC_STATUS 🐶🐶🐶
                rem gosub divider
                iff 1 eq %LYRICS_ACCEPTABLE% .and. "%LYRIC_STATUS%" !=  "APPROVED" then
                        rem double-message: call less_important "Approving lyrics %conceal_on%JJ%conceal_off%"
                        call  approve-lyric-file "%LYRIC_FILE%" >nul
                        gosub approve_lyrics_done
                endiff                        
                iff 0 eq %LYRICS_ACCEPTABLE .and. "%LYRIC_STATUS%" !=  "NOT_APPROVED" then 
                        call less_important "%underline_on%DIS%underline_off%approving lyrics...%conceal_on%Q94%conceal_off%"
                        call disapprove-lyric-file "%LYRIC_FILE%" >nul
                        set JUST_APPROVED_LYRICS=0
                        set LYRIC_STATUS=NOT_APPROVED
                        set LYRICS_JUST_DISAPPROVED=1
                endiff                        
        endiff

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━——————————————


rem Start our cleanup:
        :Cleanup
        rem (moved to very end)

rem While we’re here, create LRCs from pre-existing SRTs?:
        rem Currently: No. We prefer to do this *after* making our SRT:
        rem ❓ or perhaps even only if we absolutely have to (for eccsrt2lrc2clip.bat) ❓
        rem call srt2lrc.bat


rem Validate we did something:

        set GENERAL_LYRIC_FAILURE=0
        iff not exist "%LYRIC_FILE%" then
                echo Tracer NELF
                if "%LYRICLESSNESS_STATUS%" != "APPROVED"  set GENERAL_LYRIC_FAILURE=1
        else
                echo Tracer GLF1 -- JUST_APPROVED_LYRICS=%JUST_APPROVED_LYRICS% JUST_APPROVED_LYRICLESSNESS=%JUST_APPROVED_LYRICLESSNESS%, LYRICS_ACCEPTABLE=%LYRICS_ACCEPTABLE%
                iff "1" == "%JUST_APPROVED_LYRICS%" .or. "%LYRIC_STATUS%" == "APPROVED" then 
                        set GENERAL_LYRIC_FAILURE=0    
                        echo Tracer GLF1-A .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                elseiff "1" == "%JUST_APPROVED_LYRICLESSNESS%" then
                        set GENERAL_LYRIC_FAILURE=0
                        echo Tracer GLF1-B .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                elseiff  "0" == "%LYRICS_ACCEPTABLE%"  .or. "%LYRIC_STATUS%" == "NOT APPROVED" then
                        echo Tracer GLF1-C .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                        set GENERAL_LYRIC_FAILURE=1
                elseiff  "1" != "%LYRICS_ACCEPTABLE%" .and. "1" !=  "%LYRICS_JUST_SPPROVED%" .and. "%LYRIC_STATUS%" != "APPROVED" then
                        echo Tracer GLF1-D .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                        set GENERAL_LYRIC_FAILURE=1
                endiff
        endiff

        if "1" != "%GENERAL_LYRIC_FAILURE%" goto :lyric_final_success
                rem echo 🐐 Trace FLEN
                rem Take note of the fact that we failed to fetch the lyrics for this audio file!:
                        set LYRICS_FETCHED=0
                        set LYRIC_SEARCH_FAILED=1

                rem Display our failure in abject shame:
                        gosub divider
                        rem      call nn "%emoji_warning% %ansi_color_alarm%LYRIC FAIL%ansi_color_normal% %emoji_warning%"
                        rem  ⚠️ LYRIC FAIL  ⚠️
                        rem  ⚠️ LYRIC FAIL  ⚠️
                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[red]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                        repeat 3 call bigecho " %emoji_warning% %ansi_color_alarm% LYRIC FAIL %ansi_color_normal% %emoji_warning%"
                        gosub divider
                        if 1 eq %ABANDONED_SEARCH% goto :END
                        set FILE_ARTIST_WARNING_PART=
                        if "%FILE_ARTIST%" != "" set FILE_ARTIST_WARNING_PART=%FILE_ARTIST% - ``
                        echo %ANSI_COLOR_WARNING% %EMOJI_WARNING% Unfortunately, we could not find lyrics for “%ANSI_COLOR_BRIGHT_RED%%ITALICS_On%%FILE_ARTIST_WARNING_PART%%FILE_SONG%%ITALICS_OFF%%ansi_color_warning%” %EMOJI_WARNING% %ANSI_COLOR_NORMAL%
                        set   goto_end=1
                        title %emoji_warning% Lyrics not fetched %emoji_warning%
        goto :end


        :lyric_final_success
        rem echo 🐐 Trace QUAY2
        rem Take note of the fact that we have now successfully fetched the lyrics for this audio file!:
                set LYRICS_FETCHED=1
                set LYRIC_SEARCH_FAILED=0

        rem Make it silent if this is part of a batch:
                iff "%_pbatchname" == "get-the-missing-lyrics-here-temp.bat" then
                        rem If we are in a batch job, be quiet:
                        set silent_or_nothing=silent 
                else                
                        rem But also ultimately, just be quiet all the time (we changed our minds): [todo could make this an option]
                        set silent_or_nothing=silent
                endiff                        

        rem Although we created our “divider” subroutine to lower the overhead of actually calling divider.bat,
        rem *this* particular one in *this* particular instance created a cosmetic bug not worth the debug time,
        rem so we just revert to the “normal” way of calling the .BAT file instead of the subroutine we made here:
                gosub divider

        rem Celebrate!! 🍰🍰🍰🍰🍰🍰🍰🍰🍰🍰🍰
                rem  celebrate "%check% LYRIC SUCCESS %check%" 2
                rem  celebrate "%ansi_background_black% %check%  %@cool[LYRIC SUCCESS] %check% %@randfg[]" 2
                rem  celebrate "%ansi_background_black% %check% %@rainbow_string[LYRIC SUCCESS] %check%  %@randfg[]" 
                rem  celebrate "%ansi_background_black% %check% %@cursive[LYRIC SUCCESS] %check%  %@randfg[]" 
                iff "1" != "%GENIUS_ONLY%" then 
                        call celebrate "%ansi_background_black% %italics_off%%check% %@cursive[LYRIC SUCCESS] %check%  %@randfg[]" %silent_or_nothing%                        
                        set LYRIC_SUCCESS_CELEBRATION_DISPLAYED=1
                endiff
                rem Redundant at this point.... I think.... call important_less "Lyrics downloaded:  %blink_on%%italics_on%%LYRIC_FILE%%ANSI_RESET%"            

        rem Display newly-updated lyric / lyricLESSness status:                
                rem echo checking[aa] 🐐 %ansi_color_bright_yellow% iff exist "%LYRIC_FILE%" then %ansi_color_normal%
                iff exist "%LYRIC_FILE%" then
                        title %check% Lyrics aligned successfully! %check% 
                        if "%LYRIC_STATUS%" !=  "APPROVED" call approve-lyrics  "%LYRIC_FILE%" 
                        call display-lyric-status  "%LYRIC_FILE%"
                else
                        title %check% Lyriclessness approved! %check% 
                        rem call approve-lyriclessness        "%LYRIC_FILE%" 
                        rem echo 🐐 about to %ansi_color_bright_yellow%call display-lyriclessness-status "%AUDIO_FILE%"%ansi_color_normal%
                        call display-lyriclessness-status "%AUDIO_FILE%"
                endiff
        
        rem echo All done? 🐐🐮🐐🐮🐐🐮
        set    goto_end=1
        if "1" == "%goto_end%" echo Going to end? I guess so, since 1==%%going_to_end%% 🐐🐮🐐🐮🐐🐮
        if "1" == "%goto_end%" goto END
        if "1" == "%ABANDONED_SEARCH%" goto END
        echo this is NOT the end! 🐐🐮🐐🐮🐐🐮

rem If we couldn’t find lyrics, as if we want to approve this as our final lyic status: The status of “lyriclessness”
        :ask_to_approve_lyriclessness


rem echo %blink_on%  i thought LYRICLESSNESS_STATUS="%LYRICLESSNESS_STATUS%" is not “APPROVED”!   %newline% .......... LYRICS_FETCHED  is %LYRICS_FETCHED% .... FORCE_ASK_TO_APPROVE_LYRICLESSNESS is “%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%” %blink_off% LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%” ....ABANDONED_SEARCH=“%ABANDONED_SEARCH%” .. JUST_APPROVED_LYRICLESSNESS=“%JUST_APPROVED_LYRICLESSNESS%”
        
rem echo iff("1" != "%LYRICS_FETCHED%" .and. "1" != "%JUST_APPROVED_LYRICLESSNESS%" .and. "1" !=  "%LYRICS_ACCEPTABLE%") .or. ("1" == "%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED") then 🐐lyr
        if   "1" == "%LYRIC_SUCCESS_CELEBRATION_DISPLAYED%" goto :skip_2204
        iff ("1" != "%LYRICS_FETCHED%" .and. "1" != "%JUST_APPROVED_LYRICLESSNESS%" .and. "1" !=  "%LYRICS_ACCEPTABLE%") .or. ("1" == "%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED") then
                gosub divider

                echo %ansi_color_prompt%%star% “%ansi_color_orange%Lyric%italics_on%%underline_off%lessness%underline_off%%italics_off%%ansi_color_prompt%” is the state of having given up on finding lyrics. %faint_on%(Or officially deciding it’s an instrumental track)%faint_off%
                echo %ansi_color_prompt%%star% %blink_on%%underline_off%%italics_on%%ansi_color_orange%Approved%italics_off%%blink_off%%underline_off% lyriclessness%double_underline_off%%underone_on% status%underline_off%%ansi_color_prompt% allows automatic AI transcription %italics_on%without%italics_on% having a lyrics file. %faint_on%(Or allows skipping of instrumental tracks)%faint_off%
                call AskYN "Do you want to approve %bold_on%“%ansi_color_orange%lyric%italics_off%lessness%italics_off%%ansi_color_prompt%”%bold_off% status, and officially %italics_on%give up%italics_off% on finding lyrics for this song" %LYRICLESSNESS_APPROVAL_CURRENT_DEFAULT_ANSWER%  %@EVAL[%APPROVE_LYRICLESS_SONGS_WAIT_TIME%*4] %+ rem 🐮 extended wait time 🐮
                set   JUST_APPROVED_LYRICLESSNESS=0
                set JUST_UNAPPROVED_LYRICLESSNESS=0
                iff "Y" == "%ANSWER%" then
                        call approve-lyriclessness-for-file.bat "%AUDIO_FILE%"
                        echo LYRICLESSNESS_STATUS Trace 2 >nul 
                        set  JUST_APPROVED_LYRICLESSNESS=1
                        set  LYRICLESSNESS_STATUS=APPROVED        
                else                        
                        call unapprove-lyriclessness-for-file.bat "%AUDIO_FILE%"
                        set  JUST_UNAPPROVED_LYRICLESSNESS=1
                        set  LYRICLESSNESS_STATUS=NOT_APPROVED

                        gosub AskAboutInstrumental
                endiff
        endiff
        :skip_2204



goto :END
rem echo 🐐🐮🐐🐮🐐🐮 This should not be seen ever...

rem ━━━━━━━━━━━━━━ SUBROUTINES: BEGIN: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


        :approve_lyrics_done []
                rem TODO: consider if we should call approve-lyrics with the file here, or if that’s not necessary if we approved it in-the-moment such that we encoded it. 
                set LYRIC_STATUS=APPROVED
                set LYRICS_FETCHED=1
                set LYRICS_ACCEPTABLE=1
                set JUST_APPROVED_LYRICS=1               
                if "1" != "%[logged_lyricapproval_%AUDIO_FILE%]" @echo %@REPEAT[%newline%,2]%EMOJI_DESKTOP_COMPUTER% %_DATETIME: %check% Approved: Lyrics: “%@UNQUOTE[%@FULL["%AUDIO_FILE%"]]” >>:u8"%AUDIOFILE_TRANSCRIPTION_LOG_FILE%"
                set          logged_lyricapproval_%AUDIO_FILE%=1

        return

        :AskAboutInstrumental []
                rem echo 🐐 called AskAboutInstrumental
                set HAS_INSTRUMENTAL_ADS_TAG=0
                unset /q ADS_TAG
                set IS_INSTRUMENTAL_ADS_FILENAME=%@name[%@UNQUOTE["%AUDIO_FILE%"]].%@EXT[%@UNQUOTE["%AUDIO_FILE%"]]:is_instrumental
                rem echo            🐐 IS_INSTRUMENTAL_ADS_FILENAME=%IS_INSTRUMENTAL_ADS_FILENAME%
                rem TODO: set ADS_TAG=value of getting the ADS tag for is_instrumental 
                if " %ADS_TAG%" ==  ""     set HAS_INSTRUMENTAL_ADS_TAG=0
                if " %ADS_TAG%" !=  ""     set HAS_INSTRUMENTAL_ADS_TAG=1                
                iff "%ADS_TAG%" ==  "True" then
                        set ADS_TAG_SAYS_INSTRMENTAL=1
                else
                        set ADS_TAG_SAYS_INSTRMENTAL=0
                endiff

                rem if it’s not marked as instrumental, ask if it is one...
                rem echo            🐐 checking[f] iff "1" == "`%`@Regex[instrumental,"%AUDIO_FILE%"]" == "%@Regex[instrumental,"%AUDIO_FILE%"]" then
                iff "1" == "%@Regex[instrumental,"%AUDIO_FILE%"]" then
                        echo True>"%IS_INSTRUMENTAL_ADS_FILENAME%"
                else
                        rem Read or ask answer about if it’s an instrumental or not:
                        rem echo            🐐 checking[g] iff "1" != HAS_INSTRUMENTAL_ADS_TAG="%HAS_INSTRUMENTAL_ADS_TAG%" then
                        iff "1" != "%HAS_INSTRUMENTAL_ADS_TAG%" then
                                call AskYN "Is this an instrumental?" No 30 
                        else
                                iff "1" == "%ADS_TAG_SAYS_INSTRUMENTAL%" then
                                        set ANSWER=Y
                                else
                                        set ANSWER=N
                                endiff
                        endiff
                        iff "Y" == "%ANSWER%" then
                                echo True>"%IS_INSTRUMENTAL_ADS_FILENAME%"
                                echo %star2% Then rename it as such!
                                call rn "%AUDIO_FILE%"
                                if "" !=  "%LAST_RENAMED_TO%" set AUDIO_FILE=%@UNQUOTE[%LAST_RENAMED_TO%]
                                if "" !=  "%LAST_RENAMED_TO%" set JUST_RENAMED_TO_INSTRUMENTAL=1
                                gosub rename_audio_file_as_instrumental
                        else
                                gosub debug "echo False to “%IS_INSTRUMENTAL_ADS_FILENAME%”"
                                echo False>"%IS_INSTRUMENTAL_ADS_FILENAME%"
                        endiff

                        rem echo            🐐 gonna gosub rename_audio_file_as_instrumental from AskAboutInstrumental
                endiff
        return

        :ask_if_want_mark_lyriclessness []
                echo 🌷🌷🌷  Asking if we want to mark as lyricless.... 🌷🌷🌷 >nul
                echo %ansi_color_advice%%star2% NOTE: “%ansi_color_bright_yellow%lyric%underline_on%less%underline_on%%ansi_color_advice%”     means “we can’t/won’t find lyrics for this song”
                echo %ansi_color_advice%%star2%       “%ansi_color_bright_yellow%linstrumental%ansi_color_advice%” means “no words are sung or spoken at all”
                :ask_if_want_mark_lyriclessness_2
                call AskYn "Want to mark this song %ansi_green%i%ansi_color_prompt%nstrumental or %ansi_green%l%ansi_color_prompt%yrics %underline_on%unfindable%underline_off% (i.e. officially abandon our lyric search[%ansi_color_bright_green%Z%ansi_color_prompt%=All]) [P=Preview]" no 300 IGLPZ I:Mark_this_file_as_an_instrumental,G:Google,L:It’s_Lyricless,Z:Mark_all_as_lyricless,P:Play_it %+ rem 🐮 hard-coded value
                gosub check_for_answer_of_G
                gosub check_for_answer_of_I
                if "1" == "%GOTO_END%" (goto :END)
                gosub check_for_answer_of_L
                gosub check_for_answer_of_P
                if  "P" == "%ANSWER%" goto :ask_if_want_mark_lyriclessness_2
                iff "Y" == "%ANSWER%" then 
                        set ABANDONED_SEARCH=1
                        set ANSWER=L
                        gosub check_for_answer_of_L
                        rem echo Just got back from check_for_answer_of_L called FROM WITHIN :ASK_IF_WANT_MARK_LYRICLESSNESS [] ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”
                        if 1 eq %goto_END% goto :END
                endiff
                if "1" == "%GOOGLE_NOW%" (goto :Google_Now)
                if "1" == "%GOTO_END%"   (goto :goto_end  )
        return
        goto :END

        :check_for_answer_of_D [opt]
                gosub check_for_answer_of_D_to_eset_artist_and_song %opt%
        return
        :check_for_answer_of_D_to_eset_artist_and_song []
                rem 
                echo 🎨 checking if answer of ‘%answer%’ is “%blink_on%D%blink_off%”
                iff  "%answer%" == "D"  then
                        gosub eset_fileartist_and_filesong
                        set goto_download_with_lyric_downloader_1=1
                        rem echo 🎨 it is! setting goto_download_with_lyric_downloader_1 to “%goto_download_with_lyric_downloader_1%”
                else
                        rem echo 🎨 it isn’t❕❔?!?!!
                endiff
                rem do this after calilng: if "1" == "%goto_download_with_lyric_downloader_1%" goto :download_with_lyric_downloader_init
        return

        :check_for_answer_of_H [opt]
                gosub edit_lyrics_now_if_we_answered_H %opt%
        return

        :check_for_answer_of_L [opt]
                rem echo %ANSI_COLOR_MAGENTA%goat010101 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%

                set HOLD_ANSWER_CFAOL=%answer%
                if "%answer%" == "L" gosub mark_as_lyricless %opt%

                if "%HOLD_ANSWER_CFAOL%" == "L" set goto_END=1
                set answer=%HOLD_ANSWER_CFAOL%
                rem echo %ANSI_COLOR_MAGENTA%goat020202 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%

                iff "%answer%" == "Z" then
                        for %%tmpFileForZAnswer in (%FILEMASK_AUDIO%) gosub mark_as_lyricless "%@UNQUOTE["%tmpFileForZAnswer%"]"
                        set goto_END=1
                endiff
                set answer=%HOLD_ANSWER_CFAOL%

                echo %ANSI_COLOR_MAGENTA%goat030303 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%

           echo if "1" == "%GOTO_END%" (goto :END)
                if "1" == "%GOTO_END%" (goto :END)
           echo Why didn’t it work?

                echo %ANSI_COLOR_MAGENTA%goat040404 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%
        return

        :check_for_answer_of_O
                iff "%ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" then
                        set goto_download_with_lyric_downloader_init=1
                        goto download_with_lyric_downloader_init
                endiff
        return

        :check_for_answer_of_P [opt]
                rem echo 🔥🔥🔥 called: get-lyrics: check_for_answer_of_P [opt=%opt%]
                :try_again
                iff "%PLAYER_COMMAND%" == "" then
                        rem echo %ANSI_COLOR_WARNING%%EMOJI_CAUTION%Player command isn’t set! setting to vlc.exe for best odds...%ansi_color_normal%
                        set  PLAYER_COMMAND=%DEFAULT_PLAYER_COMMAND%
                endiff
                if "%PLAYER_COMMAND%" == "" goto :try_again
                rem echo %arrow% check_for_answer_of_P [] ... audio_file = %AUDIO_FILE%, SONGFILE= %SONGFILE%,%SONG_FILE%
                iff "%answer%" == "P" then
                        echo %ANSI_COLOR_IMPORTANT%%STAR% Playing file: “%AUDIO_FILE%” %ansi_color_normal%
                        set FILE_TO_USE=%AUDIO_FILE%
                        if "%opt%" != "" set FILE_TO_USE=%opt%
                        set player_command=%PLAYER_COMMAND% "%@UNQUOTE["%FILE_TO_USE%"]"
                        echo %ansi_color_debug%- Player command: %faint_on%%PLAYER_COMMAND%%faint_off%
                        %PLAYER_COMMAND% 
                endiff
        return

        :check_for_answer_of_G []
                if  "%ANSWER%" == "G" set GOOGLE_NOW=1 
                if  "%ANSWER%" != "G" set GOOGLE_NOW=0
                iff "%ANSWER%" == "G" .or. "1" == "%GOOGLE_NOW%" then
                        set  GOOGLE_NOW=1
                        goto Google_Now
                endiff
                if "1" == "%GOOGLE_NOW%" goto Google_Now
        return

        :check_for_answer_of_I []                        
                iff "%answer%" == "X" then
                        echo dry run:
                        for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) echo gosub rename_audio_file_as_instrumental "%@UNQUOTE["%tmpFileForXAnswer%"]"
                        pause
                        echo real run:
                        pause
                        for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) gosub rename_audio_file_as_instrumental "%@UNQUOTE["%tmpFileForXAnswer%"]"
                        set goto_END=1
                else
                        gosub rename_audio_file_as_instr_if_answer_was_I 
                endiff       
                 if "1" == "%GOTO_END%" (goto :END)
        return

        :check_for_answer_of_X
                if "X" == "%ANSWER%" for %%tmpCFAXfile in (%filemask_audio%) do gosub rename_audio_file_as_instrumental "%@UNQUOTE["%%tmpCFAXfile"]"
        return

        :debug [msg]
                echo %ANSI_COLOR_DEBUG%- DEBUG: %msg% %ansi_color_normal%
        return

        :DisplayAudioFileName []
                echo %star% Audio file: %faint_on%%AUDIO_FILE%%faint_off%%conceal_on%%0%%conceal_off%
        return
        :DisplayAudioDirectory [opt]
                 rem  %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio directory: %ansi_color_bright_red%“%italics_on%%blink_off%%ansi_color_green%%@PATH[%AUDIO_FILE%]%blink_off%%italics_off%%ansi_color_prompt%%ansi_color_bright_red%”%ansi_color_normal%                        
                 echo %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio directory: %ansi_color_bright_red%“%italics_on%%blink_off%%ansi_color_green%%@IF["" != "%@UNQUOTE[%@PATH[%AUDIO_FILE%]]",%@PATH[%AUDIO_FILE%],%_CWP]%blink_off%%italics_off%%ansi_color_prompt%%ansi_color_bright_red%”%ansi_color_normal%
                 rem echo %ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP% TESTING 🐐
                if "%opt%" == "nofilename" goto :nofilename
                echos %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio %@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "", ,]filename%ansi_color_yellow%:%ansi_color_prompt%  %@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "",%tmpSpacer%,]“%italics_on%%blink_off%%ansi_color_green%%AUDIO_FILE_TO_DISPLAY_NAME%%blink_off%%italics_off%%ansi_color_prompt%”
                :nofilename
        return

        :divider [divider_param]
                iff "1" == "%suppress_next_divider%" then
                        set  suppress_next_divider=0
                        return
                endiff
                set wd=%@EVAL[%_columns - 1]
                set nm=%bat%\dividers\rainbow-%wd%.txt
                iff exist %nm% then
                        *type %nm%
                        set last_divider_method=type
                        set last_divider_param=%divider_param%
                else
                        echo %@char[27][93m%@REPEAT[%@CHAR[9552],%wd%]%@char[27][0m
                        set last_divider_method=echo
                endiff
                iff "%divider_param%" == "NoNewline"  then
                        set last_divider_newline=False
                else 
                        set last_divider_newline=True
                        rem we COULD do the newline character, but it’s easier to just do a few spaces so that we end up on the new line anyway:
                        rem echos %NEWLINE%%@ANSI_MOVE_TO_COL[1] 
                        echos     %@ANSI_MOVE_TO_COL[1] 
                endiff
                rem echo last_divider_newline=%last_divider_newline% should we do one?
        return

        :eset_fileartist_and_filesong []
                rem 🧹 make sure the variables are clean and ready for modification 🧹
                        if not defined FILE_ARTIST (set FILE_ARTIST=?)
                        if not defined FILE_SONG   (SET   FILE_SONG=?)

                rem Pre-set it to the last thing we changed it to, in case the situation is happening multiple times:
                        if "" !=  "%FILE_ARTIST_LAST_CHANGED_TO%" set FILE_ARTIST=%FILE_ARTIST_LAST_CHANGED_TO%
                        rem   !=    "%FILE_SONG_LAST_CHANGED_TO%" set   FILE_SONG=%FILE_SONG_LAST_CHANGED_TO%    ━━━ it doesn’t make sense to do it for the song; only for the artist

                rem keep track of original values:
                        set FILE_ARTIST_BEFORE_CHANGE=%FILE_ARTIST%
                        set   FILE_SONG_BEFORE_CHANGE=%FILE_SONG%

                rem Display filename in case its scrolled off the screen and we can’t ascertain it:                        
                rem ✍🏻 hand-editing artist/song name: ✍🏻 
                        gosub DisplayAudioDirectory nofilename
                        gosub DisplayAudioFilename
                         set FILE_ARTIST_PRE_ESET=%FILE_ARTIST%
                        eset FILE_ARTIST
                        gosub DisplayAudioFilename
                         set FILE_SONG_PRE_ESET=%FILE_SONG%
                        eset FILE_SONG
                        rem  FILE_ALBUM

                rem Massage ’ into ' because ’ doesn’t match ' in genius searches:
                        set   FILE_SONG=%@Replace[’,',%FILE_SONG%]
                        set FILE_ARTIST=%@Replace[’,',%FILE_ARTIST%]

                rem Update flag:
                        if "%FILE_ARTIST_PRE_ESET%" != "%FILE_ARTIST%" .or. "%FILE_SONG_PRE_ESET%" != "%FILE_SONG%"   set debanded=0

                rem Store values for future runs:
                        iff "%FILE_ARTIST%" != "%FILE_ARTIST_BEFORE_CHANGE%" then
                                rem echo setting FILE_ARTIST_LAST_CHANGED_TO=%FILE_ARTIST% 🐺
                                set FILE_ARTIST_LAST_CHANGED_TO=%FILE_ARTIST%
                        endiff
                        iff "%FILE_SONG%"   !=   "%FILE_SONG_BEFORE_CHANGE%" then
                                rem echo setting FILE_SONG_LAST_CHANGED_TO=%FILE_SONG% 🐺
                                set   FILE_SONG_LAST_CHANGED_TO=%FILE_SONG%
                        endiff
                        

                rem Update related/alias values based on new values:
                        set        FILE_SONG_TO_USE=%FILE_SONG%
                        set       FILE_TITLE_TO_USE=%FILE_SONG%
                        set      FILE_ARTIST_TO_USE=%FILE_ARTIST%
                        set FILE_ORIG_ARTIST_TO_USE=%FILE_ORIG_ARTIST%
                        set       FILE_ALBUM_TO_USE=%FILE_ALBUM%
                        rem gosub debug "🎨🎨🎨[30] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
        return

        :edit_lyrics_now_if_we_answered_H [subarg force]
                iff "H" == "%ANSWER%" .or. "%force%" == "force" .or. ("%ANSWER%" == "%subarg%" .and. "" !=  "%subarg") then
                        echos %ANSI_POSITION_SAVE%
                        set EDIT_CALL=%EDITOR% "%LYRIC_FILE%"
                        echo editing lyric file because answer=“%answer%”  ... google_now=“%google_now%”.... call = “%blink_on%%edit_call%%blink_off%” 💩
                        %EDIT_CALL%
                        rem   2025/01/23: Not sure if this is necessary anymore: echos %ANSI_POSITION_RESTORE%
                        rem   pause "%ansi_color_warning_soft%%blink_on%Press any key when done hand-editing the lyrics...%blink_off%%ansi_color_normal%"
                        rem   pause-for-x-seconds %LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS% "%ansi_color_bright_yellow%%pencil% Hit a key when done editing lyrics... %faint_on%(leave blank if none found or if done by mistake)%faint_off% %pencil% %ansi_color_normal%"
                              pause "%ansi_color_warning_soft%%blink_on%Press any key when done hand-editing the lyrics...%blink_off%%ansi_color_normal%"
                        set   ALREADY_HAND_EDITED=1
                        rem echo 🐐 checking[bb] if filesize["%LYRIC_FILE%"] of “%@FILESIZE["%LYRIC_FILE%"]” lt 5 then 
                        iff %@FILESIZE["%LYRIC_FILE%"] lt 5 then 
                                set LYRICS_ACCEPTABLE=0
                                *del /q "%LYRIC_FILE%" >nul
                                gosub ask_if_want_mark_lyriclessness
                        else
                                set LYRICS_ACCEPTABLE=1
                                set JUST_APPROVED_LYRICS=1
                        endiff                                
                        echo LYRICS_ACCEPTABLE=%LYRICS_ACCEPTABLE%, JUST_APPROVED_LYRICS=%JUST_APPROVED_LYRICS%
                else
                        set  DO_NOT_ASK_TO_HAND_EDIT=1
                        echo FORCE_HAND_EDIT trace ZZZ >nul 
                        set  FORCE_HAND_EDIT=0
                endiff
        return
        goto :END
              
        :mark_as_lyricless [use_this_file_instead]
                echo %faint_on%🐱 CALLED: mark_as_lyricless [Q1X1] in get-lyrics-for-file with use_this_file_instead=“%use_this_file_instead%”%faint_off%, answer=“%ANSWER%”
                set HOLD_ANSWER=%ANSWER%
                set FILE_TO_MARK_AS_LL=%AUDIO_FILE%
                set SIDECAR_LYRICS=%@NAME["%AUDIO_FILE%"].txt
                if "" != "%@UNQUOTE["%use_this_file_instead%"]" set FILE_TO_MARK_AS_LL=%use_this_file_instead%
                rem echo %faint_on%🐱 CALLED: mark_as_lyricless [Q1X2] FILE_TO_MARK_AS_LL is “%FILE_TO_MARK_AS_LL%”.... INPUT_FILE=“%INPUT_FILE%”%faint_off% 
                call bigecho "%ansi_color_blue%%STAR2% Marking as lyricless and approving lyric%underline_on%%italics_on%less%italics_off%%underline_off%ness..."
                call approve-lyriclessness-for-file.bat "%@UNQUOTE["%FILE_TO_MARK_AS_LL%"]"
                set     goto_END=1
                set  ABANDONED_SEARCH=1
                set  JUST_APPROVED_LYRICLESSNESS=1
                if "1" != "%[logged_lyriclessness_%use_this_file_instead%]" @echo %@REPEAT[%newline%,2]%EMOJI_DESKTOP_COMPUTER% %_DATETIME: %no% Approved: Lyriclessness: “%@UNQUOTE["%@FULL["%file_to_mark_as_ll%"]"]” >>:u8"%AUDIOFILE_TRANSCRIPTION_LOG_FILE%"
                set          logged_lyriclessness_%use_this_file_instead%=1

                set  JUST_APPROVED_LYRICS=0
                set  LYRICLESSNESS_STATUS=APPROVED              
                echo LYRICLESSNESS_STATUS Trace 1 - status is “%LYRICLESSNESS_STATUS%” >nul
                rem echo 🐐 checking if exist: SIDECAR_LYRICS==“%SIDECAR_LYRICS%”
                iff exist "%SIDECAR_LYRICS%" then
                        echo Deleting lyric file of "%SIDECAR_LYRICS%" ???
                        del /p /a: /f  "%TXT_FILE%"
                endiff
                rem echo    ™™™ Lyriclessness marked! ™™™ 🐐  goto_end is %GOTO_END% ..... LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                rem gosub divider
                rem echo            🐐 about to gosub into %italics%AskAboutInstrumental%italics_off% from %italics%mark_as_lyricless%italics_off% [55A]
                gosub AskAboutInstrumental
                rem echo            🐐 %@cool[returned] from AskAboutInstrumental
                set ANSWER=%HOLD_ANSWER%
                goto END
                return 666
                rem echo            🐐 returning from %italics%mark_as_lyricless%italics_off% [55B]
                if "Z" != "%ANSWER%" goto :end
        return                


        :rename_audio_file_as_instr_if_answer_was_I []
                if "I" == "%ANSWER%" gosub rename_audio_file_as_instrumental
        return

        :rename_audio_file_as_instrumental [different_filename_than_usual]                        
                rem Process filename parameter:
                        iff "" == "%different_filename_than_usual%" then
                                set filename_to_rename_as_instrumental=%audio_file%
                        else
                                set filename_to_rename_as_instrumental=%different_filename_than_usual%
                        endiff

                rem Skip if the file has already been marked as an instrumental:
                        iff "%@Regex[instrumental,"%filename_to_rename_as_instrumental%"]" == "1" then
                                echo %ansi_color_warning_soft%%star2% %italics_on%Already marked%italics_off% as instrumental: “%faint_on%%filename_to_rename_as_instrumental%%faint_off%”
                                return
                        endiff

                rem Delete the existing lyric file, since if it’s an instrumental, there shoudln’t be one:
                        set  LYRIC_SIDECAR=%@NAME["%filename_to_rename_as_instrumental%"].txt
                        echo %ansi_color_removal%LYRIC_SIDECAR is “%LYRIC_SIDECAR%”
                        if exist "%LYRIC_SIDECAR%" *del /p "%LYRIC_SIDECAR%"

                rem Unset status bar if it’s set:
                        call status-bar unlock
                        echo 🐐 rename_audio_file_as_instrumental called with filename_to_rename_as_instrumental == “%filename_to_rename_as_instrumental%”

                rem Rename the file:
                        echos %ANSI_ERASE_TO_END_OF_SCREEN%
                        rem  rn "%AUDIO_FILE%"                          "%@NAME["%filename_to_rename_as_instrumental%"] [instrumental].%@EXT["%filename_to_rename_as_instrumental%"]"
                        echo %ansi_color_unimportant%call rn "%@UNQUOTE[%filename_to_rename_as_instrumental%]" "%@NAME["%filename_to_rename_as_instrumental%"] [instrumental].%@EXT["%filename_to_rename_as_instrumental%"]"%ansi_color_normal% 🐐🐐
                        call rn "%@UNQUOTE[%filename_to_rename_as_instrumental%]" "%@NAME["%filename_to_rename_as_instrumental%"] [instrumental].%@EXT["%filename_to_rename_as_instrumental%"]"


                rem Validate that the renaming happened:
                        echo BUG MONITOR for bug of: Marking instrumental doesn’t end when it should. Checking iff "" != "`%`LAST_RENAMED_TO`%`" which is “%LAST_RENAMED_TO%”... 🐐
                        iff "" != "%LAST_RENAMED_TO%" then
                                rem let’s not do this anymore: (20250221): set AUDIO_FILE=%@UNQUOTE[%LAST_RENAMED_TO%]
                                set JUST_RENAMED_TO_INSTRUMENTAL=1
                                rem Not anymore because we may be calling this for every file in the folder: quit
                                rem Instead:
                                set GOTO_END=1
                                echo BUG MONITOR for bug of: Marking instrumental doesn’t end when it should. GOTO_END is now “%GOTO_END%” and JUST_RENAMED_TO_INSTRUMENTAL is now “%JUST_RENAMED_TO_INSTRUMENTAL%” 🐐
                        endiff
        return


        :refresh_lyric_status [opt]
                echo 🐐 called refresh_lyric_status [%opt%]
                set FILE_TO_GET_LYRIC_STATUS_OF=%LYRIC_FILE%
                if exist %opt% set FILE_TO_GET_LYRIC_STATUS_OF="%@UNQUOTE["%opt%"]"
                echo 🐐 %blink_on% %ansi_color_orange% getting lyric status of “%FILE_TO_GET_LYRIC_STATUS_OF%” %blink_off% 
                if exist "%FILE_TO_GET_LYRIC_STATUS_OF%" goto :we_good
                        echo %ansi_color_warning_soft%%star2% Lyric file doesn’t exist to get status of in the first place: “%FILE_TO_GET_LYRIC_STATUS_OF%”
                        set LYRIC_STATUS=DOES_NOT_EXIST
                        return
                :we_good
                set REFRESH_COMMAND=call get-lyric-status "%@UNQUOTE["%FILE_TO_GET_LYRIC_STATUS_OF%"]"
rem silent
echo %blink_on% %ansi_color_orange% lyric status refresh command will be %REFRESH_COMMAND% %blink_off% 
                iff exist "%FILE_TO_GET_LYRIC_STATUS_OF%" .or. "%opt%" == "force" then
                        %REFRESH_COMMAND% >nul
                        if ""=="%last_file_to_get_lyric_status_of%" set last_file_to_get_lyric_status_of="%@UNQUOTE["%FILE_TO_GET_LYRIC_STATUS_OF%"]"
                endiff
echo %blink_on% %ansi_color_orange% got lyric status of “%lyric_status%” %blink_off% 
        return

        :refresh_lyriclessness_status [opt]
                gosub "%BAT%\create-srt-from-file.bat" refresh_lyriclessness_status %opt%
        return

        :set_postprocessed_lyrics [opt]
                rem call like: gosub set_postprocessed_lyrics "%lyric_file%"
                set file_to_use=%LYRIC_FILE%
                if "" != "%opt%" set file_to_use=%@UNQUOTE[%opt%]
                call set-tmp-file "postprocessed lyrics"
                rem e "%@UNQUOTE["%LYRIC_FILE%"]" |:u8 lyric-postprocessor.pl -A -L -S) >%tmpfile%
                (type            "%file_to_use%"  |:u8 lyric-postprocessor.pl -A -L -S) >%tmpfile%
                iff defined postprocessed_lyrics .and. exist %postprocessed_lyrics% .and. "%last_file_used_for_lyric_processing%" == "%file_to_use%" then
                        rem do nothing because it’s already set to an existing postprocessed file
                else
                        set postprocessed_lyrics=%tmpfile% 
                endiff
                set last_file_used_for_lyric_processing=%file_to_use%
        return                        


rem ━━━━━━━━━━━━━━ SUBROUTINES: END ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

:END
        rem echo 🦴 this is the end! %+ rem call pause-for-x-seconds 9
        rem echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 end 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 >nul
echo This is the end of get-lyrics-for-file! pbatchname=%_PBATCHNAME
echo on
:SetVarsOnly_skip_to_2
:The_VERY_End
        echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 end 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 >nul
        rem echo 🦴 this is the very end! %+ rem call pause-for-x-seconds 9

        rem Fix command separator:        
                if "%username%" != "claire" goto :fcs_end
                        @setdos /x0
                        @setdos /x-5
                        @setdos /c%DEFAULT_COMMAND_SEPARATOR_CHARACTER%
                        @setdos /x0
                :fcs_end

        rem Clean our temporary file (do we want to do this in SetVarsOnly mode?):
                if exist "__" (*del /q "__">nul)

:Pop_D
        echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 end 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 >nul
        rem echo 🦴 this is the popd section of the very end! %+ rem call pause-for-x-seconds 9
        rem Bring us back one folder level from the folder stack:
                setdos /x0
                REM this got me in trouble: whatever it was fixing needs to be fixed some other way:
                rem if %@DirStack[] gt 0 popd                                    %+ rem If we pushd’ed to another folder, popd back
                rem But unlike in create-srt, we will only do this once, so we won’t do this part: if %@DirStack[] gt 0 goto :Pop_D

                
        echo 🧹🧹🧹🧹🧹🧹 unsetting 🧹🧹🧹🧹🧹🧹🧹 GOTO_END=“%GOTO_END%” >nul
        rem echo 🦴 this is the unsetting of the very end! %+ rem call pause-for-x-seconds 9
        rem Unset various environment variables that we realllllllly want unset:        
                @echo off
                unset /q DO_NOT_ASK_TO_HAND_EDIT WE_GOOGLED TRY_SELECTION_AGAIN COVER_ORIGINAL_ATTEMPT LD1_MASSAGED_ATTEMPT_1 ONLY_ONE_FILE_AND_IT_WAS_TRIED DO_NOT_ASK_TO_HAND_EDIT JUST_APPROVED_LYRICS LYRICS_JUST_DISAPPROVED JUST_GENERATED_LYRICS FORCE_HAND_EDIT GENIUS_ONLY GOOGLE_NOW FORCE_ASK_TO_APPROVE_LYRICLESSNESS
            rem unset /q ALREADY_HAND_EDITED

                rem for LYRIC/LYRICLESSNESS status we want to retain the values if being called to create karaoke——so the karaoke creation process knows they are done
                rem     But otherwise, if we’re just looking for lyrics, then we can unset this value as we don’t need it later and it can mess up multilpe lyric search:
                rem echo 🦴 parent_bat = “%PARENT_BAT%” .. making_karaoke=“%making_karaoke%” %+ rem call pause-for-x-seconds 9
                iff "%PARENT_BAT%" != "create-srt-from-file" then
                    unset /q LYRICLESSNESS_STATUS LYRIC_STATUS                                                  
                endiff
                unset /q ANSWER ABANDONED_SEARCH
            rem unset /q LYRIC_SEARCH_FAILED            //leave this one for auditing
            rem unset /q LYRIC_RETRIEVAL_1_FAILED       //leave this one for auditing
                unset /q LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE  found_broad_lyrics_branch_1 LYRIC_SUCCESS_CELEBRATION_DISPLAYED already_tried_potential_lyrics_* did_not_go_to_end_169 goto_download_with_lyric_downloader_1 FIRST_SEARCH_COMPLETE goto_download_with_lyric* lyric_downloader_initialized JUST_RENAMED_TO_INSTRUMENTAL debanded
                        rem GOTO_END

                rem TODO i think maybe this should not be added: JUST_CONVERTED_LRC_TO_TEXT=0


:final_ending
        @setdos /x0
        rem call status-bar unlock
        rem echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 END GET-LYRICS %* !!!! 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 (pbatchname=%_PBATCHNAME)  {LYRIC_STATUS=“%LYRIC_STATUS”,LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”} >nul
        rem echo 🔚 end of %0 ... pbatchname=%_PBATCHNAME
        rem pause
