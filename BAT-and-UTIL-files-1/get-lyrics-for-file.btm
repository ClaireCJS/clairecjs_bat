@rem DUPLICATE TODO ALSO LISTED BELOW: make lyric postprocessor accept filename input the way subtitle-postprocessor does, then fix
@loadbtm on
@Echo Off
                            
                @rem ——————————————————————————————————————————————————————————————————————————————————————————————— mer@
                @rem ——————————————————————————————————————————————————————————————————————————————————————————————— mer@
                @rem —————————————————————                               ██                   —————————————————————— mer@
                @rem —————————————————————                   █            █                   —————————————————————— mer@
                @rem —————————————————————                   █            █                   —————————————————————— mer@
                @rem —————————————————————    ████   █████  ████          █ ███ ███ ███ ██    —————————————————————— mer@
                @rem —————————————————————   █    █ █     █  █            █  █   █    ██  █   —————————————————————— mer@
                @rem —————————————————————   █    █ ███████  █   ███████  █  █   █    █       —————————————————————— mer@
                @rem —————————————————————   █    █ █        █            █   █ █     █       —————————————————————— mer@
                @rem —————————————————————    █████ █     █  █  █         █   █ █     █       —————————————————————— mer@
                @rem —————————————————————        █  █████    ██        █████  █    █████     —————————————————————— mer@
                @rem —————————————————————        █                            █              —————————————————————— mer@
                @rem —————————————————————     ████                           ██              —————————————————————— mer@
                @rem ——————————————————————————————————————————————————————————————————————————————————————————————— mer@
                @rem ——————————————————————————————————————————————————————————————————————————————————————————————— mer@


rem Basic initialization:
        @setdos /x0
        @*setdos /x-5
        rem @*setdos /c????
        @setdos /x0
        @echos %conceal_off%
        rem on break cancel - removed ... when things go bad sometimes we just want to skip that step so we still go through the motions and run our cleanup. Possible alternate method would be to cause ^Break to send us straight to :END/:Cleanup
        rem rem echo y α linish 27
        rem @call status-bar unlock
        rem rem echo y α linish 29
        @set DONT_MESS_WITH_MY_STATUS_BAR=1
        @set temporarily_disable_status_bar=1
        rem rem echo y α linish 32



rem TODOs/IDEAS:
rem Embedded todos still exist!
rem TODO check if lyric file is approved [somehow--see create-lyrics for ideas]
rem Is this still applicable?
                rem TODO: if cover song search fails, try with *current* artist instead of original artist
                rem       this will also help with songs that AREN’T covers but have composers.
                rem  So we will have to make a using_original flag that says if we flipped from artist to composer, and then if 
                rem the lyrics are rejected and that flag exists, go back to where we started. 
                rem where we started, we look at the using_original flag. 
                rem at this point, we are BEFORE where it was originally set -- very important
                rem if it’s already set, we DON’T bother changing the artist at all! and unset it!.
                rem basically gaslight our script like it never happened. then go on with our life.



rem ━━━━━ DOCUMENTATION: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem *** ADS tags used:
rem * TAG:                     * FILETYPE:  * VALID VALUES:       .........................   * MEANING:
rem   generated                  txt          1, 0                                              1        == these lyrics have been generated and are safe to regenerate over.     0 == not uh
rem   generated_by               txt          lrc2txt, srt2txt, and possible expansion          {Name}   == for lyric files: the utility that generated it
rem   genius_searched_already    audio        True                                              True     == Genius search has already been tried.                             False == not uh
rem   genius_filename            audio        filename                                          string   == Genius download was successfully performed, returning a filename representing the artist and title which may or may not be the correct one
rem   is_instrumental            audio        True                                              True     == This song is an instrumental, do not try to transcribe it again.                                                    False == not uh.
rem   karaoke_failed             audio        True                                              True     == karaoke generation has failed and we should not waste our time trying again.                                        False == not uh
rem   lyriclessness              audio        not_set, approved, not_approved                   approved == This song does not have findable lyrics, so transcribe it using only the AI, without any priming from a lyric file. Not_approved == not uh
rem   lyrics                     txt, srt     not_set, approved, not_approved, does_not_exist   for txt/srt files: The lyrics/subtitles have been approved as correct.  for srt: The karaoke transcription has been double-checked for correctness

goto :skipusage
:sayusage
text
:USAGE: USAGE: <this> {audio_filename} [optional mode]
:USAGE:                                 ^^^^^^^^^^^^^^
:USAGE:                                   \__ mode can be: 
:USAGE:                                           1) "SetVarsOnly" —— to just set the MAYBE_LYRICS_1/2/BROAD_SEARCH environment variables
:USAGE:                                           2)    "force"    —— to get lyrics for songs that are already in an approved-lyricLESSness state
:USAGE:                                           3)    "genius"   —— to ONLY perform the Genius.com/LyricsGenius.exe download
:USAGE: Forms of automation via environment variables:
:USAGE:     set OVERRIDE_FILE_ARTIST_TO_USE=Misfits      //override artist name, especially useful if you want to predownload lyrics for a bunch of tribute/cover albums of a particular band. For example, I have 10 tribute albums for The Misfits that I want to pre-download lyrics for, but I have a hunch the downloader will not find the right lyrics if my original artist tag is missing on any of these files, plus a lot of people who upload lyrics upload without the “The”. And although this script compensates for both those contingencies, setting this can speed things up.
:USAGE:     set CONSIDER_ALL_LYRICS_APPROVED=1           //automatically approves lyrics at first prompt and reduces prompt from %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% to %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO% seconds
:USAGE:     set LYRIC_KARAOKE_ALIGNMENT_THOROUGH_MODE=1  //no automatic timeouts; always waits for user input
endtext
if "%1" == "%goto_end%" goto /i END
:skipusage
rem ━━━━━ DOCUMENTATION ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

:top
rem CONFIG: DEBUG:
        set DEBUG_TOKEN_PROCESSING=0                                                  %+ rem (1) whether we want to display each probe value token as it is processed
        set DEBUG_VALUE_TRANSFER=0                                                    %+ rem (2) whether we want to display the transfer of each probe value token to local environment varial
        set DEBUG_DISPLAY_PROBE_RESULTS=1                                             %+ rem (3) whether we want to display the probe results to the screen for debug purposes

REM CONFIG: 2025: 
        iff not defined LOGS then                                                     %+ rem copy this line to create-srt-from-file as well
                mkdir c:\logs                                                         %+ rem copy this line to create-srt-from-file as well
                set logs=c:\logs                                                      %+ rem copy this line to create-srt-from-file as well
                if not isdir %logs% mkdir %logs%                                      %+ rem copy this line to create-srt-from-file as well
        endiff                                                                        %+ rem copy this line to create-srt-from-file as well
        set AUDIOFILE_TRANSCRIPTION_LOG_FILE=%LOGS%\audiofile-transcription.log       %+ rem copy this line to create-srt-from-file as well
        set AUDIOFILE_TRANSCRIPTION_PROMPTS_USED_LOG_FILE=%LOGS%\audiofile-transcription-prompts.log   %+ rem copy this line to get-lyrics-for-file as well
rem CONFIG: EXTERNAL PROGRAMS:
        set DEFAULT_PLAYER_COMMAND=vlc.exe                                            %+ rem UPDATE THIS IN GET-KARAOKE TOO! ——> program we use to play audio files, i.e. VLCplayer, MPC, etc.
        set PROBER=ffprobe.exe                                                        %+ rem program we use to probe existing tag values for song title, artist, album, etc
        set PLAYER_COMMAND=vlc.exe --volume 200                                       %+ rem Command to run to play files with a media player
        set PLAYER_COMMAND=call preview-audio-file                                    %+ rem Command to run to play files with a media player
        set LYRIC_DOWNLOADER_1=lyricsgenius.exe                                       %+ rem LyricsGenius.exe is a Python package from github —— https://github.com/johnwmillr/LyricsGenius  ... There’s also this website, though I’m not sure if it’s the same thing: https://lyricsgenius.readthedocs.io/en/master/
        SET LYRIC_DOWNLOADER_1_EXPECTED_EXT=JSON                                      %+ rem LyricsGenius.exe downloads files in JSON format. And the output filename isn’t really specifiable, which creates issues. (Solution: Create temp file, run, see if latest file date-wise is the temp file you created or not, if not, then that’s the output file)
        set LYRIC_DOWNLOADER_1_SOURCE=Genius                                          %+ rem Where the LYRIC_DOWNLOADER gets its stuff from — Genius, SongText, etc
        set MOST_BYTES_THAT_LYRICS_COULD_BE=50000                                     %+ rem due to HTML, this is rather useless. Originally thought it was a chracter count of just the lyrics themselves.            
rem CONFIG: LYRIC-GOOGLE’ING BEHAVIOR:                                               
        set AUTOMATIC_HAND_EDITING_IF_GOOGLING=0                                      %+ rem It turns out that it’s annoying to have an empty TXT file opened up, Google and find no lyrics, then have the file be auto-deleted for being 0-bytes, then have the text editor complain that the file you have open no longer exists. It may make more sense to ask for hand editing AFTER googling... If we have results, yes to hand edit so we can paste them in. Otherwise, no.
        set SHOW_UNPROCESSED_LYRICS_ALSO=0                                            %+ rem 1=Show the lyrics we have in their unprocessed state prior to showing them in their processed state. Good for testing lyric-postprocessor.pl but annoying if you’re super impatient during this process
rem CONFIG: BEHAVIOR: LYRIC RETRIEVAL: DEFAULT ANSWERS:                              
        set LYRICLESSNESS_APPROVAL_CURRENT_DEFAULT_ANSWER=no                          %+ rem Default answer for whether to mark songs as lyriclessness ... If we discover a song is an instrumental, we flip this to “yes”
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 𝓽𝓲𝓶𝓮𝓸𝓾𝓽 𝓬𝓸𝓷𝓯𝓲𝓰𝓾𝓻𝓪𝓽𝓲𝓸𝓷 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem CONFIG: WAIT TIMES: DEFAULTS ━━ MAKE SURE ANY NEW ONES GET ADDED TO MODE-DEPENDENT ONES AS WELL, ESPECIALLY THOROUGH MODE:
        SET ADDITIONAL_HAND_EDIT_WAIT_TIME_IF_THEY_GOOGLED=220                        %+ rem Additional wait time to add on to last value in the event that they Googled the lyrics [to give time to check out the google results before the Yes/No prompt expires] ... One can get lost for several minutes searching through the google results, so best to extend this by several minutes....
        set LARGE_DOWNLOAD_WARNING_WAIT_TIME=0                                        %+ rem Wait time after announcing that the lyrics downloaded seemed larger than expected [pretty uselessi n practice]
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=180                                  %+ rem How long to show lyrics on the screen for them to get approval or not —— was 60 but running this while playing games made me miss the prompt so increased to 180
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=1800                                 %+ rem How long to show lyrics on the screen for them to get approval or not —— was 60 but running this while playing games made me miss the prompt so increased to 180
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO=4                               %+ rem How long to show lyrics on the screen for them to get approval or not —— if the environment variable says they are already pre-approved
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_FOR_FORCE_REGEN=10                   %+ rem How long to show lyrics on the screen for them to get approval or not when we are in force-regen mode and probably already did this
        rem LYRIC_SELECT_FROM_FILELIST_WAIT_TIME=30                                   %+ rem how long to get an affirmative response on selecting a file from multilpe files [which can’t be done in automatic mode], before proceeding on 
        set LYRIC_SELECT_FROM_FILELIST_WAIT_TIME=180                                  %+ rem how long to get an affirmative response on selecting a file from multilpe files [which can’t be done in automatic mode], before proceeding on 
        set WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH=0                                   %+ rem How long to wait after displaying the massaged artist/title prior to searching for the (if the 1st search with non-massaged failed). If set to 0, there will be no notice at all
        set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=60                  %+ rem how long to wait for “hand edit these lyrics?”-type questions
        set GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME=25                                     %+ rem how long to pause on “do you want to google the lyrics?”-type questions
        set GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME=250                                    %+ rem how long to pause on “do you want to google the lyrics?”-type questions
        set LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS=800                            %+ rem give us 15 minutes to hand edit in case we get distracted
        set PAUSED_DEBUG_WAIT_TIME=5                                                  %+ rem how long to pause on debug statements we’re particularly focusing on
        SET APPROVE_LYRICLESS_SONGS_WAIT_TIME=18                                      %+ rem how long to pause on the prompt: “Do you want to approve “lyriclessness” status, and officially give up on finding lyrics for this song?”
        set DOWNLOAD_NEW_REPLACEMENT_LYRICS_WAIT_TIME=360                             %+ rem how long to pause on the prompt: “Do you want to download new lyrics to overwrite/replace your existing ones”
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem CONFIG: WAIT TIMES: DEPENDING ON CALLING SCRIPT:
        iff "%PARENT_BAT%" == "get-lyrics" then                              
                SET APPROVE_LYRICLESS_SONGS_WAIT_TIME=5                       %+ rem how long to pause on the prompt: “Do you want to approve “lyriclessness” status, and officially give up on finding lyrics for this song?”
        else                                                                 
                SET APPROVE_LYRICLESS_SONGS_WAIT_TIME=22                      %+ rem how long to pause on the prompt: “Do you want to approve “lyriclessness” status, and officially give up on finding lyrics for this song?”
        endiff        
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem CONFIG: WAIT TIMES: DEPENDING ON ENVIRONMENT-VARIABLE-PARAMETER:
        rem rem echo y α linish 151
        iff "1" == "%CONSIDER_ALL_LYRICS_APPROVED%" then
                set LARGE_DOWNLOAD_WARNING_WAIT_TIME=0                        %+ rem Wait time after announcing that the lyrics downloaded seemed larger than expected [pretty uselessi n practice]
                set LYRIC_SELECT_FROM_FILELIST_WAIT_TIME=3                    %+ rem how long to get an affirmative response on selecting a file from multilpe files [which can’t be done in automatic mode], before proceeding on 
                set WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH=0                   %+ rem How long to wait after displaying the massaged artist/title prior to searching for the (if the 1st search with non-massaged failed)
                set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=2   %+ rem how long to wait for “hand edit these lyrics?”-type questions
                set GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME=1                      %+ rem how long to pause on “do you want to google the lyrics?”-type questions
                SET ADDITIONAL_HAND_EDIT_WAIT_TIME_IF_THEY_GOOGLED=1          %+ rem Additional wait time to add on to last value in the event that they Googled the lyrics [to give time to check out the google resuls before the Yes/No prompt expires]
        endiff
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem CONFIG: WAIT TIMES: MODE-DEPENDENT: THOROUGH MODE: basically a copy of the default values, but with almost everyting set to “0”:
        iff "1" == "%LYRIC_KARAOKE_ALIGNMENT_THOROUGH_MODE%" then                     
        echo %@cool[%@CURSIVE_PLAIN[thorough mode is set!!!!]]
        SET ADDITIONAL_HAND_EDIT_WAIT_TIME_IF_THEY_GOOGLED=0                          %+ rem Additional wait time to add on to last value in the event that they Googled the lyrics [to give time to check out the google results before the Yes/No prompt expires] ... One can get lost for several minutes searching through the google results, so best to extend this by several minutes....
        set LARGE_DOWNLOAD_WARNING_WAIT_TIME=0                                        %+ rem Wait time after announcing that the lyrics downloaded seemed larger than expected [pretty uselessi n practice]
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=0                                    %+ rem How long to show lyrics on the screen for them to get approval or not —— was 60 but running this while playing games made me miss the prompt so increased to 180
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO=0                               %+ rem How long to show lyrics on the screen for them to get approval or not —— if the environment variable says they are already pre-approved
        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_FOR_FORCE_REGEN=0                    %+ rem How long to show lyrics on the screen for them to get approval or not when we are in force-regen mode and probably already did this
        set LYRIC_SELECT_FROM_FILELIST_WAIT_TIME=0                                    %+ rem how long to get an affirmative response on selecting a file from multilpe files [which can’t be done in automatic mode], before proceeding on 
        set WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH=0                                   %+ rem How long to wait after displaying the massaged artist/title prior to searching for the (if the 1st search with non-massaged failed). If set to 0, there will be no notice at all
        set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=0                   %+ rem how long to wait for “hand edit these lyrics?”-type questions
        set GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME=0                                      %+ rem how long to pause on “do you want to google the lyrics?”-type questions
        set LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS=0                              %+ rem give us 15 minutes to hand edit in case we get distracted
        set PAUSED_DEBUG_WAIT_TIME=30                                                 %+ rem how long to pause on debug statements we’re particularly focusing on
        SET APPROVE_LYRICLESS_SONGS_WAIT_TIME=0                                       %+ rem how long to pause on the prompt: “Do you want to approve “lyriclessness” status, and officially give up on finding lyrics for this song?”
        set DOWNLOAD_NEW_REPLACEMENT_LYRICS_WAIT_TIME=0                               %+ rem how long to pause on the prompt: “Do you want to download new lyrics to overwrite/replace your existing ones”
        endiff                                              
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 𝓽𝓲𝓶𝓮𝓸𝓾𝓽 𝓬𝓸𝓷𝓯𝓲𝓰𝓾𝓻𝓪𝓽𝓲𝓸𝓷 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━



rem ——————————————————————————————————————————————————————————————————————————————————————————

rem USAGE:
        rem rem echo y α linish 87
        iff "%1" == "" then
                echo.
                gosub divider
                set goto_end=1
                goto sayusage
                gosub divider
                goto /i END
        endiff

rem For testing the “divider” subroutine:      
        iff "%1" == "divider" then
                gosub divider
                goto /i END
        endiff


rem SETUP: GRAB CALLING BAT FILE NAME, IF ANY:
        set PARENT_BAT=%@NAME[%_PBATCHNAME] %+ rem the calling BAT filename without path or extension i.e. “whatever” as opposed to “c:\bat\whatever.bat”
        set currently_getting_lyrics=1

rem DEBUG: 
        rem call bigecho CONSIDER_ALL_LYRICS_APPROVED is %CONSIDER_ALL_LYRICS_APPROVED% 
        rem set SKIP_MANUAL_SELECTION=1 to skip the manual select part

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Remove any trash environment variables left over from a previously-aborted run which might interfere with the current run:
        rem rem echo y α linish 151
        rem unset /q LYRIC_RETRIEVAL_1_FAILED
        unset /q LD1_MASSAGED_ATTEMPT_1 WE_GOOGLED TRY_SELECTION_AGAIN ONLY_ONE_FILE_AND_IT_WAS_TRIED cover_original_attempt DO_NOT_ASK_TO_HAND_EDIT ALREADY_HAND_EDITED already_searched_for* GOOGLE_NOW ANSWER goto_download_with_lyric_downloader_1 goto_download_with_lyric DO_NOT_ASK_TO_HAND_EDIT PREV_GENIUS_FNAME_2_USE
        unset /q logged_lyricapproval_*
        set FORCE_ASK_TO_APPROVE_LYRICLESSNESS=0
        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 1 >nul 
        set FORCE_HAND_EDIT=0
        set LYRICS_JUST_DISAPPROVED=0
        set JUST_APPROVED_LYRICLESSNESS=0
        set JUST_APPROVED_LYRICS=0
        set FORCE_REGEN=0                                                       %+ rem If we set it as 1 in get-karaoke, we need to pass it explicitly to this one rather than inherit it. Too messy in practice.
        set LYRICS_ACCEPTABLE=0
        set JUST_GENERATED_LYRICS=0
        set JUST_CONVERTED_LRC_TO_TEXT=0
        set JUST_CONVERTED_SRT_TO_TEXT=0

        set JUST_RENAMED_TO_INSTRUMENTAL=0
        set FORCE_AI_ENCODE_FROM_LYRIC_GET=0
        set GOTO_END_AFTER_GET_LYRICS_CALLED=0
        set  found_broad_lyrics_branch_1=0
        rem set LYRIC_SUCCESS_CELEBRATION_DISPLAYED=0 %+ rem we changed this from a 0/1 flag to a “1_%audio_file%” flag
        set debanded=0
        unset /q LYRIC_SEARCH_FAILED GENIUS_ONLY ABANDONED_SEARCH LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE GOTO_END did_not_go_to_end_169 lyric_downloader_initialized player_command_to_use LAST_ALIGNMENT_TEMP_INDEX rejected_original_lyrics JUST_CONVERTED_FROM
        rem Leave this one for when we are calling get-lyrics from create-karaoke: unset /q LYRIC_STATUS
        rem Leave this one for when we are calling get-lyrics from create-karaoke: unset /q LYRICLESSNESS_STATUS
        set goto_END=0
        set TMPREVIEWFILE=%temp%\review-file.%_datetime.%_PID.txt               %+ rem Temp file we sometimes use to hold files-to-review to be reviewed in


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Force mode?
        rem rem echo y α linish 172
        set FORCE_REDOWNLOAD=0
        if "%1" == "force" (
                set FORCE_REDOWNLOAD=1 
                shift
        ) else (
                if "%1" == "force" .or.  "%2" == "force" .or.  "%3" == "force" .or.  "%4" == "force" .or.  "%5" == "force" (
                        set FORCE_REDOWNLOAD=1 
                )
        )
        if "1" == "%FORCE_REDOWNLOAD%" (
                unset /q last*
                unset /q already*
        )       
        rem echo FORCE_REDOWNLOAD is “%FORCE_REDOWNLOAD%”         %+ pause
     
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem VALIDATE ENVIRONMENT [once per session]:
        rem rem echo y α linish 189
        iff "2" != "%VALIDATED_GLVMS_ENV%" then
                call validate-in-path              %LYRIC_DOWNLOADER_1% %PROBER% %PLAYER_COMMAND% delete-zero-byte-files get-lyrics-with-lyricsgenius-json-processor.pl tail echos  divider unimportant success alarm unimportant debug warning error fatal_error advice  important important_less celebrate eset eset.bat eset-alias.bat insert-before-each-line.pl insert-before-each-line.py pause-alias google.bat google.py google.pl insert-before-each-line.py newspaper.bat print_with_columns.py print-with-columns.bat newspaper.bat srt2lrc.py change-single-quotes-to-double-apostrophes.py add-ADS-tag-to-file.bat remove-ADS-tag-from-file.bat display-ADS-tag-from-file.bat display-ADS-tag-from-file.bat approve-lyrics.bat disapprove-lyrics.bat display-lyric-status-for-file.bat review-lyrics.bat review-files.bat approve-lyric-file.bat disapprove-lyric-file.bat approve-subtitle-file.bat disapprove-subtitle-file.bat get-lyric-status.bat approve-LYRICLESSNESS-for-file.bat disapprove-lyriclessness-for-file.bat unapprove-lyriclessness-for-file.bat cut.exe srt2txt.py lrc2txt.py rn.bat 
                rem  call unimportant               "Validated: lyric downloader, audio file prober"
                call validate-environment-variables BAT TEMP LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME LYRIC_SELECT_FROM_FILELIST_WAIT_TIME cool_question_mark ANSI_COLOR_BRIGHT_RED italics_on italics_off ANSI_COLOR_BRIGHT_YELLOW blink_on blink_off star ANSI_COLOR_GREEN ANSI_GREEN ansi_color_bright_green ansi_reset bright_on bright_off   underline_on underline_off    emoji_warning check EMOJI_MAGNIFYING_GLASS_TILTED_RIGHT EMOJI_red_QUESTION_MARK LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS ANSI_COLOR_WARNING_SOFT LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO ANSI_COLOR_DEBUG ansi_color_prompt ansi_color_orange CONNECTING_EQUALS connecting_minus bold_on bold_off italics_on italics_off blink_on blink_off ansi_colors_have_been_set LQ RQ EMOJI_DESKTOP_COMPUTER EMOJI_EAR CHECK NO EMOJI_AXE ansi_color_pink color_removal ansi_color_removal color_normal smart_apostrophe glitch_star star1 star2 star3 star4 star5 star6 star7 star8 star9 conceal_on conceal_off
                if not defined filemask_audio call validate-environment-variable filemask_audio skip_validation_existence
                call validate-functions             cool_text rainbow_string ansi_rgb
                call validate-plugin                StripANSI
                call checkeditor
                rem Default values to help portability:
                        if not defined ESCAPE                                        set                                            ESCAPE=%@CHAR[27]
                        if not defined ANSI_ESCAPE                                   set                                       ANSI_ESCAPE=%ESCAPE%[
                        if not defined ANSI_CURSOR_CHANGE_TO_DEFAULT                 set        ANSI_CURSOR_CHANGE_TO_DEFAULT=%ANSI_ESCAPE%0 q
                        if not defined ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING          set ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING=%ANSI_ESCAPE%1 q
                        if not defined ANSI_CURSOR_CHANGE_TO_BLOCK_STEADY            set ANSI_CURSOR_CHANGE_TO_BLOCK_STEADY=%ANSI_ESCAPE%2 q
                        if not defined ANSI_CURSOR_CHANGE_TO_UNDERLINE_BLINKING      set ANSI_CURSOR_CHANGE_TO_UNDERLINE_BLINKING=%ansi_escape%3 q
                        if not defined ANSI_CURSOR_CHANGE_TO_UNDERLINE_STEADY        set ANSI_CURSOR_CHANGE_TO_UNDERLINE_STEADY=%ansi_escape%4 q
                        if not defined ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_BLINKING   set ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_BLINKING=%ansi_escape%5 q
                        if not defined ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_STEADY     set ANSI_CURSOR_CHANGE_TO_VERTICAL_BAR_STEADY=%ansi_escape%6 q
                        rem TODO: ansi_color_yellow, bold on, bold off
                        if "%@ANSI_CURSOR_CHANGE_COLOR_WORD[]" == ""            function ANSI_CURSOR_CHANGE_COLOR_WORD=`%@char[27][ q%@char[27]]12;%1%@char[7]`                                
                        if not defined FILEMASK_AUDIO                                set FILEMASK_AUDIO=*.mp3;*.wav;*.rm;*.voc;*.au;*.mid;*.stm;*.mod;*.vqf;*.ogg;*.mpc;*.wma;*.mp4;*.flac;*.snd;*.aac;*.opus;*.ac3;*.dtshd
                set  VALIDATED_GLVMS_ENV=2
        endiff

        if not defined TRANSCRIBER_VALID_EXTENSIONS gosub "%BAT%\create-srt-from-file.bat" set_TRANSCRIBER_VALID_EXTENSIONS_AND_LOCK_FILE_NAME

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem VALIDATE PARAMETERS [every time]:
        rem rem echo y α linish 216
        *setdos /x-4
        set  AUDIO_FILE=%@UNQUOTE["%1"]
        set  LRC_SIDECAR_FILENAME=%@NAME[%AUDIO_FILE].lrc
        set  SRT_SIDECAR_FILENAME=%@NAME[%AUDIO_FILE].srt
        set  TXT_SIDECAR_FILENAME=%@NAME[%AUDIO_FILE].txt
        set            LYRIC_FILE=%@NAME[%AUDIO_FILE].txt
        setdos /x0


        :process_audiofile_parameter_again
        rem rem echo y α linish 226
        *setdos /x-4
        set  AUDIO_FILE_FULL=%@UNQUOTE[%@FULL["%AUDIO_FILE%"]]
        set  AUDIO_FILE_BASE=%@UNQUOTE[%@NAME["%AUDIO_FILE%"]]
        set  AUDIO_FILE_NAME=%@UNQUOTE[%@NAME["%AUDIO_FILE%"]]
        set  AUDIO_FILE_EXT=%@UNQUOTE[%@EXT["%AUDIO_FILE%"]]
        setdos /x0


        rem Make sure it’s a transcribeable filename:
                gosub "%BAT%\create-srt-from-file.bat" validate_transcribeable_filename "%AUDIO_FILE%" "getting lyrics"
                set retval=%_?
                if "%_?" == "666" .or. "%retval%" == "666" .or. "1" == "%goto_end%" (
                        echo Aborting...
                        goto /i final_ending
                )



        rem Audio file extension correction for invocation mistakes (i.e. calling this on the JSON instead of the MP3/FLAC):
                iff     "%AUDIO_FILE_EXT%" == "json" then                                                                  %+ rem If we invoked a JSON accidentally:
                        set audio_file=%audio_file_base%.flac                                                              %+ rem   Try it with FLAC instead
                        set oops_was_json=1                                                                                %+ rem   And remember we tried...
                        goto /i :process_audiofile_parameter_again                                                         %+ rem   And go try again
                elseiff "%AUDIO_FILE_EXT%" == "flac" .and. not exist "%AUDIO_FILE%" .and. "1" == "%oops_was_json%" then    %+ rem If it was a JSON and the FLAC we tried failed:
                        set audio_file=%audio_file_base%.mp3                                                               %+ rem   Try it with mp3 instead
                        set oops_was_json=0                                                                                %+ rem   but don’t try it ever again
                        goto /i :process_audiofile_parameter_again                                                         %+ rem   ...Now Go try again!
                endiff


        rem Now see if it exists....
                if not exist "%AUDIO_FILE%"  call validate-environment-variable AUDIO_FILE "1ˢᵗ parameter to get-lyrics-for-file must be an audio file that exists! [PBATCHNAME=%@UNQUOTE["%_PBATCHNAME"]] [full command line=“%@UNQUOTE["%0"] %@UNQUOTE["%*"]”]"

        rem Get the folder that the song is in:
                *setdos /x-4
                rem SONG_DIR=%@UNQUOTE[%@PATH["%AUDIO_FILE%"]]
                set SONG_DIR=%@UNQUOTE["%@PATH["%@UNQUOTE["%@FULL["%AUDIO_FILE%"]"]"]"]
                setdos /x0

        rem Validate the extension of the audio file:
                call validate-file-extension "%AUDIO_FILE%" %FILEMASK_AUDIO%


        rem Debug info:
                iff "False" == "True" then
                        echo        CWD                   is %_CWD
                        echo        AUDIO_FILE            is %AUDIO_FILE%
                        echo        AUDIO_FILE_FULL       is %AUDIO_FILE_FULL%
                        echo        @PATH["%AUDIO_FILE%"] is %@PATH["%AUDIO_FILE%"]
                        echo        if "%_CWD\" != "%SONG_DIR%"   pushd "%SONG_DIR%"
                        pause
                endiff

        if "%_CWD\" != "%SONG_DIR%"   pushd "%SONG_DIR%"

        rem Determine if GENIUS-ONLY get-lyric run, set GENIUS_ONLY appropriately:
                rem rem echo y α linish 271
                iff "%2" == "genius" .or. "%3" == "genius" .or. "%4" == "genius" .or. "%5" == "genius" then
                        set genius_only=1
                        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=8
                else
                        set genius_only=0
                endiff

        rem Chedk for “force” option which may only have been provided this BAT when directly called (it’s often set in get-karaoke.bat)
                if "%1" == "force" .or. "%2" == "force" .or. "%3" == "force" .or. "%4" == "force" .or. "%5" == "force" .or. "%6" == "force" (set force_regen=1 %+ goto :done_skip_if_already_approved_lyriclessness)

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

:begin_checking_if_this_is_one_we_should_process_or_not

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


rem Old/redundant way that should no longer apply at this point:
        rem echo [AA-D] get-lyrics: INITIAL lyric status ===== “%LYRIC_STATUS%”, INITIAL lyriclessness status ===== “%LYRICLESSNESS_STATUS%”
        rem rem echo y α linish 281
        iff 1 eq %@RegEx[\\CHIPTUNES\\,"%@UPPER[%@FULL["%AUDIO_FILE%"]]"] .or. 1 eq %@RegEx[[\[\(]CHIPTUNES?[\]\)],"%@UPPER[%@FULL["%AUDIO_FILE%"]]"] then
                gosub divider
                rem echo.
                call bigecho "%ansi_color_warning_soft%%emoji_warning% Chiptune encountered!%ansi_color_normal% %emoji_warning%"
                echo %ANSI_COLOR_WARNING%%emoji_warning% This is a chiptunes track! %emoji_warning%%ansi_color_normal% %ansi_color_bright_yellow%%connecting_minus%%connecting_minus% %ansi_color_yellow%%audio_file%%ansi_color_normal%
                set FORCE_ASK_TO_APPROVE_LYRICLESSNESS=1
                set LYRICLESSNESS_APPROVAL_CURRENT_DEFAULT_ANSWER=yes
                rem controversial: just skip over chiptunes:
                goto /i END
                rem goto /i ask_to_approve_lyriclessness
        endiff
        iff 1 eq %@RegEx[INSTRUMENTAL,"%@UPPER["%AUDIO_FILE%"]"] then
                gosub divider
                rem echo.
                call bigecho "%ansi_color_warning_soft%%emoji_warning% Instrumental encountered!%ansi_color_normal% %emoji_warning%"
                echo %ANSI_COLOR_WARNING%%emoji_warning% This is an instrumental track! %emoji_warning%%ansi_color_normal% %ansi_color_bright_yellow%%connecting_minus%%connecting_minus% %ansi_color_yellow%%audio_file%%ansi_color_normal%
                set FORCE_ASK_TO_APPROVE_LYRICLESSNESS=1
                set LYRICLESSNESS_APPROVAL_CURRENT_DEFAULT_ANSWER=yes
                goto /i ask_to_approve_lyriclessness
        endiff


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Skip if already an approved-for-lyricLESSness song....
        rem set LYRICLESSNESS=%@ExecStr[TYPE "%@UNQUOTE["%AUDIO_FILE%"]:lyriclessness" >&>nul]   %+ rem Read lyriclessness status        
        rem ^^^^^ moved to beginning of file: call get-lyriclessness-status "%AUDIO_FILE%"
        rem  call get-lyriclessness-status "%AUDIO_FILE%" 🐐1 status=%RECEIVED_VALUE / %LYRICLESSNESS_STATUS
        rem echo %ansi_color_subtle%* LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, FORCE_REGEN=“%FORCE_REGEN%” , audio_file=“%audio_file%” %ansi_color_normal% %conceal_on%%conseal_off%
        rem echo  [EL-A] get-lyrics: INITIAL lyric status ===== “%LYRIC_STATUS%” .... LYRICLESSNESS_STATUS ==== “%LYRICLESSNESS_STATUS%” ............... FORCE_REDOWNLOAD=“%FORCE_REDOWNLOAD%”  ............. %%1=“%1” %%2=“%2”

        rem rem echo y α linish 300
        if "%LYRICLESSNESS_STATUS%"  == "APPROVED" goto done_skip_if_already_approved_lyriclessness                                                                                                                                                               
        if "%FORCE_REDOWNLOAD%"      ==   "1"      goto done_skip_if_already_approved_lyriclessness
        if "%1" == "force" .or. "%2" == "force"    goto done_skip_if_already_approved_lyriclessness
        if "%3" == "force" .or. "%4" == "force"    goto done_skip_if_already_approved_lyriclessness
        if "%5" == "force" .or. "%6" == "force"    goto done_skip_if_already_approved_lyriclessness
                                                   goto done_skip_if_already_approved_lyriclessness

                        rem if "" == "%LYRICLESSNESS_STATUS%" set LYRICLESSNESS_STATUS=APPROVED
                        :do_it_9024398042890234
                        rem not sure about this blank: echo.
                        gosub divider
                        echo %ansi_color_bright_yellow%%star% File already marked as lyric%underline_on%less%underline_off%. %italics_on%Not%italics_off% fetching lyrics.
                        echo %ansi_color_bright_white%%star% %faint_on%Filename: %italics_on%%AUDIO_FILE%%italics_off% %faint_off%
                        echo %ansi_color_advice%%@CHAR[55357]%@CHAR[56393] Add the “%bold_on%force%bold_off%” parameter to skip this check %@CHAR[55357]%@CHAR[56392]
                        gosub divider
                        iff "1" == "%FORCE_REDOWNLOAD%" then
                                echo %ansi_color_bright_yellow%%star% Forcing because you said so!%ansi_color_normal%
                                goto /i :done_skip_if_already_approved_lyriclessness
                        endiff
                        goto :END                                                    %+ pause "this shouldn’t happen!"

        :done_skip_if_already_approved_lyriclessness

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━     WRONG EXTENSION?

rem Skip if extension that can’t have lyrics:
        rem echo  [FL-A] get-lyrics: INITIAL lyric status ===== “%LYRIC_STATUS%” .... LYRICLESSNESS_STATUS ==== “%LYRICLESSNESS_STATUS%” ............... FORCE_REDOWNLOAD=“%FORCE_REDOWNLOAD%”  ............. %%1=“%1” %%2=“%2”
        rem rem echo y α linish 328
        iff "%AUDIO_FILE_EXT%" == "cmf" .or. "%AUDIO_FILE_EXT%" == "stm" .or. "%AUDIO_FILE_EXT%" == "s3m" .or. "%AUDIO_FILE_EXT%" == "mid" .or. "%AUDIO_FILE_EXT%" == "midi" then
                gosub divider
                echo %ANSI_COLOR_LESS_IMPORTANT%%EMOJI_WARNING% Files of extension “%italics_on%%AUDIO_FILE_EXT%%italics_off%” cannot have lyrics!%ANSI_COLOR_NORMAL%
                call approve-lyriclessness "%AUDIO_FILE%"
                set  JUST_APPROVED_LYRICLESSNESS=1
                set  LYRICLESSNESS_STATUS=APPROVED        
                goto /i :END
        endiff


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━     ALREADY LYRICS?


rem Check if the lyrics are already approved...
        rem rem echo y α linish 432
        rem echo 🐐 [GL-A] INITIAL lyric         status ===== “%LYRIC_STATUS%”
        if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status
        rem echo 🐐 [GL-Z] INITIAL lyric         status ===== “%LYRIC_STATUS%” ... force_regen=“%force_regen%”
        iff     "%LYRIC_STATUS%" == "APPROVED" .and. "1" == "%FORCE_REGEN%" then
                ren /q "%LYRIC_FILE%" "%LYRIC_FILE%.removed_via_force_parameter.%[_datetime].bak"
                set LYRIC_STATUS=NOT_SET
                set LYRICLESSNESS_STATUS=NOT_SET
                goto /i :from_goto_459                
        elseiff "%LYRIC_STATUS%" == "APPROVED" .and. "1" != "%FORCE_REGEN%" then
                gosub divider
                rem echo Tracer we're here in approval-land right? [1]
                echo %ANSI_COLOR_WARNING%%EMOJI_CAUTION% Lyrics already approved: %faint_on%%LYRIC_FILE%%faint_off% %ansi_color_normal%``
                rem echo Tracer we're here in approval-land right? [2]
                iff "1" == "%FORCE_REGEN%" then
                        call sleep 1
                        rem echo hi goto_end==%lq%%goto_end%%rq%
                else
                        goto /i END
                        set goto_end=1
                endiff
        endiff

        gosub "%BAT%\create-srt-from-file.bat" refresh_lyriclessness_status
        rem echo [GM]   INITIAL lyriclessness status ===== “%LYRICLESSNESS_STATUS%”
        if "%LYRICLESSNESS_STATUS%" != "APPROVED" goto :not_lyricless
                echo %ANSI_COLOR_WARNING_SOFT%%blink_on%%STAR2%%blink_off% Already marked %italics_on%lyric%underscore_on%less%underscore_off%%italics_off%!%ansi_color_normal% [force_regen=%force_regen%]
                if "1" != "%FORCE_REGEN%" .and. "%1" !=  "force" .and. "%2" != "force" .and. "%3" !=  "force" .and. "1" != "%did_not_go_to_end_169%" goto :END
                        rem so at this point it wwas marked lyricless, but we’re also forcing. So we should potentially check the lyrics first, and not force a download over it.
                        set did_not_go_to_end_169=1
                        call AskYN "Unmark them as lyric%underline_on%less%underline_off%"
                                if  "Y" == "%ANSWER%" call unapprove-lyriclessness "%AUDIO_FILE%’
                                iff "Y" == "%ANSWER%" then
                                        set LYRICLESSNESS_STATUS=NOT_APPROVED
                                        set  JUST_APPROVED_LYRICLESSNESS=0
                                        rem At this point we need to kind of start over?
                                        begin_checking_if_this_is_one_we_should_process_or_not
                                endiff
        :not_lyricless

rem Delete lyrics if they are zero bytes...
        if 0 eq %@FILESIZE["%LYRIC_FILE%"] (
                call warning "Deleting 0-byte lyric file: %faint_on%%LYRIC_FILE%%faint_off%" silent
                echo ray | *del /Ns /q "%LYRIC_FILE%"
                goto :top
        )

rem Catch our breath
        if "1" == "%goto_end%"      goto :END
        if not exist "%LYRIC_FILE%" goto :start_lyric_download_process
        rem call get-lyric-status "%LYRIC_FILE%" silent
        if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status

rem Skip if the lyrics are already approved:
    rem iff "%LYRIC_STATUS%" == "APPROVED"                             then
        rem rem echo y α linish 378
        iff "%LYRIC_STATUS%" == "APPROVED" .and. "%2" != "SetVarsOnly" .and. "1" != "%FORCE_REGEN%" then
                call success "Lyrics already approved for “%italics_on%%@name[%audio_file%]%italics_off%”!"
                if not defined EDIT_KARAOKE_AFTER_CREATION_WAIT_TIME set EDIT_KARAOKE_AFTER_CREATION_WAIT_TIME=%LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS% 
                set GOTO_END=1
                goto /i END
                rem echo going to end [2q4] goto_end=“%GOTO_END%”
        endiff
        if "1" == "%goto_end%" goto :END
        :from_goto_459          

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━     GENIUS-ONLY 

rem If we are in Genius-download-only mode, skip if we’ve already tried it for this song:
        rem y α linish 389
        iff "1" == "%GENIUS_ONLY%" then
                set GENIUS_SEARCHED_ALREADY=%@ExecStr[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already" >&>nul]`` 
                rem set GENIUS_SEARCHED_ALREADY=0 %+ rem FORCING A REDO OF OLD SEARCHES... LEAVE THIS OFF UNTIL PROJECT IS MORE COMPLETE.. LONGTERM  🐐

                rem echo what about: %@ExecStr[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"]`` 
                rem echo  Trying this: type `<`"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"
                rem echos Trying this: type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"
                rem type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"
                rem echo hmm %@EXECSTR[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"]
                rem set hmm1=%@EXECSTR[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already"]
                set hmm2=%@EXECSTR[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_searched_already" >&>nul]
                rem echo hmm1? %hmm1
                rem echo hmm2? %hmm2
                echo.

                rem TODO fix this ’hmm2’ name stuff

                rem echo GENIUS_SEARCHED_ALREADY is “%GENIUS_SEARCHED_ALREADY%” for “%audio_file%”  🐻
                iff "%hmm2%" == "True" then
                        gosub divider
                        rem echo displayaudiofilename 01
                        gosub DisplayAudioFileName
                        echo %star% %conceal_off%%ansi_color_bright_yellow%Already searched this file in genius-only mode. Skipping.%ansi_color_reset%
                        goto /i :END
                endiff
        endiff


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━     WARN TXT FILE EXISTS

rem Check if we already have a TXT file in the same folder and shouldn’t even be running this:
        rem y α linish 419
        iff exist "%LYRIC_FILE%" .and. %@FILESIZE["%LYRIC_FILE%"] gt 0 then

                rem Warn that lyrics already exist:
                        rem echos  ``
                        iff "1" != "%JUST_GENERATED_LYRICS" then
                                gosub divider
                                if "%LYRICLESSNESS_STATUS%" == "" call get-lyriclessness-status "%AUDIO_FILE%"
                                if "%LYRIC_STATUS%"         == "" call get-lyric-status         "%LYRIC_FILE%"

                                set NOT_APPROVED_STR=%ansi_color_red%NOT_APPROVED
                                echo %ansi_color_warning_soft%%star2% Current folder:            %ansi_color_bright_green%“%ansi_color_warning_soft%%faint_on%%[_CWP]%faint_off%%ansi_color_bright_green%”
                                echo %ansi_color_warning_soft%%star2% Lyrics already exist for:  “%emphasis%%AUDIO_FILE%%deemphasis%%ansi_color_bright_green%”
                                echo %ansi_color_warning_soft%%star2% Lyrics approval status:    “%emphasis%%@IF["" !=         "%LYRIC_STATUS%",%LYRIC_STATUS%,%NOT_APPROVED_STR%]%deemphasis%%ansi_color_bright_green%”
                                echo %ansi_color_warning_soft%%star2% Lyricless approval status: “%emphasis%%@IF["" != "%LYRICLESSNESS_STATUS%",%LYRICLESSNESS_STATUS%,%NOT_APPROVED_STR%]%deemphasis%%ansi_color_bright_green%”%ansi_color_normal%
                        endiff

                rem If we’re in “Genius” mode—which is for unattended mass/batch 1ˢᵗ-pass Genius downloads, 
                rem then abort. We don’t want unattended lyric-overwrites. Those are for when we are at the keyboard.
                rem This mode is for when we are asleep/unattended
                        if 1 eq %GENIUS_ONLY% goto :END





rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
:start_lyric_download_process
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━        SET-VARS-ONLY MODE:

rem Let user know what we’re about to do!
iff "%2" != "SetVarsOnly" then

        rem 2024/12/24: not sure that i want this now? it may depend on pbatchname tbh: call  divider
        echos %ANSI_RESET%
        iff "%@UNQUOTE[%PARENT_BAT%]" != "" then
                rem echo PBATCHNAME=“%_PBATCHNAME”
                gosub divider
        endiff
        *setdos /x-4
        rem  bigecho "%STAR% Getting lyrics for “%@ansi_rgb[170,170,244]%italics_on%%audio_file%%italics_off%%ansi_color_normal%”"
        rem  ^^^^^^^^ decided to expand this into 2 lines to reduce line-wrap errors
        set quote_color=%ansi_color_bright_green%

        iff "%LYRICLESSNESS_STATUS%" == "APPROVED" .and. "1" != "%force_regen%" then
                call warning "is this the infinite loop?!?!?!"
                goto /i :END
        endiff

        set                         VERB=Getting                                               
        if   exist "%LYRIC_FILE%" set VERB=Aligning
        call bigecho "%STAR% %ansi_color_magenta%%VERB% lyrics for: %quote_color%“%@ansi_rgb[170,170,244]%italics_on%%ansi_color_yellow%%@NAME[%audio_file%]%italics_off%%quote_color%”%ansi_color_normal%"
        set  folder_value=%@PATH[%audio_file%]
        if "%folder_value%" == "" set  folder_value=%_CWP
        if "%folder_value%" != "" call bigecho "%STAR% %ansi_color_magenta%in: %quote_color%“%@ansi_rgb[170,170,244]%italics_on%%ansi_color_yellow%%folder_value%%italics_off%%quote_color%”%ansi_color_normal%"
        if "1" != "%DONT_MESS_WITH_MY_STATUS_BAR%" call status-bar "%VERB% lyrics for: %@NAME[%audio_file%]"
        setdos /x0
        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[bright cyan]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%

endiff

rem DEBUG: echo pbatchname = %_PBATCHNAME  %+ pause
                      

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━        PROBE FILE:


rem Get artist and song so we can use them to download lyrics:
        :start_probing
        if %DEBUG_VALUE_TRANSFER% gt 0 call unimportant "Probing file..."

        rem if "%LYRICLESSNESS_STATUS%" == "" call get-lyriclessness-status "%AUDIO_FILE%"
        if "%LYRICLESSNESS_STATUS%" == "" .and. exist "%@UNQUOTE["%AUDIO_FILE%"]" set LYRICLESSNESS_STATUS=%@EXECSTR[type <"%@unquote["%AUDIO_FILE%"]:lyriclessness" >&>nul]``
        rem echo 🦯 start_probing .. LYRICLESSNESS_STATUS is “%LYRICLESSNESS_STATUS%”

        rem if "%LYRICLESSNESS_STATUS%" == "APPROVED"

        goto :probe_faster
        
        
                :probe_slower
                timer /5 on >nul
                set       FILE_ALBUM=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=album  -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set      FILE_ARTIST=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=artist -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set        FILE_SONG=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=title  -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set FILE_ORIG_ARTIST=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=TOPE   -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py]
                set PROBED_FILE_ALBUM=%PROBED_FILE_ALBUM%
                set PROBED_FILE_ARTIST=%FILE_ARTIST%
                set PROBED_FILE_SONG=%FILE_SONG%
                set PROBED_FILE_ORIG_ARTIST=%FILE_ORIG_ARTIST%
                echos %ansi_color_yellow%
                timer /5 off %+ rem 0.946-.948
                :probe_slower_end
                
                
                

        :probe_faster
                rem timer /5 on >nul
                
                rem Handle undefined variables
                        set "probe_tit="
                        set "probe_art="
                        set "probe_alb="
                        set "probe_tpe="
                        set "probe_hmm="
                                                
                rem Skip if we already probed the file (for instance, in the outer-layer/LRC-creator):
                        set already_probed=0
                        iff "%last_file_probed%" == "%AUDIO_FILE%" .and. defined probe_output .and. "" != "%PROBE_OUTPUT%" then
                                if %DEBUG_VALUE_TRANSFER gt 0 (echo Skipping probe because we already probed %audio_file%)
                                goto /i :already_probed
                        endiff
                        
                rem Clear any previous leftover probe values:
                        set       FILE_ALBUM=
                        set      FILE_ARTIST=
                        set        FILE_SONG=
                        set FILE_ORIG_ARTIST=
                        
                rem Probe the file:                        
                        set delimeter_ascii=14

                        set PROBE_COMMAND=%PROBER% -v quiet -show_entries format_tags=title,artist,album,TOPE,composer -of compact=p=0:nk=0:s="%@CHAR[%delimeter_ascii%]"  "%AUDIO_FILE%"
                        if %DEBUG_VALUE_TRANSFER% gt 0 (echo %ansi_color_debug%%star9% argh: PROBE_COMMAND=“%PROBE_COMMAND%”)
                        unset /q probe_output        

                        rem echo %ansi_color_debug%- DEBUG [aaa]: [about to set probe output] [goat] probe_command=“%probe_command” 👾GOAT %ansi_color_normal%

                        call set-tmp-file "probed_results"
                        set tmpfile=%tmpfile%.txt

                        rem echo %ansi_color_debug%- DEBUG [ccc]: old command was: rem (set probe_output=`%`@execstr[%PROBE_COMMAND% `|`:u8 change-single-quotes-to-double-apostrophes.py])%ansi_color_normal%

                        (%PROBE_COMMAND% |:u8 change-single-quotes-to-double-apostrophes.py) >:u8 %tmpfile%

                        *setdos /x-5 %+ rem otherwise if the probe data has “&&” in it, the part after “&&” gets sent to the command line! bug report filed at https://jpsoft.com/forums/threads/is-this-by-design-execstr-type-filename-and-line-send-parts-of-the-text-file-after-directly-to-the-command-line.12502/
                        set probe_output=%@EXECSTR[type "%@UNQUOTE["%tmpfile%"]"]
                        setdos /x0

                        if %DEBUG_VALUE_TRANSFER% gt 0  (echo %star9% sooo: PROBE_OUTPUT=“%PROBE_OUTPUT%”)

                        set last_file_probed=%AUDIO_FILE%


                rem Split the string into tokens:
                        rem echo -DEBUG: goat wondering if things went south yet [1]
                        for /f "tokens=1-5 delims=%@CHAR[%delimeter_ascii%]" %%a in ("%probe_output%") do (
                                rem if %DEBUG_VALUE_TRANSFER gt 0 .or. %DEBUG_TOKEN_PROCESSING gt 0 (echo       %faint_on%%wrench% processing tokens (tit=%[faint_off]%%a %@ansi_move_left[1]%[faint_on]) (art=%[faint_off]%%b %@ansi_move_left[1]%[faint_on]) (alb=%[faint_off]%%c %@ansi_move_left[1]%[faint_on]) (tope=%[faint_off]%%d %@ansi_move_left[1]%[faint_on]) (hmm=%[faint_off]%e %@ansi_move_left[1]%[faint_on])%[faint_off])
                                rem this ruins things *setdos /x-5
                                set "probe_tit=%%a"
                                set "probe_art=%%b"
                                set "probe_alb=%%c"
                                set "probe_tpe=%%d"
                                set "probe_hmm=%%e"
                                setdos /x0
                        )

                rem It doesn’t count if it matches the a/b/c/d/e var we already had outside of the split ... those are urnelated single-letter environment variables
                        *setdos /x-5
                        if "%probe_tit" == "%a" set probe_tit=
                        if "%probe_art" == "%b" set probe_art=
                        if "%probe_alb" == "%c" set probe_alb=
                        if "%probe_tpe" == "%d" set probe_tpe=
                        if "%probe_hmm" == "%e" set probe_hmm=
                        setdos /x0

                rem Save post-probed values for auditing
                        rem echo -DEBUG: goat wondering if things went south yet [2]
                        unset /q PROBED*
                        *setdos /x-5
                        set PROBED_FILE_SONG=%probe_tit%
                        set PROBED_FILE_ARTIST=%probe_art%
                        set PROBED_FILE_ALBUM=%probe_alb%
                        set PROBED_FILE_ORIG_ARTIST_TOPE=%probe_tpe%
                        set PROBED_FILE_ORIG_ARTIST_HMMM=%probe_hmm%
                        setdos /x0

                rem Untested attempt to copmensate for original artist/composer difference in mp3/flac tags:
                        if "" == "%probe_tpe" .and. "" != "%probe_hmm%" (set probe_tpe=%probe_hmm%)
                        
                rem Transfer values over to our variables:         
                        for %%tmpVarName in (probe_tit, probe_art, probe_alb, probe_tpe, probe_hmm) do gosub sub_for_724  "%@UNQUOTE["%tmpVarName%"]"
                                        goto :for_724_end                                        
                                                :sub_for_724 [opt1]
                                                        set tmpVarName=%@UNQUOTE["%tmpVarName%"]
                                                        rem bad idea ... really need to set the separator to somehting else *setdos /x-5
                                                        set value=%[%tmpvarname]                                

                                                        set LEFT_NIN=%@left[ 9,%value%]
                                                        set LEFT_TEN=%@left[10,%value%]
                                                        set LEFT_ELV=%@left[11,%value%]
                                                        set LEFT_THI=%@left[13,%value%]

                                                        if %DEBUG_VALUE_TRANSFER gt 0  (echo %newline%!!   %%tmpVarName  is %lq%%TmpVarName%%rq% is %%value=%lq%%value%%rq% %+ echo    left_nin is %lq%%left_nin%%rq%%+ echo    left_ten is %lq%%left_ten%%rq% %+ echo    left_elv is %lq%%left_elv%%rq% %+ echo    left_thi is %lq%%left_thi%%rq%)
                                                        setdos /x0
                                     
                                                        rem echo %ansi_color_grey%-DEBUG: goat wondering if things went south yet [3]%ansi_color_normal%

                                                        iff "%LEFT_TEN%" == "tag:TITLE=" then
                                                                if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_SONG=%@right[%@eval[%@len[%value]-10],%value])
                                                                set FILE_SONG=%@right[%@eval[%@len[%value]-10],%value]
                                                        endiff
                                                        iff "%LEFT_ELV%" == "tag:ARTIST=" then
                                                                set FILE_ARTIST=%@right[%@eval[%@len[%value]-11],%value]
                                                                if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ARTIST=%@right[%@eval[%@len[%value]-11],%value])
                                                        endiff 
                                                        iff "%LEFT_TEN%" == "tag:ALBUM=" then
                                                                set tmpvalue=%@right[%@eval[%@len[%value]-10],%value]
                                                                set FILE_ALBUM=%tmpvalue%
                                                                if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ALBUM=%lq%%tmpvalue%%rq%)
                                                        endiff 
                                                        iff "%LEFT_THI%" == "tag:COMPOSER=" then
                                                                set FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-13],%value]
                                                                if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-13],%value])
                                                        endiff
                                                        iff "%LEFT_NIN%" == "tag:TOPE=" then
                                                                set FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-9],%value]
                                                                if %DEBUG_VALUE_TRANSFER gt 0 (echo    🐓 setting FILE_ORIG_ARTIST=%@right[%@eval[%@len[%value]-9],%value])
                                                        endiff
                                                return
                                        :for_724_end
                        rem echo -DEBUG: goat wondering if things went south yet [4]
                        iff "1" == "%DEBUG_DISPLAY_PROBE_RESULTS%" then
                                color bright red on black
                                setdos /x-5
                                echo    🔬 probed song: “%probe_tit%” but file_song  =“%file_song%”
                                echo    🔬 probed band: “%probe_art%” but file_artist=“%file_artist%”
                                echo    🔬 probed albm: “%probe_alb%” but file_album =“%file_album%”
                                echo    🔬 probed tope: “%probe_tpe%” \__ orig_artist=“%file_orig_artist%”
                                echo    🔬 probed hmmm: “%probe_hmm%” /
                                setdos /x0
                                %color_normal%
                        endiff                                

        rem If we didn’t get a title, use the filename after the number, i.e. “01_Time.flac" ——> “Time"
                if "" == "%FILE_SONG%" (set FILE_SONG=%@rereplace[[\d]+_,,%@name["%AUDIO_FILE%"]])

        rem If we didnt’ get an artist, but the filename is a " - " type name, then get the aprt before the " - "                
                set audio_file_has_spacedashspace=%@RegEx[ \- ,"%AUDIO_FILE%"]
                iff "" == "%FILE_ARTIST%" .and. "1" == "%audio_file_has_spacedashspace%" then
                        set FILE_ARTIST=%@UNQUOTE[%@ReReplace[[0-9]+_,,%@ReReplace[ \- .*$,,"%AUDIO_FILE%"]]]
                        echo %star3%%emoji_warning% Attempting to create file_artist from audio filename.... got “%FILE_ARTIST%” %emoji_warning% %star3% %conceal_on%🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕🦕%conceal_off%
                endiff

        rem If we didn’t get an original artist, also check fo the Composer tag which is the only place it would likely be in a FLAC file...
                rem echo -DEBUG: goat wondering if things went south yet [5]
                rem NO! ffprobe does some voodoo behind the scenes making this unnecessary: if "" == "%FILE_ORIG_ARTIST%" (set FILE_ORIG_ARTIST=%@EXECSTR[%PROBER% -v quiet -show_entries format_tags=Composer -of default=noprint_wrappers=1:nokey=1 "%AUDIO_FILE%" |:u8 change-single-quotes-to-double-apostrophes.py])

        rem “Title” is better than “Song”, but we are doing both for ease-of-remembrance
                set FILE_TITLE=%FILE_SONG%

        rem Done probing!                
                if %DEBUG gt 0 call unimportant "Probing done"         
                :already_probed


rem Update window title:
        if %DEBUG gt 0 call unimportant "setting window title to “%FILE_ARTIST% – %FILE_SONG%”"
        set title=%FILE_ARTIST% – %FILE_SONG%
        title %title%
        if %vebose gt 0 call unimportant "Title set" 

rem Back up original values of these variables because we change them as we try various different ways of searching:
        set      FILE_ARTIST_INITIAL=%FILE_ARTIST%
        set FILE_ORIG_ARTIST_INITIAL=%FILE_ORIG_ARTIST%
        set       FILE_ALBUM_INITIAL=%FILE_ALBUM%
        set        FILE_SONG_INITIAL=%FILE_SONG%
        set       FILE_TITLE_INITIAL=%FILE_SONG%
        if %vebose gt 0 call unimportant "Original values saved" 
        rem echo -DEBUG: goat wondering if things went south yet [6]


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem If we are in the special mode where we ONLY set environment variables, go to that section:
        if "%2" == "SetVarsOnly" (goto :SetVarsOnly_skip_to_1)

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem Debug info:
        rem call unimportant                    "input file exists: %1"
        if "1" == "%DEBUG_DISPLAY_PROBE_RESULTS%" gosub debug "Retrieved:%TAB%   artist=“%FILE_ARTIST%”%TAB%%tab%%tab%%tab%        title=“%FILE_SONG%”%TAB%%tab%%tab%%tab%        album=“%FILE_ALBUM%”%TAB%%tab%%tab%%tab%  orig artist=“%FILE_ORIG_ARTIST%”%tab%%tab%  probe_tpe=“%probe_tpe%”"
        if %vebose gt 0 call unimportant "Debug info printed" 

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem First things first——If it’s a cover song, and we know the original artist, we should search for lyrics by the original artist.
rem However, FLAC files don’t have an original artist tag, just “Composer”, and people put both types of values in them.
rem So we have to suspend this practice and compensate some other way later.
        iff "%FILE_ARTIST%" != "%FILE_ORIG_ARTIST%" .and. "" != "%FILE_ORIG_ARTIST%" then
                rem set FILE_ARTIST=%FILE_ORIG_ARTIST%
                set IS_POTENTIALLY_COVER_SONG=1
        else                
                set IS_POTENTIALLY_COVER_SONG=0
        endiff                
        
        if "1" == "%DEBUG_DISPLAY_PROBE_RESULTS%"  echo        %ansi_color_green%IS_POTENTIALLY_COVER_SONG=%IS_POTENTIALLY_COVER_SONG% .... FILE_ARTIST = “%FILE_ARTIST%” ... FILE_ORIG_ARTIST = “%FILE_ORIG_ARTIST%”  🎸  %ansi_color_normal%


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem Set potential filenames in our %LYRICS% repository, which can be matched 2 different ways: 
        :SetVarsOnly_skip_to_1
        rem echo -DEBUG: goat wondering if things went south yet [8]
        set MAYBE_SUBDIR_LETTER=%@LEFT[1,%file_artist]
        set              MAYBE_LYRICS_1=%lyrics\%MAYBE_SUBDIR_LETTER%\%file_artist% - %zzzzzzz%%@ReReplace[',_,%file_song%].txt
        set MAYBE_LYRICS_1_BROAD_SEARCH=%lyrics\%MAYBE_SUBDIR_LETTER%\%file_artist% - %@LEFT[3,%@ReReplace[',_,%file_song]]*.txt
        set              MAYBE_LYRICS_2=%lyrics\%MAYBE_SUBDIR_LETTER%\%@NAME[%AUDIO_FILE].txt
        rem if %vebose gt 0 call unimportant "Broad lyric search parameters generated" 

rem Also, subtitle files that may exist?
        set MAYBE_SRT_1=%@PATH[%maybe_lyrics_1]%@NAME[%MAYBE_LYRICS_1].lrc
        set MAYBE_SRT_2=%@PATH[%maybe_lyrics_2]%@NAME[%MAYBE_LYRICS_2].lrc
        rem rem gosub debug "Maybe_Srt_1 == “%maybe_srt_1”" %+ call debug "Maybe_Srt_2 == “%maybe_srt_2”"
        rem if %vebose gt 0 call unimportant "Broad LRC search parameters generated" 
        rem rem pause

        if "%2" == "SetVarsOnly" (goto :SetVarsOnly_skip_to_2)


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━
             
rem If we have set CONSIDER_ALL_LYRICS_APPROVED=1, then auto-approve lyrics at this first prompt, and reduce the time-wait on that prompt:
        iff "1" == "%CONSIDER_ALL_LYRICS_APPROVED%" then
                rem echo - %italics_on%Automatic%italics_off% acceptance of lyrics at prompt#1 turned %blink_on%on%blink_off% %ANSI_COLOR_NORMAL%
                set DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1=yes
                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
                set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
        else
                rem echo %ANSI_COLOR_DEBUG%%STAR% %italics_on%Automatic%italics_off% acceptance of lyrics at prompt#1 turned %blink_on%off%blink_off% %ANSI_COLOR_NORMAL%
                set DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1=no
        endiff
        
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Check if we already have a LRC/SRT file but no TXT file

        :Check_Again
        rem echo -DEBUG: goat wondering if things went south yet [12]
        iff exist "%LYRIC_FILE%" .and. "%@FILESIZE["%LYRIC_FILE%"]" != "0" goto :goto_endpoint_830
                rem echo iff not exist "%LYRIC_FILE%" .or. @FILESIZE["%LYRIC_FILE%"] eq 0 happened ...........
                rem iff exist "%SRT_SIDECAR_FILENAME%" .or. exist "%LRC_SIDECAR_FILENAME%" then
                rem         rem echo Karaoke file(s) exist, but not TXT
                rem         call warning_soft "Karaoke exists without lyrics file for “%emphasis%%italics_on%%AUDIO_FILE%%italics_off%%deemphasis%”"
                rem endiff                

                rem don’t convert if in genius-download-only mode:
                        if "1" == "%GENIUS_ONLY%" goto /i :do_not_convert_if_in_genius_only_mode

                        rem Do convert if a sidecar exists but no TXT file exists, and we’re NOT in genius-download-only mode:
                                iff exist "%SRT_SIDECAR_FILENAME%" then                
                                        call warning_soft "%italics_on%SRT%italics_off% exists...but no lyrics: ‘%italics_on%%LRC_SIDECAR_FILENAME%%italics_off’%"
                                        call less_important "Converting SRT file to TXT"
                                        call srt2txt.bat "%SRT_SIDECAR_FILENAME%" silent
                                        unset /q LYRIC_STATUS
                                        set JUST_GENERATED_LYRICS=1
                                        set JUST_CONVERTED_SRT_TO_TEXT=1
                                        set JUST_CONVERTED_FROM=srt
                                        rem goto /i :Check_Again
                                endiff
                                iff exist "%LRC_SIDECAR_FILENAME%" .and. "1" != "%JUST_CONVERTED_LRC_TO_TEXT%" then
                                        call warning_soft "%italics_on%LRC%italics_off% exists...but no lyrics: ‘%italics_on%%LRC_SIDECAR_FILENAME%%italics_off’%"
                                        call warning_soft "Converting %italics_on%LRC%italics_off% file to %italics_on%TXT%italics_off%: ‘%italics_on%%TXT_SIDECAR_FILENAME%%italics_off’%"
                                        rem  LRC to TXT conversion is trivial enough to handle with cut.exe:
                                        call lrc2txt.bat "%LRC_SIDECAR_FILENAME%" silent
                                        unset /q LYRIC_STATUS
                                        set JUST_GENERATED_LYRICS=1
                                        set JUST_CONVERTED_LRC_TO_TEXT=1
                                        set JUST_CONVERTED_FROM=lrc
                                        rem goto /i :Check_Again
                                endiff
                        rem Review it! We auto-approved tons of these and left a horrible mess for ourselves by not adding this review step in til 2025/04/02
                                rem pause  set JUST_GENERATED_LYRICS=“%JUST_GENERATED_LYRICS%” ... TXT_SIDECAR_FILENAME=“%TXT_SIDECAR_FILENAME%”
                                if "1" != "%JUST_GENERATED_LYRICS%" goto :endif_903
                                        call bigecho "🧁 Freshly generated! 🧁" 
                                        if exist "%TXT_SIDECAR_FILENAME%" call review-files "%TXT_SIDECAR_FILENAME%"
                                        :Ask_Again_845
                                        call AskYn "Are these lyrics%dash%%blink_on%converted from %italics_on%%just_converted_from%%italics_off%%blink_off%%dash%acceptible" No %LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS% ADHILOP A:approve_the_lyrics,D:delete_sidecars,I:mark_instrumental,L:mark_lyriclessness,O:dOwnload_new_lyrics,P:play_file,H:hand-edit
                                        rem Preserve answer in case any subroutines call AskYN and re-set it:
                                                set OUR_LAST_ANSWER_HERE=%ANSWER%
                                        rem On “N”:
                                                iff "%OUR_LAST_ANSWER_HERE%" == "N" then                               
                                                        if exist "%LYRIC_FILE%" (ren  /q "%LYRIC_FILE%" "%LYRIC_FILE%.%_datetime.rejected-after-conversion-from-%just_converted_from%.bak")                                                
                                                endiff
                                        rem On “Y”/“A”/“D”/“I”/“L”/“P”:
                                                gosub check_for_answer_of_P 
                                                if  "P" == "%OUR_LAST_ANSWER_HERE%" .or. "E" == "%OUR_LAST_ANSWER_HERE%"   goto /i Ask_Again_845
                                                gosub check_for_answer_of_A Y
                                                gosub check_for_answer_of_D
                                                gosub check_for_answer_of_H
                                                gosub check_for_answer_of_I
                                                gosub check_for_answer_of_L
                                        rem Finishings for “I”, “L”, “O”, “P”:
                                                if  "I" == "%OUR_LAST_ANSWER_HERE%"   goto /i END
                                                if  "L" == "%OUR_LAST_ANSWER_HERE%"   goto /i END
                                                if  "O" == "%OUR_LAST_ANSWER_HERE%"   goto /i download_with_lyric_downloader_init
                                :endif_903

                        :do_not_convert_if_in_genius_only_mode       
        :goto_endpoint_830


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem Check if we already have approved lyrics in the same folder:

        :check_lyric_file_begin                
        rem echo -DEBUG: goat wondering if things went south yet [16]
        iff exist "%LYRIC_FILE%" .and. %@FILESIZE["%LYRIC_FILE%"] gt 0 .and. "1" != "%FORCE_REGEN%"  then
                rem Get lyric pre-approval status
                        rem if  "%LYRIC_STATUS%" == "" call get-lyric-status "%LYRIC_FILE%" silent
                        if  "%LYRIC_STATUS%" == "" gosub refresh_lyric_status       
                        iff "%LYRIC_STATUS%" == "APPROVED" then 
                                gosub divider
                                call success "Lyrics are already approved!"
                                set LYRICS_ACCEPTABLE=1
                                set LYRIC_ACCEPTANCE_PROMPT_TO_USE=yes
                                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
                                set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_AUTO%
                                set GOTO_END=1
                                goto /i END
                        elseiff "1" == "%FORCE_REGEN" then 
                                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_FOR_FORCE_REGEN%
                        else                        
                                set LYRICS_ACCEPTABLE=0
                                set LYRIC_ACCEPTANCE_PROMPT_TO_USE=%DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%
                                set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME%
                                set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME%
                        endiff                   
                        if "1" == "%GOTO_END%" goto /i :END

                rem Display lyrics:
                        rem @gosub divider
                        rem @call bigecho %ansi_color_bright_white%%star% %underline_on%Current lyrics%underline_off%:
                        rem don’t set a color: echos %ANSI_COLOR_GREEN%
                        rem (type "%LYRIC_FILE%" |:u8 unique-lines -A -L) |:u8 print-with-columns

                        gosub set_postprocessed_lyrics "%LYRIC_FILE%"
                        if "1" == "%SHOW_UNPROCESSED_LYRICS_ALSO%" call review-file   -wh  -st    "%LYRIC_FILE%"           "%underline_on%Current lyrics%underline_off% (not processed)"
                                                                   call review-file   -wh  -stU   "%postprocessed_lyrics%" "%underline_on%Current lyrics%underline_off% (processed)"

                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[purple]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                        rem removed 2022/12/11 
                        @gosub divider

                rem Get lyric approval status:
                        rem No let’s not do this yet! unset /q lyric_status
                        rem %LYRIC_STATUS%" == "" call      get-lyric-status "%LYRIC_FILE%" silent
                        if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status
                        iff    "%lyric_status%" == "APPROVED" then
                                set LYRICS_ACCEPTABLE=1
                                set LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED=1
                                goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                        else                                
                                set LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED=0
                        endiff

                rem Get original Genius JSON-file download name, which we store as an ADS tag attached the downloaded lyricfile:
                        set   PREVIOUS_GENIUS_FILENAME=%@ExecStr[type <"%@UNQUOTE["%AUDIO_FILE%"]:genius_filename" >&>nul]`` 

                rem Display the filename again in case the lyrics were so long / text zoomed in so large / columns so wide print_with_columns couldn’t fit it on the screen such that it scrolled off and we lost track of what song we are even looking at, and need to be reminded
                        iff "%PREVIOUS_GENIUS_FILENAME%" !=  "" then
                                rem Massage audiofile / geniusfilename / artistname: Step 1: capture original variables, strip out spaces, hyphens, leading The
                                        *setdos /x-8-5
                                        set  PREV_GENIUS_FNAME_2_USE=%@UNQUOTE[%%@REPLACE[',,%@REPLACE[-,,%@REPLACE[ ,,"%PREVIOUS_GENIUS_FILENAME%"]]]]
                                        set    ARTIST_NAME_SCRUNCHED=%@UNQUOTE[%%@REPLACE[',,%@REPLACE[ ,,%@REPLACE[ ,,"%FILE_ARTIST%"]]]]
                                        set    AUDIO_FILE_TO_DISPLAY=%@UNQUOTE[%%@REPLACE[',,%@REPLACE[-,,%@REPLACE[ ,,"%AUDIO_FILE%"]]]]
                                        if   "%AUDIO_FILE_TO_DISPLAY%" != "" if "1" != "%@Regex[^[Tt][Hh][Ee][Yy],%AUDIO_FILE_TO_DISPLAY%]"   set   AUDIO_FILE_TO_DISPLAY=%@UNQUOTE[%%@ReReplace[^[Tt][Hh][Ee],,"%AUDIO_FILE_TO_DISPLAY%"]]
                                        if "%PREV_GENIUS_FNAME_2_USE%" != "" if "1" != "%@Regex[^[Tt][Hh][Ee][Yy],%PREV_GENIUS_FNAME_2_USE%]" set PREV_GENIUS_FNAME_2_USE=%@UNQUOTE[%%@ReReplace[^[Tt][Hh][Ee],,"%PREV_GENIUS_FNAME_2_USE%"]]

                                        rem Take “The ” of artist name:                                                                                                                                                               
                                                rem echo %ANSI_COLOR_DEBUG%- DEBUG: ARTIST_NAME_SCRUNCHED=“%ARTIST_NAME_SCRUNCHED%”, FILE_ARTIST=“%FILE_ARTIST%” which if it’s empty would explain things
                                                set do_it=0
                                                if "" == "%ARTIST_NAME_SCRUNCHED%" goto /i nevermind_1023
                                                if "1" != "%@Regex[^[Tt][Hh][Ee][Yy],%ARTIST_NAME_SCRUNCHED%]"   set do_it=1
                                                :decision_made_1017
                                                if "0" == "%do_it%" goto /i nevermind_1023
                                                if "1" == "%do_it%" set ARTIST_NAME_SCRUNCHED=%@UNQUOTE[%%@ReReplace[^[Tt][Hh][Ee],,"%ARTIST_NAME_SCRUNCHED%"]]
                                                :nevermind_1023 
                                                setdos /x0                   

                                rem Massage audiofile / geniusfilename / artistname: Step 2: strip the “01_” from filenames like “01_track.mp3”
                                        set AUDIO_FILE_TO_DISPLAY_NAME=%@ReReplace[[0-9]+_,,%@UNQUOTE[%@NAME["%AUDIO_FILE_TO_DISPLAY%"]]]

                                rem Massage audiofile / geniusfilename / artistname: Step 3: get initial lengths:
                                        set      ARTIST_NAME_SCRUNCHED_LENGTH=%@LEN[%ARTIST_NAME_SCRUNCHED%]
                                        set      AUDIO_FILE_TO_DISPLAY_LENGTH=%@LEN[%AUDIO_FILE_TO_DISPLAY%]
                                        set AUDIO_FILE_TO_DISPLAY_NAME_LENGTH=%@LEN[%AUDIO_FILE_TO_DISPLAY_NAME%]
                                        set            FILENAME_GENIUS_LENGTH=%@LEN["%PREV_GENIUS_FNAME_2_USE%"]  %+ rem ...and this instaed

                                rem Massage audiofile / geniusfilename / artistname: Step 4: genereate spacers
                                        set tmpSpacer=%@REPEAT[ ,%@EVAL[%ARTIST_NAME_SCRUNCHED_LENGTH]]``
                                        set TMPSPACER_LENGTH=%@LEN[%tmpspacer%]

                                rem Massage audiofile / geniusfilename / artistname: Step 5: calculate additional lengths
                                        set AUDIO_FILE_DISPLAY_LENGTH_WITH_SPACER=%@EVAL[%ARTIST_NAME_SCRUNCHED_LENGTH% + 0 + %AUDIO_FILE_TO_DISPLAY_NAME_LENGTH%] %+ rem 0 used to be 1 used to be 2 

                                rem Massage audiofile / geniusfilename / artistname: Step 6: kill the spacer if both start with the same 5 letters because spacer is not needed if they already line up:
                                        iff "%@LEFT[5,"%AUDIO_FILE_TO_DISPLAY_NAME%"]" == "%@LEFT[5,"%PREVIOUS_GENIUS_FILENAME%"]" then
                                                set tmpSpacer=``
                                                set tmpSpacer_length=0
                                        endiff

                                rem Massage audiofile / geniusfilename / artistname: Step 7: kill the spacer if the ARTIST_NAME_SCRUNCHED isn’t even in the PREVIOUS_GENIUS_FILENAME because what are we even alingning at that point?
                                        if "" != "%ARTIST_NAME_SCRUNCHED%" set LAST_ALIGNMENT_TEMP_INDEX=%@INDEX[%PREVIOUS_GENIUS_FILENAME%,%ARTIST_NAME_SCRUNCHED%]
                                        iff "%LAST_ALIGNMENT_TEMP_INDEX%" == "-1" then
                                                set tmpSpacer=``
                                                set tmpSpacer_length=0
                                        endiff

                                rem Massage audiofile / geniusfilename / artistname: Step 8: Determine which line is longest:
                                        set LENGTHIEST=%@MAX[%FILENAME_GENIUS_LENGTH%,%@EVAL[%AUDIO_FILE_TO_DISPLAY_NAME_LENGTH%+%tmpSpacer_length%]]

                                rem Massage audiofile / geniusfilename / artistname: Step 9: Calculate the column where our message will be displayed:
                                        set MAGIC_COLUMN=%@EVAL[%LENGTHIEST% + 23] 

                                rem Massage audiofile / geniusfilename / artistname: DEBUG INFO
                                        echo  LENGTHIEST=“%lengthiest%”  // FILENAME_GENIUS_LENGTH=“%FILENAME_GENIUS_LENGTH%”(%PREVIOUS_GENIUS_FILENAME%) // AUDIO_FILE_DISPLAY_LENGTH_WITH_SPACER=“%AUDIO_FILE_DISPLAY_LENGTH_WITH_SPACER%”(%%) ///// AUDIO_FILE_TO_DISPLAY_NAME_LENGTH=“%AUDIO_FILE_TO_DISPLAY_NAME_LENGTH%”(%AUDIO_FILE_TO_DISPLAY_NAME%) and @LEN[tmpspacer]=“%@LEN[%tmpspacer]” ... so MAGIC_COLUMN=“%MAGIC_COLUMN%” // 😎 ARTIST_NAME_SCRUNCHED_LENGTH=“%ARTIST_NAME_SCRUNCHED_LENGTH%”(%ARTIST_NAME_SCRUNCHED%)

                                rem Massage audiofile / geniusfilename / artistname: Step 10: Set variable to ANSi code to move us to the proper column and set our message color:
                                        set MOVEITMOVEIT=%@ANSI_MOVE_TO_COL[%MAGIC_COLUMN%]%ansi_color_bright_yellow%
                        else
                                unset /q MOVEITMOVEIT
                                set AUDIO_FILE_TO_DISPLAY=%AUDIO_FILE%
                                set AUDIO_FILE_TO_DISPLAY_NAME=%@NAME["%AUDIO_FILE_TO_DISPLAY%"]
                        endiff


                rem Display line #1: the directory:
                        gosub DisplayAudioDirectory nofilename

                rem Display line #1.5: the audio filename without processing
                         IF "%PREVIOUS_GENIUS_FILENAME%" !=  "" echo %ansi_color_prompt%%star% %ansi_color_bright_yellow%Syst%@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "",e,]m filename%ansi_color_yellow%: %ansi_color_pink%%@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "",%tmpSpacer%,]%blink_off%“%blink_off%%ansi_color_green%%ansi_color_pink%%italics_on%%AUDIO_FILE%%blink_off%%italics_off%%ansi_color_prompt%”

                rem TODO: is it always the top one that’s shorter? 
                          rem because the bottom one has the band name, yes.  
                          rem so we could use %@INDEX to find the index of the 1ˢᵗ 5 chars of the audio fileename within the genius filename
                          rem and then make the spacer that way

                rem Display line #2: the audiofile filename
                        rem   %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio %@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "", ,]filename%ansi_color_yellow%:%ansi_color_prompt% %@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "",%tmpSpacer%,]“%italics_on%%blink_off%%ansi_color_green%%AUDIO_FILE_TO_DISPLAY_NAME%%blink_off%%italics_off%%ansi_color_prompt%”  [old legacy line] with one less space after the colon
                        echos %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio %@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "", ,]filename%ansi_color_yellow%: %ansi_color_prompt%%@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "",%tmpSpacer%,]%blink_off%“%blink_off%%ansi_color_BRIGHT_green%%italics_on%%AUDIO_FILE_TO_DISPLAY_NAME%%blink_off%%italics_off%%ansi_color_prompt%”


                rem Display line #3: the Genius JSON-file download name, if one was previously fetched:
                        iff "%PREVIOUS_GENIUS_FILENAME%" !=  "" then
                                echos %MOVEITMOVEIT%%@CHAR[10229]   %blink_on%Are these more%blink_off%
                                echo.
                                echos %ansi_color_prompt%%star% %ansi_color_bright_yellow%%ansi_color_orange%Genius %ansi_color_bright_yellow%filename%ansi_color_yellow%:%ansi_color_prompt% “%italics_on%%blink_off%%ansi_color_BRIGHT_green%%PREV_GENIUS_FNAME_2_USE%%ansi_color_prompt%%blink_off%%italics_off%”
                                echos %MOVEITMOVEIT%%@CHAR[10229]  %blink_on%or less the same%blink_off%?
                        endiff
                        echo.

                rem %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio %@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "", ,]filename%ansi_color_yellow%:%ansi_color_prompt% %@IF["%PREVIOUS_GENIUS_FILENAME%" !=  "",%tmpSpacer%,]“%italics_on%%blink_off%%ansi_color_green%%AUDIO_FILE_TO_DISPLAY_NAME%%blink_off%%italics_off%%ansi_color_prompt%”  [old legacy line] with 1 less spc after :

                rem Ask if the lyrics are good:
                        rem Default answer is different depending on the situation:
                                iff "1" == "%LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE%" .or. "1" == "%FORCE_REGEN%" then
                                        set LYRIC_ACCEPTANCE_PROMPT_TO_USE=yes
                                        set LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE=%LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_FOR_FORCE_REGEN%
                                        unset /q LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE
                                else
                                        set LYRIC_ACCEPTANCE_PROMPT_TO_USE=no
                                endiff
                        rem Ask the actual question:
                                :Ask_Again_p_972
                                if "1" == "%JUST_GENERATED_LYRICS%" (call bigecho "%ansi_color_bright_yellow%%star2% Fresh TXT file converted from SRT/LRC%ansi_color_normal%" %+ set LYRIC_ACCEPTANCE_PROMPT_TO_USE=no)  %+ rem was Yes but incorrect LRC downloads would then create incorrectly-accepted lyrics so this did not play out as the right decision 
                                echo %emoji_red_question_mark%%ANSI_COLOR_PROMPT%%EMOJI_QUESTION_MARK% We %italics_on%already have%italics_off% these. Are they acceptable?
                                call AskYn "Acceptable?%conceal_on%1%conceal_off%[%ANSI_COLOR_bright_green%H%ANSI_COLOR_PROMPT%%connecting_equals%Yes+%ansi_color_bright_green%h%ansi_color_prompt%and-edit,%ANSI_COLOR_bright_green%P%ansi_color_prompt%lay,%ANSI_COLOR_bright_green%G%ANSI_COLOR_PROMPT%oogle,%ansi_color_bright_green%L%ansi_color_prompt%yricless(%ansi_color_green%Z%ansi_color_prompt%%connecting_equals%All),e%ansi_color_bright_green%D%ansi_color_prompt%it band/tit,d%ansi_color_bright_green%O%ansi_color_prompt%wnload,%ansi_color_bright_green%I%ansi_color_prompt%=inst(%ansi_color_bright_green%X%ansi_color_prompt%=All),%ansi_color_bright_green%R%ansi_color_prompt%ename,s%ansi_color_bright_green%K%ansi_color_prompt%ip]" %LYRIC_ACCEPTANCE_PROMPT_TO_USE%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME_TO_USE% DHILOPRSKXZ H:Yes_but_hand-edit_them_first,L:Mark_as_lyricless!!,Z:Mark_everything_here_as_lyricless,P:Play_file_it_and_see,G:Google_for_better,D:eDit_the_artist/song_instead,O:dOwnload_new_lyrics_nOw,I:mark_instrumental,X:mark_all_as_insturmentals,R:rename,K:skip_this_file
                                set HOLD_ANSWER=%ANSWER%

                        rem Deal with our answer:
                                gosub check_for_answer_of_R
                                set ANSWER=%HOLD_ANSWER%

                                gosub check_for_answer_of_P
                                set ANSWER=%HOLD_ANSWER%

                                gosub check_for_answer_of_H
                                set ANSWER=%HOLD_ANSWER%

                                if "P" == "%HOLD_ANSWER%" goto /i Ask_Again_p_972
                                if "R" == "%HOLD_ANSWER%" goto /i Ask_Again_p_972
                                if "S" == "%HOLD_ANSWER%" (call important_less "Skipping" %+ goto /i END)
                                
                                rem echo 🎨 goto_download_with_lyric_downloader_1 is "%goto_download_with_lyric_downloader_1%" 
                                rem                        if  "1" == "%goto_download_with_lyric_downloader_1%" goto /i download_with_lyric_downloader_init                                                                                                                                                                                                                                  
                                if "%HOLD_ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" goto /i download_with_lyric_downloader_init

                                gosub check_for_answer_of_D_to_eset_artist_and_song
                                if "D" == "%HOLD_ANSWER%" goto /i download_with_lyric_downloader_init
                                gosub check_for_answer_of_G
                                if  "1" == "%GOOGLE_NOW%" goto /i Google_Now
                                iff "Y" == "%HOLD_ANSWER%" then
                                        set LYRICS_APPROVED=1
                                else
                                        set ANSWER=%HOLD_ANSWER%
                                        gosub check_for_answer_of_I
                                        gosub check_for_answer_of_L
                                        rem Just got back from check_for_answer_of_L called from near the end of get-lyrics 📚📚📚📚📚 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”
                                        if "1" == "%GOTO_END%" (goto /i END)
                                        goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                                endiff
                                if "P" == "%HOLD_ANSWER%" (goto /i Ask_Again_p_927)
                                if "I" == "%HOLD_ANSWER%" (set  goto_end=1)
                                if "X" == "%HOLD_ANSWER%" (set  goto_end=1)
                                if "1" == "%GOTO_END%"    (goto /i END)
                                
                rem Since the question we just asked included option to hand-edit, let’s suppress asking that question later:
                        set  DO_NOT_ASK_TO_HAND_EDIT=1
                        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 2 >nul 
                        set  FORCE_HAND_EDIT=0
                        
                rem If the lyrics are good, set them as so. if they are not, warn:                        
                        set ANSWER=%HOLD_ANSWER%
                        iff "%ANSWER%" == "Y" .or. "%ANSWER%" == "H" then                        
                                rem if "%LYRIC_STATUS%" == "" call get-lyric-status "%LYRIC_FILE%" silent
                                if "%LYRIC_STATUS%" == "" gosub refresh_lyric_status
                                echo %check% %ansi_color_success%Approving lyrics...%ansi_color_normal% %conceal_on%DEF%conceal_off%
                                iff "%LYRIC_STATUS%" != "APPROVED" then
                                        set JUST_APPROVED_LYRICS=1
                                        call  approve-lyrics "%LYRIC_FILE%" >nul
                                        gosub approve_lyrics_done
                                endiff                                        
                                set JUST_APPROVED_LYRICS=1
                                set LYRICS_ACCEPTABLE=1
                                set ANSWER=%HOLD_ANSWER%
                                iff "%ANSWER%" != "H" then
                                        set  DO_NOT_ASK_TO_HAND_EDIT=1
                                        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 3 >nul 
                                        set  FORCE_HAND_EDIT=0
                                endiff
                                rem echo 🍕🍕 goat problematic answer is “%answer%” right before the block where we set force_hand_edit
                                iff "%ANSWER%" == "H" then
                                        set DO_NOT_ASK_TO_HAND_EDIT=0
                                        rem gosub debug "Setting FORCE_HAND_EDIT=1 .... instance #2 ... answer=“%ANSWER%”"
                                        set  FORCE_HAND_EDIT=1
                                        echo FORCE_HAND_EDIT=%FORCE_HAND_EDIT% trace 4 >nul 
                                else
                                        goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                                endiff                                        
                        else
                                set LYRICS_ACCEPTABLE=0
                                rem echo %ansi_color_warning_soft%%star% Not using them, so let’s remove them and try downloading...%ansi_color_normal%
                                rem if exist "%LYRIC_FILE%" (ren  /q "%LYRIC_FILE%" "%LYRIC_FILE%.%_datetime.MAKE_THIS_BE_A_REASON.bak")

                                echo %ansi_color_warning_soft%%star% Not using them...%ansi_color_normal%
                                iff exist "%LYRIC_FILE%" then
                                        call AskYN "Remove lyric file" yes 0 A A:approve_it
                                        
                                        iff "Y" == "%ANSWER%" then
                                                set rejected_original_lyrics=%LYRIC_FILE%.%_DATETIME.rejected.bak 
                                                ren /q  "%LYRIC_FILE%" "%REJECTED_ORIGINAL_LYRICS%"
                                        else
                                                if "N" == "%ANSWER%" goto /i check_lyric_file_begin
                                        endiff
                                endiff
                                if  exist "%SRT_SIDECAR_FILENAME%" (call AskYN "Remove SRT file" yes 0 %+ if "Y" == "%ANSWER%" ren  /q "%SRT_SIDECAR_FILENAME%" "%SRT_SIDECAR_FILENAME%.%_DATETIME.rejected.bak")
                                if  exist "%LRC_SIDECAR_FILENAME%" (call AskYN "Remove LRC file" yes 0 %+ if "Y" == "%ANSWER%" ren  /q "%LRC_SIDECAR_FILENAME%" "%LRC_SIDECAR_FILENAME%.%_DATETIME.rejected.bak")

                                rem gosub divider
                                goto /i End_Of_Check_To_See_If_We_Already_Had_Them
                        endiff                     
echo 🍕🍕 goat problematic answer is “%[answer]” achieved force_hand_edit value of “%force_hand_edit%”
                        if "%ANSWER%" == "H" gosub edit_lyrics_now_if_we_answered_H H
echo 🍕🍕 goat problematic answer is “%[answer]” has now returned from the edit_lyrics_now_if_we_answered_H H added 2025/03/27

        endiff
        :End_Of_Check_To_See_If_We_Already_Had_Them
        if %vebose gt 0 call unimportant ":End_Of_Check_To_See_If_We_Already_Had_Them" 
        if "1" == "%GOTO_END%" (goto :END)
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━




rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem ━━━━━━━━━━━━━━━━━━━━━━━ CHECKING IN OLD MINILYRICS/EVILLYRICS REPOSITORY STUFF BEGINS HERE ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
:actual_alignment_begins
:repo_stuffs_begin
rem echo -DEBUG: goat wondering if things went south yet [32]




rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem Check if we have one in our lyric repository already, via 2 different filenames, and then manual selection:
        rem gosub debug "(10) Checking[hh] for %MAYBE_LYRICS_1%" silent
        if "%MAYBE_LYRICS_1%" == "%LAST_MAYBE_LYRICS_1%" goto :MaybeLyrics1_END
        set LAST_MAYBE_LYRICS_1=%MAYBE_LYRICS_1%
        iff "1" != "%LYRICS_ACCEPTABLE%" .and. exist "%MAYBE_LYRICS_1%" .and. %@FILESIZE["%MAYBE_LYRICS_1%"] gt 0 .and. "1" != %GENIUS_ONLY% then
                set PROCESS_MAYBE_1=1
        else
                set PROCESS_MAYBE_1=0
        endiff

        rem iff "1" == "%LYRICS_ACCEPTABLE%" .and. exist "%MAYBE_LYRICS_1%" .and. %@FILESIZE["%MAYBE_LYRICS_1%"] gt 0 .and. "1" != %GENIUS_ONLY% then
        if "1" != "%PROCESS_MAYBE_1%" goto :endiff_991
                @gosub divider
                @call less_important "Found possible lyrics (type 1) at %emphasis%%maybe_lyrics_1%%deemphasis%!%conceal_on%3838%conceal_off%"
                @call less_important "Let’s review them..."
                rem @gosub divider
                rem @call bigecho %ANSI_COLOR_IMPORTANT_LESS%%star% %underscore_on%Let’s review:%underscore_off%%ANSI_RESET%
                rem (type "%MAYBE_LYRICS_1%" |:u8 unique-lines -A -L) |:u8 print-with-columns
                call review-file -wh "%MAYBE_LYRICS_1%" 
                echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[bright cyan]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                gosub divider
                rem echo displayaudiofilename 02
                gosub DisplayAudioFileName
                :Ask_Again_p_12
                call AskYn "These good? (e%ansi_color_bright_green%D%ansi_color_prompt%it band/song,%ansi_color_bright_green%P%ansi_color_prompt%lay,%ansi_color_bright_green%H%ansi_color_prompt%and-edit,%ansi_color_bright_green%L%ansi_color_prompt%yric give-up(%ansi_color_bright_green%Z%ansi_color_prompt%=all),I=%ansi_color_bright_green%I%ansi_color_prompt%nstr(%ansi_color_bright_green%X%ansi_color_prompt%=All),d%ansi_color_bright_green%O%ansi_color_prompt%/l)" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% DHILOPXZ H:Yes_but_hand_edit_first,L:No!_Marking_as_lyricless,I:Mark_the_track_as_an_instrumental_track,P:Play_the_file,Z:mark_all_songs_in_folder_as_lyricless,D:edit_artist/song_name,O:dOwnload_lyrics_nOw,X:mark_all_as_instrumental
                        rem echo [A] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        set SAVED_ANSWER=%ANSWER%
                        if "%ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" goto download_with_lyric_downloader_init
                        rem echo [B] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        gosub check_for_answer_of_D_to_eset_artist_and_song
                        rem echo 🎨 goto_download_with_lyric_downloader_1 is "%goto_download_with_lyric_downloader_1%" 
                        rem echo [C] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        gosub check_for_answer_of_P
                        gosub check_for_answer_of_L
                        rem echo [E] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        if  "L" == "%SAVED_ANSWER%"   goto /i END
                        if  "P" == "%SAVED_ANSWER%"   goto /i Ask_Again_p_12
                        gosub check_for_answer_of_I
                        rem echo [G] Just got back from “these good” around line 975 🏠🏠🏠🏠🏠🏠 ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%”,  LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” !!!!!
                        rem echo answer=“%answer%”,goto_end=“%goto_end%”
                        if "1" == "%GOTO_END%" goto /i END
        :endiff_991
        if  "1" == "%goto_END%"          goto /i END
        if  "1" == "%ABANDONED_SEARCH%"  goto /i END
        if  "L" == "%ANSWER%"            goto /i END
        if  "P" == "%ANSWER%"            goto /i Ask_Again_p_12
        if  "1" == "%goto_download_with_lyric_downloader_1%" goto download_with_lyric_downloader_init
        iff "1" == "%PROCESS_MAYBE_1%" then
                rem call AskYn "%conceal_on%2%conceal_off%Do %italics_on%these%italics_off% look acceptable (%ansi_color_bright_green%H%ansi_color_prompt%=Yes+%ansi_color_bright_green%H%ansi_color_prompt%and-edit,%ansi_color_bright_green%L%ansi_color_prompt%=No! Give up/%ansi_color_bright_green%L%ansi_color_prompt%yriclessness)" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% HL H:Yes_but_hand_edit_first,L:No!_Marking_as_lyricless
                iff "%ANSWER%" == "Y" .or. "%ANSWER%" == "H" then
                        *copy /q "%MAYBE_LYRICS_1%" "%LYRIC_FILE%" >nul
                        iff exist "%LYRIC_FILE%" then
                                call approve-lyrics "%LYRIC_FILE%"
                                set LYRICS_ACCEPTABLE=1
                                set LYRIC_STATUS=APPROVED
                        endiff
                        set LYRIC_STATUS=APPROVED
                        if not exist "%LYRIC_FILE%" (call error "Well. This shouldn%apostrophe%t happen. #9334033440" %+ beep %+ pause %+ call exit-maybe)
                        rem echo [1] about to call edit_lyrics_now_if_we_answered_H 🐐
                        if "%ANSWER%" == "H" gosub edit_lyrics_now_if_we_answered_H H
                        set DO_NOT_ASK_TO_HAND_EDIT=1
                        set    JUST_APPROVED_LYRICS=1
                        set       LYRICS_ACCEPTABLE=1
                        goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                else
                        set LYRICS_ACCEPTABLE=0
                        call warning_soft "Not using potential lyric file #1, then..."
                        goto /i MaybeLyrics2
                endiff
        endiff
        rem echo 🐐 Trace LS1 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
        :MaybeLyrics1_END

        :MaybeLyrics2
        rem gosub debug "(11) Checking[ii] for %MAYBE_LYRICS_2%" silent
        iff exist "%MAYBE_LYRICS_2%" .and. %@FILESIZE["%MAYBE_LYRICS_2%"] gt 0  .and. "1" != "%GENIUS_ONLY%" then
                set PROCESS_MAYBE_2=1
        else
                set PROCESS_MAYBE_2=0
        endiff
        rem exist "%MAYBE_LYRICS_2%" .and. %@FILESIZE["%MAYBE_LYRICS_2%"] gt 0  .and. 1 ne %GENIUS_ONLY% then
        iff "1" == "%PROCESS_MAYBE_2%" then
                call less_important "Found possible lyrics (type 2) at %emphasis%%maybe_lyrics_2%%emphasis%!%conceal_on%7272%conceal_off%"
                call less_important "Let’s review them:"
                rem gosub divider
                rem @call bigecho %ANSI_COLOR_IMPORTANT_LESS%Let’s review!%ANSI_RESET%
                rem (type "%MAYBE_LYRICS_2%" |:u8 unique-lines -A -L) |:u8 print-with-columns
                call review-file -wh "%MAYBE_LYRICS_2%" "%ANSI_COLOR_IMPORTANT_LESS%Let’s review!%ANSI_RESET%"
                echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[bright cyan]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                gosub divider
                rem echo displayaudiofilename 03
                gosub DisplayAudioFileName
                :ask_again_1297
                call AskYn "%conceal_on%3%conceal_off%Do these look acceptable [%ansi_color_bright_green%P%ansi_color_prompt%lay,%ansi_color_bright_green%H%ansi_color_prompt%and-edit]" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% HP H:Yes_but_hand-edit_first,P:play
                rem echo 1 so answer is "%ANSWER%"
                                
                iff "%ANSWER%" == "Y" .or. "%ANSWER%" == "H" .or. "%ANSWER%" == "P" then
                        rem echo 1 so answer is "%ANSWER%"
                        *copy "%MAYBE_LYRICS_2%" "%LYRIC_FILE%"
                        unset /q LYRIC_STATUS
                        rem about to call edit_lyrics_now_if_we_answered_H 🐐
                        gosub check_for_answer_of_P
                        if "%ANSWER%" == "P" goto /i ask_again_1297
                        gosub edit_lyrics_now_if_we_answered_H H
                        iff "%ANSWER%" == "Y" then
                                set LYRICS_ACCEPTABLE=1
                                set DO_NOT_ASK_TO_HAND_EDIT=1
                        endiff
                        if "%ANSWER%" == "H" (echo %BLINK_ON%should we ask if post-hand-edited  are good here?? 🚄🚄🚄🚄🚄%BLINK_OFF% 🐐 %+ pause)
                        goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                else
                        rem echo 1 wait, if answer is "%ANSWER%" why are we here?
                        set LYRICS_ACCEPTABLE=0
                        call warning_soft "Not using potential lyric file #2, then..."
                endiff
        endiff
        rem echo 🐐 Trace LS3 -- LYRICLESSNESS_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRIC_STATUS%”, goto_END=“%GOTO_END%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”
        if "1" != "%FORCE_REDOWNLOAD%" .and. ("%LYRICLESSNESS_STATUS%" == "APPROVED" .or. "%GOTO_END%" == "1") goto :END

rem If we still didn’t find anything acceptable, but have potentially matching files in our lyric repository, let us select one manually:
        :TrySelectingSomethingFromOurLyricsArchive
        :select_from_repo_again
        set TRY_SELECTION_AGAIN=0
        set do_block_1008=0
        if exist "%MAYBE_LYRICS_1_BROAD_SEARCH%" .and. "%SKIP_MANUAL_SELECTION%" != "1" .and. "1" != "%GENIUS_ONLY%" (set do_block_1008=1)

        if "1" != "%do_block_1008%" goto :do_not_do_block_1008
                rem echo 🐐 entering do_block_1008
                rem gosub debug "(12) Checking[jj] for %MAYBE_LYRICS_1_BROAD_SEARCH%" 
                set  file_count=%@files["%MAYBE_LYRICS_1_BROAD_SEARCH%"]
                if "%file_count%" == "1" .and. "1" != "%found_broad_lyrics_branch_1%" goto :true_1010 %+ rem else:
                                                                                      goto :false_1010
                        :true_1010
                        if "%ONLY_ONE_FILE_AND_IT_WAS_TRIED%" == "1" goto :End_Of_Local_Lyric_Archive_Selection
                        gosub divider
                        rem  less_important "Found lyrics in %italics_on%local%italics_off% lyric repository of: %faint_on%%LYRICS%%faint_off%"
                        rem  less_important "%Blink_on%Copying file from our %italics_on%LYRIC%italics_off% repository...%blink_off%"
                        set expanded=%@unquote[%@expand["%MAYBE_LYRICS_1_BROAD_SEARCH%"]]
                        if "%expanded%" == "%maybe_lyrics_1%" (
                                echo %ansi_color_warning_soft%%star2% Skipping %italics_on%MAYBE_LYRICS_1_BROAD_SEARCH%italics_off% because when expanded it is the same as %italics_on%MAYBE_LYRICS_1%italics_off% which is %lq%%expanded%%rq%%ansi_color_normal%
                                goto :Nevermind_about_this_1 
                        )
                        if %@CKSUM["%expanded%"] == %@CKSUM["%maybe_lyrics_1%"] (
                                echo Skipping checking maybe_lyrics_1_broad_search because expanded has same checksome as maybe_lyrics_1 which is %@CKSUM["%expanded%"] for %lq%%expanded%%rq% and %@CKSUM["%maybe_lyrics_1%"] for %lq%%maybe_lyrics_1%%rq%
                                goto :Nevermind_about_this_1
                        )

                        if "%[already_tried_potential_lyrics_%expanded%]" == "1" echo - DEBUG: not going thru whole process again because we already dealt with %expanded% !
                        if "%[already_tried_potential_lyrics_%expanded%]" == "1" goto :Nevermind_about_this_1
                        call less_important "Found possible lyrics (type 3) at %emphasis%%expanded%%deemphasis%!"
                                call less_important "Let’s review them..."
                                set  found_broad_lyrics_branch_1=1
                                *copy /Ns "%expanded%" "%TMPREVIEWFILE%" >nul
                                set already_tried_potential_lyrics_%expanded%=1
                                unset /q LYRIC_STATUS
                                gosub refresh_lyric_status "%TMPREVIEWFILE%"
                                set ONLY_ONE_FILE_AND_IT_WAS_TRIED=1
                        :Nevermind_about_this_1
                        goto :endif_1010
                :else:
                        :false_1010
                        set tmptitle=%_title
                        call bigecho %ANSI_COLOR_SUCCESS%%STAR% %underline_on%Choose %italics_on%one%italics_off%%underline_off%?:
                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[yellow]%ANSI_CURSOR_CHANGE_TO_UNDERLINE_BLINKING%   
                        rem echo         %star%%star%song is %FILE_SONG% by %FILE_ARTIST%
                        dir /b "%MAYBE_LYRICS_1_BROAD_SEARCH%" |:u8 insert-before-each-line.py "        %@REPEAT[%EMOJI_red_QUESTION_MARK,2] "
                        unset /q ANSWER
                        :Ask_Again_p_13
                        rem echo  displayaudiofilename 04
                        gosub DisplayAudioFileName
                        rem  AskYn "%underline_on%Select%underline_off% from %file_count% files, for “%italics_on%%blink_on%%FILE_SONG%%blink_off%%italics_off%” by “%italics_on%%FILE_ARTIST%%italics_off%” [I=rename as instrumental]" no %LYRIC_SELECT_FROM_FILELIST_WAIT_TIME% LI L:Mark_this_one_as_lyricLESS,I:rename_file_as_instrumental
                        call AskYn "%underline_on%Select%underline_off% from one of these %file_count% file%@IF[%file_count% gt 1,s,]? [%ansi_green%I%ansi_color_prompt%nstrum(%ansi_color_bright_green%X%ansi_color_prompt%=All),%ansi_green%P%ansi_color_prompt%=Play,%ansi_green%L%ansi_color_prompt%=Lyrics unfindable(%ansi_color_bright_green%Z%ansi_color_prompt%=all),e%ansi_color_bright_green%D%ansi_color_prompt%it names,e%ansi_color_bright_green%D%ansi_color_prompt%it names]" no %LYRIC_SELECT_FROM_FILELIST_WAIT_TIME% ADLIOPXZ L:Mark_this_one_as_lyricLESS,Z:Mark_all_as_lyricless,I:rename_file_as_instrumental,P:play_it!!!!,O:dOwnlOad_nOw_already!!,X:rename_all_songs_as_instrumental,D:edit_names,A:approve_them_Instead
                        SET OUR_LAST_ANSWER=%ANSWER%
                        rem echo GOATCHEESE001 OUR_LAST_ANSWER=“%OUR_LAST_ANSWER%”
                        rem On “A”/“D”/“I”/“L”/“P”:
                                gosub check_for_answer_of_A 
                                gosub check_for_answer_of_D
                                gosub check_for_answer_of_I
                                gosub check_for_answer_of_L
                                gosub check_for_answer_of_P
                                if  "I" == "%OUR_LAST_ANSWER%"   goto :END
                                echo GOATCHEESE007 OUR_LAST_ANSWER=“%OUR_LAST_ANSWER%”
                        rem Finishings for “L”, “O”, “P”:
                                if  "L" == "%OUR_LAST_ANSWER%"   goto /i END
                                if  "1" == "%goto_END%"          goto /i END
                                if  "O" == "%OUR_LAST_ANSWER%"   goto /i download_with_lyric_downloader_init
                                if  "P" == "%OUR_LAST_ANSWER%"   goto /i Ask_Again_p_13
                        rem On “Y/N”:
                                iff "N" == "%OUR_LAST_ANSWER%"   then
                                        call bigecho        "%NO% Skipping selecting from repository..."
                                        call less_important "%NO% Skipping selecting from repository..."
                                        gosub divider
                                        goto /i End_Of_Local_Lyric_Archive_Selection
                                endiff
                                iff "%answer%" == "Y" .or. "1" == "%RESELECT%" then
                                        unset /q reselect
                                        rem Moved this to earlier so the variable is always present: set TMPREVIEWFILE=%temp%\review-file.%_datetime.%_PID.txt
                                        rem 2025/01/17 tried to remove this: cls
                                        rem in favor of this:
                                        rem if "" == "%file_count%" set file_count=10
                                        rem set repeat_amount=%@EVAL[%file_count + 10]
                                        rem repeat %repeat_amount% echo.
                                        rem and it created screen glitches due to what @select leaves behind. So no.
                                        rem ━━━━━━━━━━━━━━━━
                                        repeat 15 echo.
                                        cls
                                        echos %@RANDFG_SOFT[]
                                        title %file_song% - %file_artist%
                                        select *copy /Ns  ("%MAYBE_LYRICS_1_BROAD_SEARCH%") "%TMPREVIEWFILE%"
                                        unset /q LYRIC_STATUS
                                        gosub refresh_lyric_status "%TMPREVIEWFILE%"
                                        rem gosub debug  "copied “%MAYBE_LYRICS_1_BROAD_SEARCH%” to sidecar location"
                                endiff
                        rem Finishings for all:
                                if "1" == "%goto_END%" goto :END
                                if ""  != "%tmptitle%" title %tmptitle%
                :endif_1010
                :done_1010
                if "1" == "%goto_END%" goto :END
        :do_not_do_block_1008
        if "1" == "%goto_END%" goto :END
        rem echo 🐐 Trace LS4 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”


rem Now we have gotten past the “Select from existing filelist” part

        rem This next if block got complicated so we broke it down:
                iff exist "%TMPREVIEWFILE%" .and. %@FILESIZE["%TMPREVIEWFILE%"] gt 0 then
                        set do_block_1088=1
                else
                        set do_block_1088=0
                endiff

        rem Now that we’ve broken it down... here we go:

        if "0" == "%do_block_1088%" goto :end_of_block_1088
                rem echo 🐐 Trace LS-B-4.1 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                if %DEBUG gt 0 (gosub debug "TMPREVIEWFILE of size %@FILESIZE[%TMPREVIEWFILE%] exists: %TMPREVIEWFILE%")
                call review-file -wh "%TMPREVIEWFILE%" "Lyrics from local repo"
                gosub divider
                rem echo displayaudiofilename 05
                gosub DisplayAudioFileName
                :ask_if_these_are_acceptible_1
                call  AskYn "These %italics_on%%underline_on%local repo%underline_off%%italics_off% lyrics good?%conceal_on%4%conceal_off%[%ANSI_GREEN%H%ANSI_COLOR_PROMPT%%connecting_equals%edit lyr,%ANSI_COLOR_PROMPT%e%ansi_color_bright_green%D%ansi_color_prompt%it band/tit,d%ansi_color_bright_green%O%ansi_color_prompt%wnload,%ANSI_GREEN%L%ANSI_COLOR_PROMPT%=%ANSI_GREEN%L%ANSI_COLOR_PROMPT%yricless,%ANSI_GREEN%I%ANSI_COLOR_PROMPT%=Instr(%ansi_color_green%X%ansi_color_prompt%=all),%ANSI_color_bright_GREEN%G%ANSI_COLOR_PROMPT%oogle,%ANSI_GREEN%P%ANSI_COLOR_PROMPT%lay%%ansi_color_prompt%]" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% ADGHILOPXZ H:Yes_but_hand-edit_1st,D:eDit_and_change_artist_or_song_name_first,O:dOwnload_now,L:Mark_as_lyricless!!!,Z:Mark_all_as_lyricless,I:Rename_as_instrumental,P:Play_it!,G:Google_for_better_lyrics,X:mark_all_as_instrumental
                echo [111] Just got back from 🌭🌭🌭🌭🌭 situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%” -- - LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” -- - LYRIC_STATUS=“%LYRIC_STATUS%” 🐐 Trace LS-B-4.2 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                gosub check_for_answer_of_L
                gosub check_for_answer_of_D_to_eset_artist_and_song
                gosub check_for_answer_of_G
                gosub check_for_answer_of_P
                gosub check_for_answer_of_R
                gosub rename_audio_file_as_instr_if_answer_was_I
                if  "O" == "%ANSWER%"                                goto /i download_with_lyric_downloader_init
                if  "1" == "%goto_download_with_lyric_downloader_1%" goto /i download_with_lyric_downloader_init
                if  "P" == "%ANSWER%"                                goto /i ask_if_these_are_acceptible_1
                if  "1" == "%GOTO_END%"                              goto /i END
                if  "1" == "%GOOGLE_NOW%"                            goto /i Google_Now
                iff "Y" == "%ANSWER%" .or. "%ANSWER%" == "H" then
                        *copy /q "%TMPREVIEWFILE%" "%LYRIC_FILE%" >nul
                        gosub edit_lyrics_now_if_we_answered_H 
                        unset /q LYRIC_STATUS
                        iff not exist "%LYRIC_FILE%" then
                                call error "LYRIC_FILE of %italics_on%%LYRIC_FILE%%italics_off% doesn’t exist and should"
                        else 
                                set LYRICS_ACCEPTABLE=1
                                set JUST_APPROVED_LYRICS=1
                        endiff
                        rem echo [3] about to call edit_lyrics_now_if_we_answered_H 🐐
                        set   DO_NOT_ASK_TO_HAND_EDIT=1

                        goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                else
                        iff "%ANSWER%" == "L" then
                                set LYRICLESSNESS_STATUS=APPROVED
                        else
                                rem echo 🐐 Trace LS-B2-4.2 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”
                                set LYRICS_ACCEPTABLE=0
                                call important_less "We have rejected this set of lyrics    %faint_on%(file_count=“%file_count%”)%faint_off%"
                                rem echo.
                                rem instead of this: goto /i End_Of_Local_Lyric_Archive_Selection
                                rem if we go back to the beginning, we can allow trying of multiple 
                                rem                                 files before finally giving up
                                rem This seemed to not workgoto: TrySelectingSomethingFromOurLyricsArchive
                                iff "1" == "%file_count%" then
                                        rem Don’t try it again. But also don’t mark it 0.n
                                else
                                        set TRY_SELECTION_AGAIN=1
                                endiff
                        endiff
                endiff
        :else:
                rem It seems we did not select/copy a file and must move on to the next step
                rem or that the file we selected is 0 bytes andn ot useful
        :endiff:
        :end_of_block_1088
        rem echo 🐐 Trace LS5-A -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, goto_end=“%goto_end%”
        if "1" != "%FORCE_REDOWNLOAD%" .and. ("1" == "%goto_END%" .or. "%LYRICLESSNESS_STATUS%" == "APPROVED") goto :END

        iff "%TRY_SELECTION_AGAIN%" == "1" then
                set TRY_SELECTION_AGAIN=2                               %+ rem Recursion stopgap
                goto /i TrySelectingSomethingFromOurLyricsArchive
        endiff
        :End_Of_Local_Lyric_Archive_Selection
        unset /q ONLY_ONE_FILE_AND_IT_WAS_TRIED
        unset /q TRY_SELECTION_AGAIN
        rem echo 🐐 Trace LS5-B -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

rem But wait! If a TXT file exists, and it  IS approved, we should continue as normal.
rem       But if a TXT file exists, and it NOT approved, we should ask before overwriting it.
rem                         It could be a hand-edited txt file that’s years old and has value.
        iff "%LYRIC_STATUS%" == "" then
                echo %ansi_color_orange%[refresh_lyric_status "%@UNQUOTE[%LYRIC_FILE%]"]%ansi_color_normal%
                gosub  refresh_lyric_status "%@UNQUOTE[%LYRIC_FILE%]"                                           
                echo %ansi_color_orange%[/refresh_lyric_status]%ansi_color_normal%
        endiff
                                                                           
        rem echo %ANSI_COLOR_DEBUG%- DEBUG: TXT_FILE=“%TXT_FILE%”,LYRIC_FILE=“%LYRIC_FILE%”[%@IF[exist "%LYRIC_FILE%",exists,does not exist]],TXT_SIDECAR_FILENAME=“%TXT_SIDECAR_FILENAME%”,LYRIC_STATUS=“%LYRIC_STATUS%”,LYRIClessness_STATUS=“%LYRIClessness_STATUS%”, last_file_to_get_lyric_status_of=“%last_file_to_get_lyric_status_of%”, goto_end="%goto_end%"
        rem pause
        set goto_end=0
        iff not exist "%LYRIC_FILE%"          goto keep_on_truckin_1295
        if "%LYRIC_STATUS%" == "APPROVED"     goto have_acceptable_lyrics_now_or_at_the_very_least_are_done
        if "%LYRIC_STATUS%" == "NOT_APPROVED" goto download_with_lyric_downloader_init
        rem At this point, the lyric_file isn’t approved or not_approved. “NOT_SET” is the technical value.
        rem Since it’s neutral——neither declared unapproved-and-replaceable nor approved-and-irreplaceable——
        rem we must ask for it’s fate. But we should default to “NO” for our answer——because it could be a
        rem previously-hand-edited file from years ago that we care about very much:
                echo %star2% %ansi_color_warning_soft%lyric_file %italics_on%already exists%italics_on% with status: %@IF["APPROVED" eq "%lyric_status%",%ansi_color_bright_green%,%ansi_color_bright_red%]%lyric_status%%ansi_color_warning_soft%: %faint_on%“%lyric_file%”%faint_off%%ansi_color_normal%
                :requestion_1347
                call AskYN "Download %blink_on%new lyrics%blink_off% %underline_on%over%underline_off% existing ones? [%ansi_color_bright_green%A%ansi_color_prompt%pprove them,%ansi_color_bright_green%I%ansi_color_prompt%nstr(%ansi_color_bright_green%X%ansi_color_prompt%=all),%ansi_color_bright_green%L%ansi_color_prompt%yricless,%ansi_color_bright_green%P%ansi_color_prompt%lay,%ansi_color_bright_green%R%ansi_color_prompt%epo-select]" no %DOWNLOAD_NEW_REPLACEMENT_LYRICS_WAIT_TIME% AILOXPS A:Approve_them_instead,I:mark_as_instrumental,X:mark_all_as_instrumentals,L:mark_lyricless,P:Preview_it,S:select_from_Repo,O:dOwnload_them_yes_indeedy!
                        rem Do instrumental marking if told to:
                                if "%ANSWER%" == "I" .or. "%ANSWER%" == "X" (
                                        gosub check_for_answer_of_I
                                        rem   TODO: consider the possibility that if we DON’T end up marking it as an instrumental after all, that maybe we should not actually abort...
                                        set   abort_karaoke_kreation=1
                                        set   goto_end=1
                                )
                        rem Completely abort on “N”:
                                if "%ANSWER%" == "N" (
                                        call AskYN "Want to try selecting from our repo again" no 30
                                        if   "Y" == "%ANSWER%" goto :select_from_repo_again
                                        set  abort_karaoke_kreation=1
                                        set  goto_end=1
                                )
                        rem On “S”, go back to selecting a file from our repo:
                                if "%ANSWER%" == "S" goto :repo_stuffs_begin
                
                        rem On “A”, approve the lyrics, then continue:
                                gosub check_for_answer_of_A
                        rem On “Y”, download new lyrics:
                                if "%ANSWER%" == "Y" .or. "%ANSWER%" == "O" (
                                        set  goto_end=0
                                        goto download_with_lyric_downloader_init
                                )
                        rem On “P”, preview:
                                gosub check_for_answer_of_P
                                if  "%answer%" == "P" (goto :requestion_1347)

                        rem On “L”, mark as lyricless:
                                if "L" == "%ANSWER%" set LYRICS_ACCEPTABLE=0
                                gosub check_for_answer_of_L
                        rem If we hit “N” / otherwise decided we’re done, let user know why:
                                echo 🐑🐑🐑 goto_end is “%goto_end%”, LYRIC_STATUS=“%LYRIC_STATUS%”
                                if "1" != "%goto_end%" .or. "APPROVED" == "%LYRIC_STATUS%" goto keep_on_truckin_1295
                                        echo %ansi_color_warning_soft%%star2% Okay then... We’re done, I guess.
                                        echo %ansi_color_warning_soft%%star2% You didn’t %italics_on%approve%italics_off% the above lyrics
                                        echo %ansi_color_warning_soft%%star2% But you %italics_on%also didn’t approve%italics_off% downloading new lyrics to overwrite them
                                        echo %ansi_color_warning_soft%%star2% We are at an impasse.
                                        rem this made doubles when called from get-lyrics-here: gosub divider
                                        goto :end
                                :keep_on_truckin_1295

                rem echo Hello McFly! if "1" == "%GOTO_END%" .or. "1" == "%ABANDONED_SEARCH%" goto :END
                if "1" == "%GOTO_END%" .or. "1" == "%ABANDONED_SEARCH%" goto /i END


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
rem Download the lyrics using LYRIC_DOWNLOADER_1: SETUP: —————————————————————————————————————————————————————————————————
rem Set the values that we will use when using LYRIC_DOWNLOADER_1 the first time [they get changed during subsequent download attempts]:
        rem Don’t go here unless we haven’t performed our first search yet; otherwise goto download_with_lyric_downloader_1 instead
        :download_with_lyric_downloader_init
                setdos /x0
                *setdos /x-9
                if "1" == "%lyric_downloader_initialized%" goto :done_with_download_with_lyric_downloader_init
                        set        FILE_SONG_TO_USE=%FILE_SONG%
                        set       FILE_TITLE_TO_USE=%FILE_SONG%          
                        set      FILE_ARTIST_TO_USE=%FILE_ARTIST%
                        set FILE_ORIG_ARTIST_TO_USE=%FILE_ORIG_ARTIST%
                        set       FILE_ALBUM_TO_USE=%FILE_ALBUM%
                        set lyric_downloader_initialized=1
                        rem gosub debug "🎨🎨🎨[40] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
        :done_with_download_with_lyric_downloader_init
        

rem Download the lyrics using LYRIC_DOWNLOADER_1: BEGIN: ——————————————————————————————————————————————————————————————————
        :download_with_lyric_downloader_1
        rem echo 🌧🌧🌧 got to %italics_on%download_with_lyric_downloader_1%italics_off% with %italics_on%FILE_SONG_TO_USE%italics_off%=“%FILE_SONG_TO_USE%” and %italics_on%FILE_ARTIST_TO_USE%italics_off%=“%FILE_ARTIST_TO_USE%”

        set current_search=%FILE_SONG_TO_USE% :::: %FILE_ARTIST_TO_USE%``
        rem echo %ANSI_COLOR_DEBUG% -DEBUG: current_search set to %ansi_color_orange%"%current_search%"%ansi_color_normal% 666
        iff "%current_search%" == "%last_search%" .and. "%FIRST_SEARCH_COMPLETE%" != "1" then
                echo %ansi_color_warning_soft%%NO% Skipping search because current_search is the same as last_search of “%LAST_SEARCH%”%ansi_color_normal%
                goto /i skip_this_search
        endiff

        set   already_searched_for_this=%[already_searched_for_%file_song_to_use%_%file_artist_to_use%]
        iff "%already_searched_for_this%" == "1" then
                echos %ansi_color_bright_red%%NO% %blink_on%Skipping%ansi_color_bright_red% search because we’ve already searched for %ansi_color_warning_soft%“%blink_on%%ansi_color_green%%file_song_to_use%%ansi_color_warning_soft%” 
                if "" != "%file_artist_to_use%" echos  %blink_on%%ansi_color_bright_red%by %ansi_color_warning_soft%“%ansi_color_green%%blink_on%%file_artist_to_use%%ansi_color_warning_soft%”%blink_off%%ansi_color_normal%
                echo.
                goto /i skip_this_search
        endiff

        rem Create a tiny file so we don’t accidentally do anything latest-file based with any pre-existing files in the folder,
        rem Because later we are doing things with the latest file, but if a failure happens, the latest file could be something
        rem already in the folder.  To prevent that, *this* will be the latest file:
                 >"__"          


        rem Allow universal override of FILE_ARTIST_TO_USE via environment variable:
                if "" != "%OVERRIDE_FILE_ARTIST_TO_USE%" set FILE_ARTIST_TO_USE=%OVERRIDE_FILE_ARTIST_TO_USE%

        rem Create our command:
                set                               LYRIC_RETRIEVAL_COMMAND=%LYRIC_DOWNLOADER_1% song "%FILE_SONG_TO_USE%" "%FILE_ARTIST_TO_USE%" --save
                rem  %ANSI_COLOR_DEBUG- COMMAND: %LYRIC_RETRIEVAL_COMMAND%%ANSI_COLOR_NORMAL%
                
                iff "1" == "%cover_original_attempt%" then
                        set blink_maybe=%blink_on%
                else                        
                        set blink_maybe=%blink_off%
                endiff

                gosub divider nonewline                                    
                rem gosub debug "🎨🎨🎨[50] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
                echos %BIG_OFF%%@ANSI_CURSOR_COLOR_BY_WORD[yellow]
                echo %BIG_OFF%%ANSI_COLOR_IMPORTANT_LESS%%STAR% Searching %italics_on%%LYRIC_DOWNLOADER_1_SOURCE%%italics_off% for %ansi_color_important%“%ansi_color_important_less%%italics_on%%FILE_SONG_TO_USE%%italics_off%%ansi_color_important%”%ansi_color_important_less%%@IF["" != "%FILE_ARTIST_TO_USE%", by ,]%ansi_color_important%%italics_off%%blink_maybe%%FILE_ARTIST_TO_USE%%blink_off%%ansi_color_important_less%...%italics_off%%ANSI_RESET%%conceal_on%[1119]%conceal_off%
                set last_search=%FILE_SONG_TO_USE% :::: %FILE_ARTIST_TO_USE%``
                set      already_searched_for_%[file_song_to_use]_%[file_artist_to_use]=1     %+ rem Attach the fact that we’ve performed a Genius search for this file temporarily to the current environemnt session                
                echo True>"%@UNQUOTE["%audio_file%"]:genius_searched_already"                 %+ rem Attach the fact that we’ve performed a Genius search for this file permanently to the file itself using ADS tag


        rem Store original environment variable value for PYTHONIOENCODING:            
                if defined PYTHONIOENCODING (set PYTHONIOENCODING_OLD=%PYTHONIOENCODING%)
                set PYTHONIOENCODING=utf-8

        rem Run our command, with a “y” answer to overwrite:
                echos %ANSI_COLOR_RUN%
                set LAST_LYRIC_RETRIEVAL_COMMAND=%LYRIC_RETRIEVAL_COMMAND%
                rem  LYRIC_RETRIEVAL_COMMAND=“%LYRIC_RETRIEVAL_COMMAND%”
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            " |:u8 copy-move-post.py whisper)    %+ rem temporarily disabling this until we get that leak fixed ... actually i don’t thik it was related to that leak but making this one moment color cycle really isn’t important
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            ")
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            " |:u8 strip-ansi |:u8 highlight "Wrote \b.*.json" |:u8 gr -v q.*].*#CF5500)
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "            " |:u8 strip-ansi |:u8 highlight       "\b.*.json" |:u8 gr -v q.*].*#CF5500) %+ rem CF5500 is just a kludge for something else   not working right at the moment
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "          "   |:u8 strip-ansi |:u8 highlight       "\b.*.json" |:u8 gr -v q.*].*#CF5500) %+ rem CF5500 is just a kludge for something else not working right at the moment and i’m not even sure if it’s still happening or not
                rem ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 insert-before-each-line.py "          "   |:u8 strip-ansi |:u8 highlight       "\b.*.json") %+ rem CF5500 is just a kludge for something else not working right at the 

*setdos /x-89
                    rem *eset LYRIC_RETRIEVAL_COMMAND
                    ((echo y | %LYRIC_RETRIEVAL_COMMAND%) |:u8 %BAT%\insert-before-each-line.py "          "   |:u8 %BAT%\strip-ansi |:u8 %BAT%\highlight       "\b.*.json") 
                    set LAST_LYRIC_RETRIEVAL_COMMAND=%LYRIC_RETRIEVAL_COMMAND%
setdos /x0

                call errorlevel "Problem retrieving lyrics in %0"
                echos %@ANSI_CURSOR_COLOR_BY_WORD[yellow]


        rem Restore original environment variable value for PYTHONIOENCODING:            
                iff   defined    PYTHONIOENCODING_OLD then
                          set    PYTHONIOENCODING=%PYTHONIOENCODING_OLD%
                else
                        unset /q PYTHONIOENCODING
                endiff

        rem Set flag:
                set FIRST_SEARCH_COMPLETE=1

        rem Get the most latest file so we can examine it to see if it’s the lyrics we just tried to download or not:
                setdos /x0
                set LATEST_FILE=%@EXECSTR[dir /b /odt |:u8 tail -1]

        rem Generate the proper post-downloader intermediate filename for our freshly-downloaded lyrics, and if it already exists, back it up:
                rem PREFERRED_LATEST_FILE_NAME=%SONG_DIR%%@NAME[%AUDIO_FILE].%@EXT[%LATEST_FILE]``
                set PREFERRED_LATEST_FILE_NAME=%SONG_DIR%%@UNQUOTE[%@NAME["%AUDIO_FILE%"].]json
                rem echo PREFERRED_LATEST_FILE_NAME is %PREFERRED_LATEST_FILE_NAME 🍕🍕🍕
                set LFEXT=%@EXT[%LATEST_FILE]`` %+ rem latest file extension
                if exist "%PREFERRED_LATEST_FILE_NAME%" .and. ("%LFEXT%" == "json" .or. "%LFEXT%" == "txt") (ren /q "%PREFERRED_LATEST_FILE_NAME%" "%PREFERRED_LATEST_FILE_NAME%.%_datetime.replaced-by-download.bak">nul)  %+ rem maintanance warning: if we ever download extensions other than JSON/TXT we need to update this
                rem pause "pause 1"
                rem echo 🐐 Trace LT1 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”

        rem See if our latest file is the expected extension [which would indicate download sucess] or not:              
                if not exist %LATEST_FILE% set MYSIZEY=0
                if     exist %LATEST_FILE% set MYSIZEY=%@FILESIZE[%LATEST_FILE]
                set  MYNAMEY=%@CAPS[%@ReReplace[_, ,%@ReReplace[lyrics_,,%@NAME[%LATEST_FILE%]]]]
                iff %MYSIZEY% gt %MOST_BYTES_THAT_LYRICS_COULD_BE% then  
                        rem echos             ``
                        rem echos %@ANSI_MOVE_TO_COL[0]       %@ANSI_MOVE_TO_COL[0]``
                        @echos %@ANSI_MOVE_TO_COL[0]               %@ANSI_MOVE_TO_COL[11]``
                        echo %ansi_color_warning%%emoji_warning% Caution! Download is %MYSIZEY%b, larger than threshold of %MOST_BYTES_THAT_LYRICS_COULD_BE%b %emoji_warning%%ansi_color_normal%
                        if 0 lt %LARGE_DOWNLOAD_WARNING_WAIT_TIME (call pause-for-x-seconds %LARGE_DOWNLOAD_WARNING_WAIT_TIME%)
                endiff
                iff "%@EXT[%LATEST_FILE]" == "%LYRIC_DOWNLOADER_1_EXPECTED_EXT%" then
                        echos %ANSI_COLOR_GREEN%%@ANSI_CURSOR_COLOR_BY_WORD[green]
                        *ren /q "%LATEST_FILE%" "%PREFERRED_LATEST_FILE_NAME%" >nul
                else
                        rem (It should be the "__" file if nothing generated)
                        rem call warning "The latest file is not a JSON? It is %LATEST_FILE% .. Does this mean lyrics didn’t download?"
                        echos %@ANSI_CURSOR_COLOR_BY_WORD[red]
                        @echos             %@ANSI_MOVE_TO_COL[0]               %@ANSI_MOVE_TO_COL[11]``
                        rem nah gosub divider
                        @call warning_soft " No lyrics downloaded%conceal_on%5%conceal_off%" silent
                        rem echo %@ANSI_CURSOR_COLOR_BY_WORD[red]%ANSI_COLOR_WARNING_SOFT%%STAR2% No lyrics downloaded%conceal_on%5%conceal_off% %ansi_color_normal%
                        rem echo dir audiofile? 🐐 %+ dir %audio_file%
                        rem Stop here if “genius” command line option was given:
                                rem Maybe don’t do this just yet.... if 1 eq %GENIUS_ONLY goto /i END

                        rem set LYRIC_RETRIEVAL_1_FAILED=1
                        rem goto /i Cleanup
                        rem Actually, just continue...We will try again with different values
                        rem No actually...skip forward,but not to cleanup
                        goto /i skip_from_nothing_downloaded
                endiff
                echos %ANSI_RESET%

        rem We are about to make a TXT file.  If it exists, better back it up first:
                if exist "%LYRIC_FILE%" (ren /q "%LYRIC_FILE" "%LYRIC_FILE%.%_datetime.replaced-by-lyrics-generated-from-karaoke.bak">nul)
                rem pause "pause 2"

        rem Create TXT file out of the JSON we downloaded, using our Perl postprocessor:
                echos %ANSI_COLOR_RUN%
                get-lyrics-with-lyricsgenius-json-processor.pl <"%PREFERRED_LATEST_FILE_NAME%" >:u8"%LYRIC_FILE%" 

                rem pause "pause 3"

        rem Delete zero-byte txt files, so that if we created an empty file, we don’t leave useless trash laying around:
                call delete-zero-byte-files *.txt silent >nul

        rem At this point, our SONG.txt should exist!  If it doesn’t, then we rejected all our downloads.
                if not exist "%LYRIC_FILE%" .or. %@FILESIZE["%LYRIC_FILE%"] eq 0 goto :then_block_1455
                                                                                 goto :else_block_1464
                        :then_block_1455
                                @echos             ``
                                @call warning "%conceal_on%Q%conceal_off% No lyrics downloaded!%conceal_on%Q%conceal_off%" silent
                                rem set LYRIC_RETRIEVAL_1_FAILED=1

                                rem At this point, if we’ve given the “genius” command-line option, we’re done. This is all we’re doing.
                                        if "1" == "%GENIUS_ONLY%" goto :END
                        goto :endif_1570
                rem else
                        :else_block_1464
                                rem pause "pause 3c"
                                rem @gosub divider
                                rem call bigecho %star% %ansi_color_bright_white%%underline_on%Downloaded lyrics%underline_off%:
                                echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[purple]%ANSI_CURSOR_CHANGE_TO_BLOCK_steady%   
                                @rem  %ANSI_COLOR_BRIGHT_YELLOW%
                                rem echo.
                                rem (type "%LYRIC_FILE%" |:u8 unique-lines -A -L) |:u8 print-with-columns
                                rem pause "pause 3c1"
                                rem echo call review-file "%LYRIC_FILE%" "Downloaded lyrics"


                                rem OLD:
                                rem call review-file -wh -st "%LYRIC_FILE%" "Downloaded lyrics"
                                rem NEW:
                                        gosub set_postprocessed_lyrics
                                        if exist "%TXT_FILE%"          call review-file -wh -st  "%TXT_FILE%"        "Lyrics"
                                        if exist "%LYRIC_FILE%"        call review-file -wh -st  "%LYRIC_FILE%"      "Lyrics"              
                                        if exist "%%PROCESSED_LYRICS%" call review-file -wh -stB "%PROCESSED_LYRICS" "Lyrics (processed)"
                                        rem xist "%SRT_FILE%"          call review-file -wh -stU "%SRT_FILE%"        "Transcription"


                                rem pause "pause 3c2"
                                @gosub divider
                                iff "%GENIUS_FILANAME%" !=  "" then
                                        set spacer=                  ``
                                else
                                        unset /q spacer
                                endiff
                                echo %ansi_color_important_less%%star% Directory is: %SPACER%%italics_on%%[_CWP]%[italics_off]
                                echo %ansi_color_important_less%%star% Filename  is: %SPACER%%ansi_color_green%%italics_on%%blink_off%%@unquote[%@NAME["%AUDIO_FILE%"]]%blink_off%.%faint_on%%@EXT["%AUDIO_FILE%"]%faint_off%%italics_off%

                                rem Display total downloaded this session:
                                        if "" == "%NUM_DOWNLOADED_THIS_SESSION%" set NUM_DOWNLOADED_THIS_SESSION=0
                                        set NUM_DOWNLOADED_THIS_SESSION=%@EVAL[%NUM_DOWNLOADED_THIS_SESSION% + 1]
                                        rem PARENT_BAT=get-lyrics at this point
                                        if %NUM_DOWNLOADED_THIS_SESSION% gt 1 echo %ANSI_COLOR_IMPORTANT%%check1% Downloaded this session: %bold_on%%NUM_DOWNLOADED_THIS_SESSION%%bold_off%%ANSI_COLOR_NORMAL%

                                        call bigecho %STAR% %ANSI_COLOR_GREEN%Downloaded: %bold_on%“%bold_off%%[blink_on]%[italics_on]%[MYNAMEY]%[italics_off]%[blink_off]%bold_on%”%bold_off%
                                        set  LYRIC_STATUS=NOT_SET

                                rem Store the Genius filename as an ADS tag, because the filename is AN AMAZINGLY GOOD SANITY CHECK for whether they were the right lyrics or not —— particularly with music you aren’t familiar with and dno’t recognize the lyrics to right away. They could be lyrics to a totally different song! You’d never know!
                                        echo %[MYNAMEY]>"%@UNQUOTE["%AUDIO_FILE%"]:genius_filename"
                                                                                           
                                rem At this point, if we’ve given the “genius” command-line option, we’re done. This is all we’re doing.
                                        if 1 eq %GENIUS_ONLY goto :END
                                        
                                :try_it_again_1220
                                rem  bigecho %ansi_color_red%%COOL_QUESTION_MARK%Are the lyrics good?%COOL_QUESTION_MARK%
                                call bigecho %ansi_color_red%%COOL_QUESTION_MARK%%ansi_color_red%Are the lyrics good for: %bold_on%“%bold_off%%ansi_color_green%%italics_on%%@IF[%UNQUOTE["%file_song_to_use%"] != "",%FILE_SONG_TO_USE%,%FILE_SONG%]%italics_off%%ansi_color_red%%bold_on%”%bold_off%%ansi_color_red%...
                                if "" != "%FILE_artist_TO_USE%" call bigecho %ansi_color_red%%COOL_QUESTION_MARK%...by %bold_on%“%bold_off%%italics_on%%ansi_color_green%%FILE_artist_TO_USE%%italics_off%%ansi_color_red%%bold_on%”%bold_off% ...
                                unset /q ANSWER
                                @call AskYn "Are they good? [D%ANSI_COLOR_PROMPT%%CONNECTING_EQUALS%e%ansi_color_bright_green%D%ansi_color_prompt%it artist/song,%ANSI_COLOR_bright_green%H%ANSI_COLOR_PROMPT%%CONNECTING_EQUALS%Hand-edit lyrics,%ANSI_COLOR_bright_green%L%ansi_color_prompt%yricless(%ansi_color_bright_green%Z%ansi_color_prompt%=all),%ANSI_COLOR_bright_green%I%ansi_color_prompt%nstrum(%ansi_color_bright_green%X%ansi_color_prompt%=All),%ANSI_COLOR_bright_green%P%ansi_color_prompt%=Play,s%ansi_color_bright_green%K%ansi_color_prompt%ip]" %DEFAULT_LYRIC_ACCEPTANCE_PROMPT_1%  %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME% DEGHILPRXZ D:Edit_artist_and_song_name,G:Google_for_some_lyrics,H:Yes_but_hand_edit_them,L:No_and_Mark_As_Lyricless,Z:Mark_all_as_lyricless,I:rename_as_instrumental,P:play_it_baby,X:mark_all_files_as_instrumental,R:rename_the_file_first,S:Skip_file
                                set hold_answer_main=%ANSWER%

                                gosub check_for_answer_of_R
                                if  "R" == "%ANSWER%"     gosub try_it_again_1220
                                if  "D" == "%ANSWER%"     gosub hand_edit_artist_and_song
                                set answer=%hold_answer_main%
                                gosub check_for_answer_of_I
                                set answer=%hold_answer_main%
                                if  "I" == "%ANSWER%"  goto  END
                                gosub check_for_answer_of_P
                                set answer=%hold_answer_main%
                                gosub check_for_answer_of_G
                                set answer=%hold_answer_main%
                                gosub check_for_answer_of_L
                                set answer=%hold_answer_main%
                                        rem echo [JGB-001] Just got back from 🍒🍒🍒🍒🍒🍒🍒 check_for_answer_of_L situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%” ... 
                                if  "1" == "%LYRIC_SUCCESS_CELEBRATION_DISPLAYED%" .or. "L" == "%ANSWER%" goto /i END
echo goatymccheese answer=“%answer%”, hold_answer_main=“%hold_answer_main%”
                                iff "Y" == "%ANSWER%" .or. "%ANSWER%" == "H" then
                                        rem oops this waqsn’t happening and it turns out we don’t need it: *del /Ns /q "%LYRIC_FILE%" >nul
                                        iff "Y" == "%ANSWER%" .and. "APPROVED" != "%LYRIC_STATUS%" then
                                                set LYRIC_STATUS=APPROVED
                                                rem echo [JGB-001-A-01] iff "Y" == "%ANSWER%" .and. "APPROVED" != "%LYRIC_STATUS%" 
                                                call  approve-lyrics "%LYRIC_FILE%" >nul
                                                gosub approve_lyrics_done
                                                rem echo [JGB-001-A-03] iff "Y" == "%ANSWER%" .and. "APPROVED" != "%LYRIC_STATUS%" 
                                        endiff
                                        gosub check_for_answer_of_H
                                        set    LYRICS_ACCEPTABLE=1
                                        set JUST_APPROVED_LYRICS=1
                                        set DO_NOT_ASK_TO_HAND_EDIT=1
                                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[green]
                                        goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                                endiff
                                iff "N" == "%ANSWER%" .or. "L" == "%ANSWER%" then
                                        rem Continue on but delete the file to indicate its rejection
                                        set LYRICS_ACCEPTABLE=0

                                        rem This section is redundant because it gets replaced anyway...
                                        rem iff exist "%LYRIC_FILE%" then
                                        rem         set hold_my_answer_for_me=%answer%
                                        rem         call askyn "Remove the lyric file? [or %ansi_color_bright_green%A%ansi_color_prompt%pprove it]" no 600 A A:approve_it
                                        rem         if "A" == "%ANSWER%" goto /i have_acceptable_lyrics_now_or_at_the_very_least_are_done
                                        rem         if "Y" == "%ANSWER%" ren  /q "%LYRIC_FILE%" "%LYRIC_FILE%.%_datetime.MAKE_THIS_BE_A_REASON.bak"
                                        rem         set answer=%hold_my_answer_for_me%
                                        rem endiff
                                endiff                                
                                iff "%ANSWER%" == "H" then                        
                                        rem gosub debug "You hit h (#1) . Rejecting hand editing question and going straight to hand editing"
                                        rem gosub debug "Setting FORCE_HAND_EDIT=1 .... instance #3"
                                        set FORCE_HAND_EDIT=1
                                        goto /i hand_edit_lyrics_right_now_without_asking
                                else                                
                                        set DO_NOT_ASK_TO_HAND_EDIT=1
                                endiff
                                if  "P" == "%ANSWER%"     (goto /i try_it_again_1220)
                                if  "1" == "%GOOGLE_NOW%" (goto /i Google_Now       )
                                if  "1" == "%GOTO_END%"   (goto /i END              )
                        goto :endif_1570
                rem endiff
                :endif_1570

                rem Debug:
                        rem pause "pause 4"
                        rem echo 🐐 Trace LT2 -- LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”, answer=“%ANSWER%”, JUST_APPROVED_LYRICS=“%JUST_APPROVED_LYRICS%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”
                
                rem Redundant?
                        if "1" == "%JUST_APPROVED_INSTRUMENTAL%" goto /i END
                        if "1" == "%JUST_APPROVED_LYRICS%" .and. "Y" == "%ANSWER%" goto have_acceptable_lyrics_now_or_at_the_very_least_are_done


                :end_of_massage_attempt
                :skip_from_nothing_downloaded


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


rem Get massaged names for next section’s check:
        :skip_this_search
        :massage_the_probe_info
        rem Massage some problematic subsets of these fields:
        rem 1) Remove things in parenthesis
        rem 2) remove "The "
                rem Let’s test with functions!
                rem function massageLyricGetValueOLD=`%@ReReplace["\([^\)]*\)",,%@ReReplace[^The ,,%1$]]`

                rem TODO                 *setdos /x-8-5   ???????

                function massageLyricGetValue=`%@ReReplace[^.*My Little Pony.*$,My Little Pony,%@ReReplace["[\(\[][^\)\]]*[\)\]]",,%@ReReplace[^The ,,%1$]]]`

                rem      FILE_ARTIST_MASSAGED=%@UNQUOTE[%@ReReplace[ & h[ie][sr] orche?s?t?r?a?,,%@ReReplace[ minus .*$,,%@ReReplace[:.*$,,%@massageLyricGetValue["%FILE_ARTIST%"]]]]]
                set      FILE_ARTIST_MASSAGED=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%@ReReplace[[ \-]+$,,%@ReReplace[^[Tt][Hh][Ee] ,,%@ReReplace[❟* *with .*,,%@ReReplace[ & .*,,%@ReReplace[ minus .*$,,%@ReReplace[:.*$,,%@massageLyricGetValue["%FILE_ARTIST%"]]]]]]]]]
                set FILE_ORIG_ARTIST_MASSAGED=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%@massageLyricGetValue["%FILE_ORIG_ARTIST%"]]]
                set       FILE_ALBUM_MASSAGED=%@UNQUOTE[%@massageLyricGetValue["%FILE_ALBUM%"]]
                set        FILE_SONG_MASSAGED=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%@ReReplace[.* [\/]  ,,%@ReReplace[ *[oc][pl][eo][ns]e?ing theme,,%@ReReplace[ aka .*$,,%@UNQUOTE["%@massageLyricGetValue["%FILE_SONG%"]"]]]]]]
                set       FILE_TITLE_MASSAGED=%FILE_SONG_MASSAGED%
                
                rem gosub debug "(13) Massaged: %TAB%   artist=%italics_on%%FILE_ARTIST_MASSAGED%=%italics_off%%newline%%TAB%%tab%%tab%%tab%         title=%italics_on%%FILE_SONG_MASSAGED%=%italics_off%%newline%%TAB%%tab%%tab%%tab%         album=%italics_on%%FILE_album_MASSAGED%=%italics_off%"


rem try again if massaged names exist (that is, if the massaged names are different than the original names):        
        if 1 eq LD1_MASSAGED_ATTEMPT_1 (goto :Already_Did_Massaged)
        iff "%FILE_SONG_MASSAGED%" == "" .and. "%FILE_ARTIST_MASSAGED%" == "" then
                echo %ANSI_COLOR_WARNING_SOFT%%STAR% Couldn’t get file *AND* artist! %ANSI_COLOR_NORMAL%
                goto /i skip_for_empty_filename_and_artist
        endiff
        
        rem echo iff "1" != "%LD1_MASSAGED_ATTEMPT_1%" .and. ("%FILE_SONG_MASSAGED%" != "%FILE_SONG%" .or. "%FILE_artist_MASSAGED%" != "%FILE_artist%" .or. "%FILE_ORIG_ARTIST_MASSAGED%" != "%FILE_ORIG_ARTIST%") then %+ pause
        iff "1" != "%LD1_MASSAGED_ATTEMPT_1%" .and. ("%FILE_SONG_MASSAGED%" != "%FILE_SONG%" .or. "%FILE_artist_MASSAGED%" != "%FILE_artist%" .or. "%FILE_ORIG_ARTIST_MASSAGED%" != "%FILE_ORIG_ARTIST%") then 
                gosub divider
                set suppress_next_divider=1
                rem            %ANSI_COLOR_WARNING_SOFT%%STAR%  Let’s try downloading with the massaged names (%ansi_color_bright_green%%italics_on%%FILE_ARTIST_MASSAGED%%italics_off%%ansi_reset% - %ansi_color_bright_cyan%%italics_on%%FILE_SONG_MASSAGED%%italics_off%%ANSI_COLOR_WARNING_SOFT%)...%ANSI_RESET% %STAR%
                echo %ANSI_COLOR_WARNING_SOFT%%STAR% Let’s try downloading with the massaged names (%ansi_color_bright_green%%italics_on%%FILE_ARTIST_MASSAGED%%italics_off%%ansi_reset% - %ansi_color_bright_cyan%%italics_on%%FILE_SONG_MASSAGED%%italics_off%%ANSI_COLOR_WARNING_SOFT%)...%ANSI_RESET% %STAR%
                if 0 lt %WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH (call pause-for-x-seconds %WAIT_AFTER_ANNOUNCING_MASSAGED_SEARCH%)
                set FILE_SONG_TO_USE=%FILE_SONG_MASSAGED%
                set FILE_ARTIST_TO_USE=%FILE_ARTIST_MASSAGED%
                *setdos /x-8-5
                set FILE_ARTIST_TO_USE=%@ReReplace[^[Tt][Hh][Ee] ,,%@UNQUOTE[%FILE_ARTIST_TO_USE%]]
                setdos /x0
                rem gosub debug "🎨🎨🎨[10] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
                set LD1_MASSAGED_ATTEMPT_1=1
                goto /i download_with_lyric_downloader_init
        endiff
        :Already_Did_Massaged
        if exist "%LYRIC_FILE" (ren /q "%LYRIC_FILE" "%LYRIC_FILE%.%_datetime.failed-lyric-search.bak">nul)
        rem gosub divider
        rem Continue on... We have failed so far.  (DON’T do this here: goto :end_of_massage_attempt)
        unset /q LD1_MASSAGED_ATTEMPT_1
        rem echo 🐐 Trace LT3 -- LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem If we’ve still failed, and it’s a cover song, let’s try with the original artist:
        iff %cover_original_attempt% eq 1 then
                rem Skip it if we already attempted this
        elseiff 1 eq %IS_POTENTIALLY_COVER_SONG%  then
                rem 1ˢᵗ we started with original, so if that fails we’d try initial: set FILE_ARTIST_TO_USE=%FILE_ARTIST_INITIAL%
                rem 2ⁿᵈ we started with  initial, so if that fails we’d try original...
                set FILE_ARTIST_TO_USE=%FILE_ORIG_ARTIST%
                set cover_original_attempt=1
                rem gosub debug "🎨🎨🎨[20] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
                goto /i download_with_lyric_downloader_init
        endiff                
        
rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem If we’ve still failed, and the artist has “feat” like “Michael Jacksonfeat Metallica”, strip and try again:
        if "" == "%FILE_ARTIST_TO_USE%" goto :feat_stuff_done
                iff 1 eq %@Regex[ feat\.? ,"%FILE_ARTIST_TO_USE%"] then
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: “Feat\.” is in the %italics_on%FILE_ARTIST_TO_USE%italics_off% of “%FILE_ARTIST_TO_USE%”
                        set  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[ feat\.? .*$,,"%FILE_ARTIST_TO_USE%"]]
                        set  varname=already_tried_featured_with_%file_artist_to_use%
                        set  already_tried_featured_for_this_one=%[%VARNAME%]
                        iff "%already_tried_featured_for_this_one%" != "1" then
                                rem echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried de-feat.-ing this one                        
                                set  %VARNAME%=1
                                goto /i download_with_lyric_downloader_init
                        else
                                rem echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried de-feat.-ing this one                        
                        endiff
                else
                        rem echo featured no!
                endiff
        :feat_stuff_done        

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem If we’ve still failed, and the artist has “The” at the beginning, strip and try again:
        if "" == "%FILE_ARTIST_TO_USE%" goto :the_stuff_done
        *setdos /x-5
        rem echo 🐐 file_artist_to_use is “%file_artist_to_use%”
        set REGEX_VALUE="%@RegEx[^THE,%@UPPER[%file_artist_to_use%]]"  
        rem echo    [DE-THE] REGEX_VALUE=“%REGEX_VALUE%”
        rem echo    [DE-THE] if "0" eq"%%@RegEx[^THE ,%@UPPER[%file_artist_to_use%]]" goto the_stuff_done 
        rem echo    [DE-THE] if "0" eq "%@RegEx[^THE ,%@UPPER[%file_artist_to_use%]]" goto the_stuff_done 
        if          "0" eq "%@RegEx[^THE ,%@UPPER[%file_artist_to_use%]]" goto :the_stuff_done
                rem echo %ANSI_COLOR_DEBUG%- DEBUG: “The ” is in the %italics_on%FILE_ARTIST_TO_USE%italics_off% of “%FILE_ARTIST_TO_USE%”
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[^The ,,"%FILE_ARTIST_TO_USE%"]]
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[[Tt][Hh][Ee] ,,"%FILE_ARTIST_TO_USE%"]] didn’t work
                set  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[^[Tt][Hh][Ee] ,,%FILE_ARTIST_TO_USE%]]
                set  varname=already_tried_the_with_%file_artist_to_use%
                set   already_tried_the_for_this_one=%[%VARNAME%]
                iff "%already_tried_the_for_this_one%" != "1" then
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried de-The-ing this one %dash% this is the first one
                        set  %VARNAME%=1
                        goto /i download_with_lyric_downloader_init
                else
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried de-The-ing this one, so we won’t try again
                endiff
        :the_stuff_done

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━——————————————————

rem If we’ve still failed, and the artist has “ @ ” in it, it’s probably a badly named live track i.e. “For Whom The Bell Tolls @ RFK Stadium”:

        if "" == "%FILE_ARTIST_TO_USE%" goto at_stuff_done
        *setdos /x-5
        rem echo 🐐 file_artist_to_use is “%file_artist_to_use%”
        if "0" eq "%@RegEx[ @ ,%@UPPER[%file_artist_to_use%]]" goto :at_stuff_done
                rem echo %ANSI_COLOR_DEBUG%- DEBUG: “ @ ” is in the %italics_on%FILE_ARTIST_TO_USE%italics_off% of “%FILE_ARTIST_TO_USE%”
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[^The ,,"%FILE_ARTIST_TO_USE%"]]
                rem  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[[Tt][Hh][Ee] ,,"%FILE_ARTIST_TO_USE%"]] didn’t work
                set  FILE_ARTIST_TO_USE=%@UNQUOTE[%@ReReplace[ \@ .*$,,%FILE_ARTIST_TO_USE%]]
                rem echo %ANSI_COLOR_DEBUG%- DEBUG: “ @ ” remove attemped: %italics_n%FILE_ARTIST_TO_USE%italics_off%=“%FILE_ARTIST_TO_USE%”
                set  varname=already_tried_at_with_%file_artist_to_use%
                set   already_tried_at_for_this_one=%[%VARNAME%]
                iff "%already_tried_at_for_this_one%" != "1" then
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried de-@-ing this one %dash% this is the first one
                        set  %VARNAME%=1
                        goto /i download_with_lyric_downloader_init
                else
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried de-@-ing this one, so we won’t try again
                endiff
        :at_stuff_done

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem Still nothing? Let’s try removing the band name altogether (de-band-name’ing)...  [less annoying for vintage than modern stuff it seems]

        if "" == "%FILE_ARTIST_TO_USE%" goto noband_stuff_done
                *setdos /x-5
                rem echos 🐐 file_artist_to_use was “%file_artist_to_use%”
                unset /q file_artist_to_use
                rem echo  but is now “%file_artist_to_use%”
                iff "%debanded%" != "1" then
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: We have not tried no-band-ing this one %dash% this is the first one [varname=%varname%] [file_artist=“%file_artist%”]
                        set  debanded=1
                        goto /i download_with_lyric_downloader_init
                else
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: We’ve already tried no-band-ing this one, so we won’t try again [varname=%varname%]  [file_artist=“%file_artist%”]
                endiff
        :noband_stuff_done


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem At this point, if we’ve given the “genius” command-line option, we’re done. This is all we’re doing.        //20250307 moved this one block up

        if 1 eq %GENIUS_ONLY% goto :END
        if 1 eq %GOTO_END%    goto :END

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━——————————————————

rem If we *do* have a downloaded file, we’re at the very least ready to proceed to the post-lyrics section:

        :skip_for_empty_filename_and_artist
        iff exist "%LYRIC_FILE%" (goto have_acceptable_lyrics_now_or_at_the_very_least_are_done)


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem If we still don’t have a downloaded file, let us manually edit the song and artist name if we want

        rem 🌈 Q: rainbow divider here? A: No, it already happens. .... No it doesn’t???? Not always??? Not if this is the 1ˢᵗ attempt, anyway....
        if 1 eq %GENIUS_ONLY  (goto :Skip_Hand_Editing)
        gosub divider 
        rem echo %ANSI_COLOR_UNIMPORTANT%- DEBUG: Initial LYRICLESSNESS_STATUS IS “%LYRICLESSNESS_STATUS%”
        iff "%LYRICLESSNESS_STATUS%" == "APPROVED" .and. "1" != "%FORCE_REGEN%" then
                echo *** Lyriclessness status is “%LYRICLESSNESS_STATUS%”, so we are aborting ***       
                goto /i END
        endiff
        :requestion_1325
        unset /q answer
        rem echo 🐐 %%_CWP is “%_CWP”
        unset /q GOOGLE_NOW
        call AskYN "Change artist/song? (%ansi_green%L%ansi_color_prompt%=Lyricless(%ansi_color_bright_green%Z%ansi_color_prompt%=All),%ansi_green%N%ansi_color_prompt%=ai %italics_on%%ansi_green%N%ansi_color_prompt%ow%italics_off%,G=%ansi_green%G%ansi_color_prompt%oogle,%ansi_color_bright_green%A%ansi_color_prompt%pprove lyrics,%ansi_green%I%ansi_color_prompt%nstr(%ansi_green%X%ansi_color_prompt%=ALL),%ansi_green%P%ansi_color_prompt%lay)" no %HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME% ADGILNOPRXZ L:Mark_As_Lyricless,Z:Mark_all_as_lyricless,N:AI_encode_NOW_without_lyrics,G:Google_for_the_lyrics,A:the_lyrics_are_good_actually!,I:rename_it_as_an_instrumental_file,P:play_the_file,X:Mark_all_songs_in_folder_as_instrumental,O:download_lyrics_with_genius,D:eDit_and_change_song_title_and_artist,R:rename_file
                rem “G”:
                        gosub check_for_answer_of_G
                        if "1" == "%GOOGLE_NOW%" goto Google_Now
                rem “R”:
                        gosub check_for_answer_of_R
                        if  "%answer%" == "R" (goto :requestion_1325)
                rem “P”:
                        gosub check_for_answer_of_P
                        if  "%answer%" == "P" (goto :requestion_1325)
                rem “Y”/“N” answers:
                        if "N" == "%ANSWER%"                        goto  did_not_want_to_change_artist_song
                        if "Y" == "%ANSWER%" .or. "D" == "%ANSWER%" gosub eset_fileartist_and_filesong
                        if "Y" == "%ANSWER%" .or. "D" == "%ANSWER%" goto  download_with_lyric_downloader_init
                rem “A” for “approve lyrics because I forgot/wasn’t around to say ‘Y’ for the previous [a]pproval prompt”
                        rem echo - DEBUG: answer was “%ANSWER%” [0i94239023], 
                        gosub check_for_answer_of_A 
                        rem iff "%answer%" == "A" then
                        rem         set   LYRICS_ACCEPTABLE=1
                        rem         echo REM call  approve-lyrics "%LYRIC_FILE%" in %_CWP ... this seems to be a problem sometimes and why?
                        rem         call  approve-lyrics "%LYRIC_FILE%" >nul
                        rem         gosub approve_lyrics_done
                        rem endiff
                        if  "%answer%" == "A" goto  have_acceptable_lyrics_now_or_at_the_very_least_are_done
                rem “L”:
                        if "L" == "%ANSWER%" set LYRICS_ACCEPTABLE=0
                        gosub check_for_answer_of_L
                        if "1" == "%goto_END%"         goto :END
                        if "1" == "%ABANDONED_SEARCH%" goto :END
                rem “O/X/I”:
                        gosub check_for_answer_of_O
                        if "%ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" goto :download_with_lyric_downloader_init


                        gosub check_for_answer_of_X
                        if  "%answer%" == "N" (goto :Skip_Hand_Editing)


                        gosub rename_audio_file_as_instr_if_answer_was_I
                        if "%goto_end%" == "1" goto :end

                rem echo Just got back from 🌶🌶 🌶🌶 🦆🦆 🦆🦆 situation and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%”
                rem 2025/02/15 adding answer==L to this one to fix infinite loop bug:                                                
                iff "%answer%" == "L" then
                        set SOLELY_BY_AI=1
                        rem TODO: right now, if you are ONLY getting lyrics, and you answer "A" for 
                        rem               for "AI encode now", you just end up back at the prompt. 
                        rem       This is technically correct, but it’s a bit jarring to tell it 
                        rem               to do something and have it do nothing!
                        iff "%PARENT_BAT%" != "create-srt-from-file" then
                                echo.
                                call warning_soft "I know you said to AI encode now... But you need to be running the get-karaoke commands to do that, and you’re just running get-lyric commands"
                                call warning_soft "The %italics_on%PARENT_BAT%italics_off% var is set to “%PARENT_BAT%”"
                                call warning_soft "Okay... Let’s try calling create-srt from get-lyrics and see how that plays out... beta idea!"
                                set FORCE_AI_ENCODE_FROM_LYRIC_GET=1
                                call create-srt-from-file "%AUDIO_FILE%"
                                set  GOTO_END_AFTER_GET_LYRICS_CALLED=1
                        endiff
                        goto :END
                else
                        echo ----`>` Answer is not A! >nul
                endiff
                if "1" eq "%goto_END%" (goto :END)

        rem 🤔 remind us of filename
        rem echo [GL] by the wayyyyyyyyy. lyriclessness status is “%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%” ******************************************************************
        if "" == "%LYRICLESSNESS_STATUS%" set LYRICLESSNESS_STATUS=%@ExecStr[TYPE "%@UNQUOTE["%AUDIO_FILE%"]:lyriclessness" >&>nul]         %+ rem get the song’s lyriclessness approval status
        rem echo [GL] by the woooooooooo. lyriclessness status is “%LYRICLESSNESS_STATUS%”, LYRIC_STATUS=“%LYRIC_STATUS%”  ******************************************************************
        if "%LYRICLESSNESS_STATUS%" == "APPROVED" .or. "%LYRIC_STATUS%" == "APPROVED" .or. "1" == "%LYRIC_SUCCESS_CELEBRATION_DISPLAYED%" goto :Skip_Hand_Editing

                echo %ansi_color_important_less%%star% Directory: %italics_on%%[_CWP]%[italics_off]
                echo %ansi_color_important_less%%star% Filename:  %italics_on%%@NAME[%AUDIO_FILE]%italics_off%

        :hand_edit_artist_and_song
        rem echo Trace about to eset_fileartist_and_filesong 🥩 🥩 🥩🥩 🥩🥩🥩
        gosub eset_fileartist_and_filesong
        goto  download_with_lyric_downloader_init
        :Skip_Hand_Editing
        :end_of_lyric_downloader_1
        :did_not_want_to_change_artist_song
rem Download the lyrics using LYRIC_DOWNLOADER_1: END: —————————————————————————————————————————————————————————————————————————————————————


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━


rem Ask to Google the lyrics if we haven’t approved them yet:
        :ask_to_hand_edit_lyrics
        rem Nah? I think nah (2024/12/10): gosub divider
        iff "1" == "%GENIUS_ONLY%" .or. "%LYRICLESSNESS_STATUS%" == "APPROVED" .or. "%LYRIC_STATUS%" == "APPROVED" then
                goto /i skip_all_the_googling
        endiff

        :askyn_2186
        call AskYN "%[italics_on]Google%[italics_off] for some lyrics (%ansi_color_bright_green%L%ansi_color_prompt%=Lyricless[%ansi_color_bright_green%Z%ansi_color_prompt%=All],e=e%ansi_color_bright_green%D%ansi_color_prompt%it names)" no %GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME% DILPZ L:Mark_this_as_lyricless_insteaed,Z:Mark_all_as_lyricless,I:No_just_mark_it_as_instrumental,D:edit_song_and_artist,P:play
        rem echo Just got back from 🚩🚩🚩 situation 🚩 and the answer is still “%ANSWER%” and goto_end is “%GOTO_END%”
        if "N" == "%ANSWER%"  goto /i END
        gosub check_for_answer_of_P
        gosub check_for_answer_of_A 
        gosub check_for_answer_of_I
        gosub check_for_answer_of_L        
        rem iff "%answer%" == "A" then
        rem         set LYRICS_ACCEPTABLE=1
        rem         call  approve-lyrics "%LYRIC_FILE%" >nul
        rem         gosub approve_lyrics_done
        rem         goto /i  have_acceptable_lyrics_now_or_at_the_very_least_are_done
        rem endiff
        if "P" == "%ANSWER%"                                gosub askyn_2186
        if "D" == "%ANSWER%"                                gosub eset_fileartist_and_filesong
        if "D" == "%ANSWER%"                                goto  download_with_lyric_downloader_1
        if "1" == "%goto_download_with_lyric_downloader_1%" goto  download_with_lyric_downloader_1
        if "1" == "%goto_END%"                              goto  END

        :Google_Now
        iff "%answer%" == "Y" .or. "1" == "%GOOGLE_NOW%" then
                set      FILE_ARTIST_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_ARTIST_INITIAL%"]"]]
                set FILE_ORIG_ARTIST_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_ORIG_ARTIST_INITIAL%"]"]]
                set        FILE_SONG_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_SONG_INITIAL%"]"]]
                set       FILE_ALBUM_INITIAL_FOR_GOOGLE=%@UNQUOTE[%@ReReplace[ *\(live\).*$,,"%@ReReplace[[\+\?&],,"%FILE_ALBUM_INITIAL%"]"]]
                
                rem These are original values:
                        rem Lived experience says either search is insufficient; we need both:
                          google.py "%FILE_ARTIST_INITIAL_FOR_GOOGLE%" "%FILE_SONG_INITIAL_FOR_GOOGLE%" +lyrics                    
                          google.py  %FILE_ARTIST_INITIAL_FOR_GOOGLE%   %FILE_SONG_INITIAL_FOR_GOOGLE%   lyrics                    
                          iff 1 eq %cover_original_attempt% then
                                  google.py "%FILE_ORIG_ARTIST_INITIAL%"       "%FILE_SONG_INITIAL_FOR_GOOGLE%" +lyrics                    
                                  google.py  %FILE_ORIG_ARTIST_INITIAL%         %FILE_SONG_INITIAL_FOR_GOOGLE%   lyrics                    
                          endiff
                          
                rem Track that we have googled:
                        set WE_GOOGLED=1
                        rem gosub debug "Setting FORCE_HAND_EDIT=1 .... instance #1"
                        set FORCE_HAND_EDIT=1
                        
                rem Increase wait time if we googled:
                        set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=%@EVAL[%HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME + %ADDITIONAL_HAND_EDIT_WAIT_TIME_IF_THEY_GOOGLED%]

                goto /i post_googling_for_lyrics_point
        else
                rem Track that we have not googled:
                        set WE_GOOGLED=0
        endiff
        :skip_all_the_googling


rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━


:have_acceptable_lyrics_now_or_at_the_very_least_are_done

rem echo 🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂 Have_acceptable_lyrics_now_or_at_the_very_least_are_done 🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂🎂 LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%” >nul


echos %ANSI_CURSOR_CHANGE_TO_underline_BLINKING%                                                        %+ rem Update cursor


rem echo 🐐 checking[K] iff 1 eq LYRICS_ACCEPTABLE=%LYRICS_ACCEPTABLE .or. 1 eq LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED=%LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED then ..... LYRIC_STATUS=“%LYRIC_STATUS%”
iff "0" == "%LYRICS_ACCEPTABLE%" .and. "1" != "%LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED%" then
        gosub ask_about_instrumental
        echo something should be done here? but what?
        echo let’s go back to the start maybe?
                goto /i actual_alignment_begins
        pause
endiff
iff "1" == "%LYRICS_ACCEPTABLE%"  .or. "1" == "%LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED%" then
        rem echo 🐐 inside first if -         iff exist "%LYRIC_FILE%" .and. "1" == JUST_APPROVED_LYRICS="%JUST_APPROVED_LYRICS%" then
        iff exist "%LYRIC_FILE%" .and. "1" == "%JUST_APPROVED_LYRICS%" then
                if "" == "%LYRIC_STATUS%" gosub refresh_lyric_status

                iff "%LYRIC_STATUS%" != "APPROVED" then
                        rem echo 🐐 inside first third if
                        echo %check% %ansi_color_success%Approving lyrics...%ansi_color_normal% %conceal_on%ABC%conceal_off%
                        set LYRICS_ACCEPTABLE=1
                        set LYRIC_STATUS=APPROVED
                        call  approve-lyrics "%LYRIC_FILE%" >nul
                        gosub approve_lyrics_done
               iff ("1" != "%LYRICS_FETCHED%" .and. "1" != "%JUST_APPROVED_LYRICS%" .and. "1" != "%LYRICS_ACCEPTABLE%") .or. ("1" == "%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED") then
                        set LYRIC_STATUS=APPROVED
                        rem why??? set HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME=8 %+ rem 🐮 hard-coded value warning
                endiff                                     
        else
                set LYRIC_STATUS=NOT_APPROVED
        endiff
                
        iff exist "%LRC_SIDECAR_FILENAME%" then
                set LYRIC_STATUS_BACKUP=%LYRIC_STATUS%
                rem do not gosub refresh_lyric_status here because it assumes LYRIC_FILE
                call get-lyric-status "%LRC_SIDECAR_FILENAME%" silent
                iff "%LYRIC_STATUS%" != "APPROVED" then
                        echo %check% %ansi_color_success%Approving LRC file...%ansi_color_normal% %conceal_on%GHI%conceal_off%
                        set   LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
                        call  approve-lyrics "%LRC_SIDECAR_FILENAME%" >nul
                        gosub approve_lyrics_done
                endiff
                set LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
        endiff                

        iff exist "%SRT_SIDECAR_FILENAME%" then
                set LYRIC_STATUS_BACKUP=%LYRIC_STATUS%
                rem do not gosub refresh_lyric_status here because it assumes LYRIC_FILE
                call get-lyric-status "%SRT_SIDECAR_FILENAME%" silent
                iff "%LYRIC_STATUS%" != "APPROVED" then
                        echo %check% %ansi_color_success%Approving SRT file...%ansi_color_normal%
                        set   LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
                        call  approve-lyrics "%SRT_SIDECAR_FILENAME%" >nul
                        gosub approve_lyrics_done
                endiff
                set LYRIC_STATUS=%LYRIC_STATUS_BACKUP%
        endiff                
endiff
rem echo     ...we’re done with that if...

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem Final chance to hand edit the lyrics, but skip it if we already opted to search Google to save us the hassle:
        rem i THINK this is where to put this:
                :post_googling_for_lyrics_point

        rem Decide whether we are even asking:
                rem DEBUG:  echo DO_NOT_ASK_TO_HAND_EDIT=%DO_NOT_ASK_TO_HAND_EDIT% ... ALREADY_HAND_EDITED=%ALREADY_HAND_EDITED%, WE_GOOGLED=%WE_GOOGLED, AUTOMATIC_HAND_EDITING_IF_GOOGLING=%AUTOMATIC_HAND_EDITING_IF_GOOGLING, FORCE_HAND_EDIT=%FORCE_HAND_EDIT% 
                if "1" == "%FORCE_HAND_EDIT%"                                                (goto :hand_edit_lyrics_right_now_without_asking)
                if "1" == "%WE_GOOGLED%" .and. "%AUTOMATIC_HAND_EDITING_IF_GOOGLING%" == "1" (goto :hand_edit_lyrics_right_now_without_asking)
                if "1" == "%DO_NOT_ASK_TO_HAND_EDIT%" .or. "1" == "%ALREADY_HAND_EDITED%"    (goto :reject_hand_editing_question_entirely)
                
        rem Ask if we are supposed to:   
                unset /q answer
                rem echo 🌴 iff "1" != GENIUS_ONLY="%GENIUS_ONLY%" .and. "1" != ALREADY_HAND_EDITED="%ALREADY_HAND_EDITED%" then and. LYRICLESSNESS_STATUS="%LYRICLESSNESS_STATUS%" != "APPROVED" then         🐐
                if "1" == "%FORCE_REGEN%" goto /i :goto_from_2338
                iff "1" != "%GENIUS_ONLY%" .and. "1" != "%ALREADY_HAND_EDITED%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED" then         
                        call AskYN "Hand-edit our%conceal_on%H%conceal_off%lyrics" no %HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME%
                endiff
                
        rem Do the hand-editing, if we have decided to:                
                :hand_edit_lyrics_right_now_without_asking
                iff "%answer%" == "Y" .or. "1" == "%FORCE_HAND_EDIT%" .or. ("%WE_GOOGLED%" == "1" .and. "%AUTOMATIC_HAND_EDITING_IF_GOOGLING%" == "1") then
                        set do_next_block=1
                else
                        set do_next_block=0
                endiff

                if "0" == "%DO_NEXT_BLOCK%" goto :skip_from_2159
                        rem Create 0-byte file for us to edit:
                                if not exist "%LYRIC_FILE%" >:u8"%LYRIC_FILE%"

                        rem Edit the file if we have decided to....
                                rem echo [4] about to call edit_lyrics_now_if_we_answered_H 🐐 ... answer=“%ANSWER%”
                                gosub edit_lyrics_now_if_we_answered_H Y force
        
                        if not exist "%LYRIC_FILE%" goto :lyric_file_does_not_exist_at_2167ish
                                :recheck_post_hand_edited_lyrics                                                                                                
                                call review-file -wh "%LYRIC_FILE%" "%italics_on%Post%italics_off%-hand-edited lyrics"                        
                                gosub divider                
                                call AskYn "Are the post-hand-edited lyrics now acceptable? [%ansi_color_bright_green%P%ansi_color_prompt%=play,%ansi_color_bright_green%H%ansi_color_prompt%=edit again,%ansi_color_bright_green%R%ansi_color_prompt%ename]" yes %HAND_EDIT_ARTIST_AND_SONG_AND_LYRICS_PROMPT_WAIT_TIME% HLPR P:play_file,H:hand_edit_again,L:mark_lyricless_actually,R:rename
                                     rem echo GOAT001 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     gosub check_for_answer_of_R
                                     gosub check_for_answer_of_L
                                     gosub check_for_answer_of_P
                                     rem oops totesmcgoates gosub check_for_answer_of_H
                                     rem oops totesmcgoates if "%answer%" == "H" goto recheck_post_hand_edited_lyrics
                                     if "%answer%" == "P" goto recheck_post_hand_edited_lyrics
                                     if "%answer%" == "R" goto recheck_post_hand_edited_lyrics
                                     if "%answer%" == "N" set  LYRICS_ACCEPTABLE=0
                                     if "%answer%" == "N" set  LYRIC_STATUS=NOT APPROVED
                                     if "%answer%" == "N" set  goto_end=0
                                     rem echo GOAT002 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     rem   nswer%" == "Y" .and. "%LYRIC_STATUS%" !=  "APPROVED" (call approve-lyrics  "%LYRIC_FILE%" %+ call display-lyric-status  "%LYRIC_FILE%")
                                     if "%answer%" == "Y" .and. "%LYRIC_STATUS%" !=  "APPROVED" (call approve-lyrics  "%LYRIC_FILE%" )
                                     rem echo GOAT003 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     if "%answer%" == "Y" gosub approve_lyrics_done
                                     rem echo GOAT004 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     if "%answer%" == "Y" set goto_end=1
                                     rem echo GOAT005 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                                     if "%answer%" == "Y" goto /i END
                                     rem echo GOAT006 we got the post-hand-edited answer of ANSWER=“%ANSWER%”
                        :lyric_file_does_not_exist_at_2167ish
                        echo 🐐 okay right here[19Y], LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” ... goto_end=“%goto_end%”
                        if "Y" == "%answer%"   goto :END
                        if "1" == "%goto_end%" goto :END
                :skip_from_2159

                rem echo 🐐 okay right here[19Z], LYRIC_STATUS=“%LYRIC_STATUS%”, LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%” ... goto_end=“%goto_end%”
                if "Y" == "%answer%"   goto :END
                if "1" == "%goto_end%" goto :END
                rem if     exist "%LYRIC_FILE%" echo %@randfg_soft[]🐐🐐 lyric file exists! [goto_end=%goto_end%] [lyric_status=“%lyric_status%”]"
                rem if not exist "%LYRIC_FILE%" echo %@randfg_soft[]🐐🐐 lyric file DOESN’T exists! [goto_end=%goto_end%] [lyric_status=“%lyric_status%”]"
                if "%1" == "%goto_end%" goto :END

                :nexty_next_next
                unset /q WE_GOOGLED
                :goto_from_2338

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem TODO: Perhaps a prompt to reject the lyrics here {and delete the file}, i needed that in at least 1 case. it would have to default to 0

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

:reject_hand_editing_question_entirely

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━

rem Mark the lyric file as approved/disapproved, using windows Alternate Data Streams:


        iff exist "%LYRIC_FILE%" .and. "1" != "%LYRICS_FOUND_TO_HAVE_BEEN_PREAPPROVED%" .and. "1" != "%FORCE_REGEN%" then
                rem echo LYRIC_STATUS is %LYRIC_STATUS 🐶🐶🐶
                rem gosub divider
                iff 1 eq %LYRICS_ACCEPTABLE% .and. "%LYRIC_STATUS%" !=  "APPROVED" then
                        rem double-message: call less_important "Approving lyrics %conceal_on%JJ%conceal_off%"
                        call  approve-lyric-file "%LYRIC_FILE%" >nul
                        gosub approve_lyrics_done
                endiff                        
                iff 0 eq %LYRICS_ACCEPTABLE .and. "%LYRIC_STATUS%" !=  "NOT_APPROVED" then 
                        call less_important "%underline_on%DIS%underline_off%approving lyrics...%conceal_on%Q94%conceal_off%"
                        call disapprove-lyric-file "%LYRIC_FILE%" >nul
                        set JUST_APPROVED_LYRICS=0
                        set LYRIC_STATUS=NOT_APPROVED
                        set LYRICS_JUST_DISAPPROVED=1
                endiff                        
        endiff

rem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━-━-━-━


rem Start our cleanup:
        :Cleanup
        rem (moved to very end)

rem While we’re here, create LRCs from pre-existing SRTs?:
        rem Currently: No. We prefer to do this *after* making our SRT:
        rem ❓ or perhaps even only if we absolutely have to (for eccsrt2lrc2clip.bat) ❓
        rem call srt2lrc.bat


rem Validate we did something:

        set GENERAL_LYRIC_FAILURE=0
        iff not exist "%LYRIC_FILE%" then
                rem echo Tracer NELF
                if "%LYRICLESSNESS_STATUS%" != "APPROVED"  set GENERAL_LYRIC_FAILURE=1
        else
                rem echo Tracer GLF1 -- JUST_APPROVED_LYRICS=%JUST_APPROVED_LYRICS% JUST_APPROVED_LYRICLESSNESS=%JUST_APPROVED_LYRICLESSNESS%, LYRICS_ACCEPTABLE=%LYRICS_ACCEPTABLE%
                iff "1" == "%JUST_APPROVED_LYRICS%" .or. "%LYRIC_STATUS%" == "APPROVED" then 
                        set GENERAL_LYRIC_FAILURE=0    
                        rem echo Tracer GLF1-A .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                elseiff "1" == "%JUST_APPROVED_LYRICLESSNESS%" then
                        set GENERAL_LYRIC_FAILURE=0
                        rem echo Tracer GLF1-B .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                elseiff  "0" == "%LYRICS_ACCEPTABLE%"  .or. "%LYRIC_STATUS%" == "NOT APPROVED" then
                        rem echo Tracer GLF1-C .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                        set GENERAL_LYRIC_FAILURE=1
                elseiff  "1" != "%LYRICS_ACCEPTABLE%" .and. "1" !=  "%LYRICS_JUST_SPPROVED%" .and. "%LYRIC_STATUS%" != "APPROVED" then
                        rem echo Tracer GLF1-D .... GENERAL_LYRIC_FAILURE=%GENERAL_LYRIC_FAILURE%
                        set GENERAL_LYRIC_FAILURE=1
                endiff
        endiff

        if "1" != "%GENERAL_LYRIC_FAILURE%" goto :lyric_final_success
                rem echo 🐐 Trace FLEN
                rem Take note of the fact that we failed to fetch the lyrics for this audio file!:
                        set LYRICS_FETCHED=0
                        set LYRIC_SEARCH_FAILED=1

                rem Display our failure in abject shame:
                        gosub divider
                        rem      call nn "%emoji_warning% %ansi_color_alarm%LYRIC FAIL%ansi_color_normal% %emoji_warning%"
                        echos %@ANSI_CURSOR_CHANGE_COLOR_WORD[red]%ANSI_CURSOR_CHANGE_TO_BLOCK_BLINKING%   
                        rem  ⚠️ LYRIC FAIL  ⚠️
                        repeat 3 call bigecho " %emoji_warning% %ansi_color_alarm% LYRIC FAIL %ansi_color_normal% %emoji_warning%"
                        gosub divider
                        if 1 eq %ABANDONED_SEARCH% goto :END
                        set FILE_ARTIST_WARNING_PART=
                        if "%FILE_ARTIST%" != "" set FILE_ARTIST_WARNING_PART=%FILE_ARTIST% - ``
                        echo %ANSI_COLOR_WARNING% %EMOJI_WARNING% Unfortunately, we could not find lyrics for “%ANSI_COLOR_BRIGHT_RED%%ITALICS_On%%FILE_ARTIST_WARNING_PART%%FILE_SONG%%ITALICS_OFF%%ansi_color_warning%” %EMOJI_WARNING% %ANSI_COLOR_NORMAL%
                        title %emoji_warning% Lyrics not fetched %emoji_warning%
                        set   goto_end=1
                        goto /i END



        :lyric_final_success
        rem echo 🐐 Trace QUAY2
        rem Take note of the fact that we have now successfully fetched the lyrics for this audio file!:
                set LYRICS_FETCHED=1
                set LYRIC_SEARCH_FAILED=0

        rem Make it silent if this is part of a batch:
                iff "%_pbatchname" == "get-the-missing-lyrics-here-temp.bat" then
                        rem If we are in a batch job, be quiet:
                        set silent_or_nothing=silent 
                else                
                        rem But also ultimately, just be quiet all the time (we changed our minds): [todo could make this an option]
                        set silent_or_nothing=silent
                endiff                        

        rem Although we created our “divider” subroutine to lower the overhead of actually calling divider.bat,
        rem *this* particular one in *this* particular instance created a cosmetic bug not worth the debug time,
        rem so we just revert to the “normal” way of calling the .BAT file instead of the subroutine we made here:
                gosub divider

        rem Celebrate!! 🍰🍰🍰🍰🍰🍰🍰🍰🍰🍰🍰
                rem  celebrate "%check% LYRIC SUCCESS %check%" 2
                rem  celebrate "%ansi_background_black% %check%  %@cool[LYRIC SUCCESS] %check% %@randfg[]" 2
                rem  celebrate "%ansi_background_black% %check% %@rainbow_string[LYRIC SUCCESS] %check%  %@randfg[]" 
                rem  celebrate "%ansi_background_black% %check% %@cursive[LYRIC SUCCESS] %check%  %@randfg[]" 
                iff "1" != "%GENIUS_ONLY%" .and. "%LYRIC_SUCCESS_CELEBRATION_DISPLAYED%" != "1_%AUDIO_FILE%" then 
                        call celebrate "%ansi_background_black% %italics_off%%check% %@cursive[LYRIC SUCCESS] %check%  %@randfg[]" %silent_or_nothing%                        
                        set LYRIC_SUCCESS_CELEBRATION_DISPLAYED=1_%AUDIO_FILE%
                endiff
                rem Redundant at this point.... I think.... call important_less "Lyrics downloaded:  %blink_on%%italics_on%%LYRIC_FILE%%ANSI_RESET%"            

        rem Display newly-updated lyric / lyricLESSness status:                
                rem echo checking[aa] 🐐 %ansi_color_bright_yellow% iff exist "%LYRIC_FILE%" then %ansi_color_normal%
                iff exist "%LYRIC_FILE%" then
                        title %check% Lyrics aligned successfully! %check% 
                        if "%LYRIC_STATUS%" !=  "APPROVED" call approve-lyrics  "%LYRIC_FILE%" 
                        call display-lyric-status  "%LYRIC_FILE%"
                else
                        title %check% Lyriclessness approved! %check% 
                        rem call approve-lyriclessness        "%LYRIC_FILE%" 
                        rem echo 🐐 about to %ansi_color_bright_yellow%call display-lyriclessness-status "%AUDIO_FILE%"%ansi_color_normal%
                        call display-lyriclessness-status "%AUDIO_FILE%"
                endiff
        
        rem echo All done? 🐐🐮🐐🐮🐐🐮
        set    goto_end=1
        rem if "1" == "%goto_end%" echo Going to end? I guess so, since 1==%%going_to_end%% 🐐🐮🐐🐮🐐🐮
        if "1" == "%goto_end%" goto /i END
        if "1" == "%ABANDONED_SEARCH%" goto /i END
        echo this is NOT the end! 🐐🐮🐐🐮🐐🐮

rem If we couldn’t find lyrics, as if we want to approve this as our final lyic status: The status of “lyriclessness”
        :ask_to_approve_lyriclessness


rem echo %blink_on%  i thought LYRICLESSNESS_STATUS="%LYRICLESSNESS_STATUS%" is not “APPROVED”!   %newline% .......... LYRICS_FETCHED  is %LYRICS_FETCHED% .... FORCE_ASK_TO_APPROVE_LYRICLESSNESS is “%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%” %blink_off% LYRICS_ACCEPTABLE=“%LYRICS_ACCEPTABLE%” ....ABANDONED_SEARCH=“%ABANDONED_SEARCH%” .. JUST_APPROVED_LYRICLESSNESS=“%JUST_APPROVED_LYRICLESSNESS%”
        
rem echo iff("1" != "%LYRICS_FETCHED%" .and. "1" != "%JUST_APPROVED_LYRICLESSNESS%" .and. "1" !=  "%LYRICS_ACCEPTABLE%") .or. ("1" == "%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED") then 🐐lyr
        if   "1" == "%LYRIC_SUCCESS_CELEBRATION_DISPLAYED%" goto :skip_2204
        iff ("1" != "%LYRICS_FETCHED%" .and. "1" != "%JUST_APPROVED_LYRICLESSNESS%" .and. "1" !=  "%LYRICS_ACCEPTABLE%") .or. ("1" == "%FORCE_ASK_TO_APPROVE_LYRICLESSNESS%" .and. "%LYRICLESSNESS_STATUS%" != "APPROVED") then
                gosub divider

                echo %ansi_color_prompt%%star% “%ansi_color_orange%Lyric%italics_on%%underline_off%lessness%underline_off%%italics_off%%ansi_color_prompt%” is the state of having given up on finding lyrics. %faint_on%(Or officially deciding it’s an instrumental track)%faint_off%
                echo %ansi_color_prompt%%star% %blink_on%%underline_off%%italics_on%%ansi_color_orange%Approved%italics_off%%blink_off%%underline_off% lyriclessness%double_underline_off%%underone_on% status%underline_off%%ansi_color_prompt% allows automatic AI transcription %italics_on%without%italics_on% having a lyrics file. %faint_on%(Or allows skipping of instrumental tracks)%faint_off%
                call AskYN "Do you want to approve %bold_on%“%ansi_color_orange%lyric%italics_off%lessness%italics_off%%ansi_color_prompt%”%bold_off% status, and officially %italics_on%give up%italics_off% on finding lyrics for this song" %LYRICLESSNESS_APPROVAL_CURRENT_DEFAULT_ANSWER%  %@EVAL[%APPROVE_LYRICLESS_SONGS_WAIT_TIME%*4] I I:mark_as_instrumental %+ rem 🐮 extended wait time 🐮
                set   JUST_APPROVED_LYRICLESSNESS=0
                set JUST_UNAPPROVED_LYRICLESSNESS=0
                iff "I" == "%ANSWER%" then
                        gosub check_for_answer_of_I
                        goto /i END
                endiff
                if  "1" == "%GOTO_END%" goto /i END
                iff "Y" == "%ANSWER%"   then
                        call approve-lyriclessness-for-file.bat "%AUDIO_FILE%"
                        echo LYRICLESSNESS_STATUS Trace 2 >nul 
                        set  JUST_APPROVED_LYRICLESSNESS=1
                        set  LYRICLESSNESS_STATUS=APPROVED        
                else                        
                        call  unapprove-lyriclessness-for-file.bat "%AUDIO_FILE%"
                        set   JUST_UNAPPROVED_LYRICLESSNESS=1
                        set   LYRICLESSNESS_STATUS=NOT_APPROVED
                        gosub ask_about_instrumental
                endiff
        endiff
        :skip_2204



goto :END
rem echo 🐐🐮🐐🐮🐐🐮 This should not be seen ever...

rem ━━━━━━━━━━━━━━ SUBROUTINES: BEGIN: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


        :approve_lyrics_done []
                rem TODO: consider if we should call approve-lyrics with the file here, or if that’s not necessary if we approved it in-the-moment such that we encoded it. 
                set LYRIC_STATUS=APPROVED
                set LYRICS_FETCHED=1
                set LYRICS_ACCEPTABLE=1
                set JUST_APPROVED_LYRICS=1               
                if "1" != "%[logged_lyricapproval_%AUDIO_FILE%]" @echo %@REPEAT[%newline%,2]%EMOJI_DESKTOP_COMPUTER% %_DATETIME: %check% Approved: Lyrics: “%@UNQUOTE[%@FULL["%AUDIO_FILE%"]]” >>:u8"%AUDIOFILE_TRANSCRIPTION_LOG_FILE%"
                set          logged_lyricapproval_%AUDIO_FILE%=1
        return

        :ask_about_instrumental [as_what]
                rem echo 🐐 called ask_about_instrumental [as_what=“%as_what”] [answer]
                set HAS_INSTRUMENTAL_ADS_TAG=0
                if "%as_what%" == "" set temp_ads_tag_name=is_instrumental
                if "%as_what%" != "" set temp_ads_tag_name=is_%as_what%
                set IS_INSTRUMENTAL_or_whatever_ADS_FILENAME=%@name[%@UNQUOTE["%AUDIO_FILE%"]].%@EXT[%@UNQUOTE["%AUDIO_FILE%"]]:%temp_ads_tag_name%
                rem echo            🐐 IS_INSTRUMENTAL_or_whatever_ADS_FILENAME=%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%

                REM TODO: unset /q ADS_TAG
                rem TODO: set ADS_TAG=value of getting the ADS tag for is_instrumental 
                REM TODO: if " %ADS_TAG%" ==  ""     set HAS_INSTRUMENTAL_ADS_TAG=0
                REM TODO: if " %ADS_TAG%" !=  ""     set HAS_INSTRUMENTAL_ADS_TAG=1                
                REM TODO: iff "%ADS_TAG%" ==  "True" then
                REM TODO:         set ADS_TAG_SAYS_INSTRMENTAL=1
                REM TODO: else
                REM TODO:         set ADS_TAG_SAYS_INSTRMENTAL=0
                REM TODO: endiff

                rem Did we already ask about this one?
                        iff "1" != "%[already_asked_about_%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%]" then
                                 set  already_asked_about_%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%=1
                        else
                                echo Already asked about this song.... (already_asked_about_%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%=“%[already_asked_about_%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%]”)
                                return
                        endiff
                        rem echo are we still here? 🐐🐐🐐🐐

                rem if it’s not marked as instrumental, ask if it is one...
                rem echo            🐐 checking[f] iff "1" == "`%`@Regex[instrumental,"%AUDIO_FILE%"]" == "%@Regex[instrumental,"%AUDIO_FILE%"]" then
                if "1" != "%@Regex[instrumental,"%AUDIO_FILE%"]" goto :else_2280
                        gosub debug "Marked file with ADS tag of “%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%”"
                        echo True>"%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%"
                        goto :endiff_2318
                :else_2280
                        rem Read or ask answer about if it’s an instrumental or not:
                        rem echo            🐐 checking[g] iff "1" != HAS_INSTRUMENTAL_ADS_TAG="%HAS_INSTRUMENTAL_ADS_TAG%" then
                        if "1" != "%HAS_INSTRUMENTAL_ADS_TAG%" goto :do_it_2282
                                                               goto :else_do_it_2294
                                :do_it_2282
                                set HELD_ANSWER=%ANSWER%
                                        :ask_again_2283
                                        unset /q ANSWER
                                        call AskYN "Is this an instrumental? [%ansi_color_bright_green%P%ansi_color_prompt%=Preview]" No %GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME% IP P:preview_song,I:instrumental_it_is!
                                        SET LAST_ANSWER_TO_ISTHISINSTRUMENTAL=%ANSWER%
                                        gosub check_for_answer_of_P
                                        if "P" == "%ANSWER%" gosub ask_again_2283
                                        if "I" == "%ANSWER%" gosub rename_audio_file_as_instrumental
                                        if "Y" == "%ANSWER%" gosub rename_audio_file_as_instrumental
                                rem set ANSWER=%HELD_ANSWER%
                                goto /i endiff_2300
                        :else_do_it_2294
                                iff "1" == "%ADS_TAG_SAYS_INSTRUMENTAL%" then
                                        set ANSWER=Y
                                else
                                        set ANSWER=N
                                endiff
                        :endiff_2300
                        if "Y" != "%ANSWER%" goto :else_230999
                                gosub debug "Marked file with ADS tag: “%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%”"
                                echo True>"%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%"
                                iff "" !=  "%LAST_RENAMED_TO%" then
                                        set AUDIO_FILE=%@UNQUOTE[%LAST_RENAMED_TO%]
                                        set JUST_RENAMED_TO_INSTRUMENTAL=1
                                        set IS_INSTRUMENTAL_or_whatever_ADS_FILENAME=%@name[%@UNQUOTE["%AUDIO_FILE%"]].%@EXT[%@UNQUOTE["%AUDIO_FILE%"]]:%temp_ads_tag_name%
                                endiff
                                gosub rename_audio_file_as_instrumental
                                rem Section removed after it started rn’ing previous %AUDIO_FILE%s and not the current due to rename code not beinog fully perfected
                                rem if not exist "%AUDIO_FILE%" goto :endif_2479
                                rem         echo %ansi_color_warning_soft%%star2% Last chance for bonus renaming:
                                rem         call rn "%AUDIO_FILE%"
                                rem :endif_2479
                                goto /i endiff_2313
                        :else_230999
                                rem gosub debug "echo False to “%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%”"
                                echo False>"%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%"
                                gosub debug "Marked file with ADS tag of %italics_on%FALSE%italics_off%: “%IS_INSTRUMENTAL_or_whatever_ADS_FILENAME%”"
                        :endiff_2313

                        rem echo            🐐 gonna gosub rename_audio_file_as_instrumental from ask_about_instrumental
                :endiff_2318
        return

        :ask_if_want_mark_lyriclessness []
                rem echo 🌷🌷🌷  Asking if we want to mark as lyricless.... 🌷🌷🌷 >nul
                echo %ansi_color_advice%%star2% NOTE: “%ansi_color_bright_yellow%lyric%underline_on%less%underline_on%%ansi_color_advice%”     means “we can’t/won’t find lyrics for this song”
                echo %ansi_color_advice%%star2%       “%ansi_color_bright_yellow%linstrumental%ansi_color_advice%” means “no words are sung or spoken at all”
                :ask_if_want_mark_lyriclessness_2
                call AskYn "Want to mark this song %ansi_green%i%ansi_color_prompt%nstrumental or %ansi_green%l%ansi_color_prompt%yrics %underline_on%unfindable%underline_off% (i.e. officially abandon our lyric search[%ansi_color_bright_green%Z%ansi_color_prompt%=All]) [P=Preview]" no %GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME% IGLPZ I:Mark_this_file_as_an_instrumental,G:Google,L:It’s_Lyricless,Z:Mark_all_as_lyricless,P:Play_it %+ rem 🐮 borrowed wait time
                gosub check_for_answer_of_G
                gosub check_for_answer_of_I
                if "1" == "%GOTO_END%" (goto :END)
                gosub check_for_answer_of_L
                gosub check_for_answer_of_P
                if  "P" == "%ANSWER%" goto :ask_if_want_mark_lyriclessness_2
                iff "Y" == "%ANSWER%" then 
                        set ABANDONED_SEARCH=1
                        set ANSWER=L
                        gosub check_for_answer_of_L
                        rem echo Just got back from check_for_answer_of_L called FROM WITHIN :ASK_IF_WANT_MARK_LYRICLESSNESS [] ...answer=“%ANSWER%”, goto_end=“%GOTO_END%”
                        if 1 eq %goto_END% goto :END
                endiff
                if "1" == "%GOOGLE_NOW%" (goto :Google_Now)
                if "1" == "%GOTO_END%"   (goto :goto_end  )
        return
        goto :END

        :check_for_answer_of_A [alsoAcceptThisLetter]
                if "%ANSWER%" != "A" .and. "%ANSWER%" != "%alsoAcceptThisLetter%" return
                call  approve-lyrics "%LYRIC_FILE%"
                gosub approve_lyrics_done
                set   goto_end=1
                goto /i END
                rem ^^ todo should we perhaps goto lyric success message instead? Hmm.
        return

        :check_for_answer_of_D [opt]
                gosub check_for_answer_of_D_to_eset_artist_and_song %opt%
        return
        :check_for_answer_of_D_to_eset_artist_and_song []
                rem 
                rem echo 🎨 checking if answer of ‘%answer%’ is “%blink_on%D%blink_off%”
                iff  "%answer%" == "D"  then
                        gosub eset_fileartist_and_filesong
                        set goto_download_with_lyric_downloader_1=1
                        rem echo 🎨 it is! setting goto_download_with_lyric_downloader_1 to “%goto_download_with_lyric_downloader_1%”
                else
                        rem echo 🎨 it isn’t❕❔?!?!!
                endiff
                rem do this after calilng: if "1" == "%goto_download_with_lyric_downloader_1%" goto :download_with_lyric_downloader_init
        return

        :check_for_answer_of_G []
                if  "%ANSWER%" == "G" set GOOGLE_NOW=1 
                if  "%ANSWER%" != "G" set GOOGLE_NOW=0
                if "1" == "%GOOGLE_NOW%" goto Google_Now
        return

        :check_for_answer_of_H [opt]
                gosub edit_lyrics_now_if_we_answered_H %opt%
        return

        :check_for_answer_of_L [opt]
                rem echo %ANSI_COLOR_MAGENTA%goat010101 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%
                set HOLD_ANSWER_CFAOL=%answer%
                if "%answer%" == "L" gosub mark_as_lyricless %opt%

                if "%HOLD_ANSWER_CFAOL%" == "L" (set goto_END=1 %+ goto /i END)
                set answer=%HOLD_ANSWER_CFAOL%
                rem echo %ANSI_COLOR_MAGENTA%goat020202 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%

                iff "%answer%" == "Z" then
                        for %%tmpFileForZAnswer in (%FILEMASK_AUDIO%) gosub mark_as_lyricless "%@UNQUOTE["%tmpFileForZAnswer%"]"
                        set goto_END=1
                        goto /i END
                endiff
                set answer=%HOLD_ANSWER_CFAOL%

                rem echo %ANSI_COLOR_MAGENTA%goat030303 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%

                if "1" == "%GOTO_END%" (goto :END)
                rem echo Why didn’t it work?

                rem echo %ANSI_COLOR_MAGENTA%goat040404 check_for_answer_of_L answer=“%answer%”, JUST_RENAMED_TO_INSTRUMENTAL=“%JUST_RENAMED_TO_INSTRUMENTAL%”, GOTO_END=“%GOTO_END%”%ANSI_COLOR_NORMAL%
        return

        :check_for_answer_of_O
                iff "%ANSWER%" == "O" .or. "1" == "%goto_download_with_lyric_downloader_1%" then
                        set goto_download_with_lyric_downloader_init=1
                        goto /i download_with_lyric_downloader_init
                endiff
        return

        :check_for_answer_of_P [opt]
                rem goat
                echo 📞📞📞 called: get-lyrics: check_for_answer_of_P [opt=%opt%] 📞📞📞
                :try_again
                iff "%PLAYER_COMMAND%" == "" then
                        rem echo %ANSI_COLOR_WARNING%%EMOJI_CAUTION%Player command isn’t set! setting to vlc.exe for best odds...%ansi_color_normal%
                        set  PLAYER_COMMAND=%DEFAULT_PLAYER_COMMAND%
                endiff
                if "%PLAYER_COMMAND%" == "" goto :try_again
                rem echo %arrow% check_for_answer_of_P [] ... audio_file = %AUDIO_FILE%, SONGFILE= %SONGFILE%,%SONG_FILE%
                iff "%answer%" == "P" then
                        set FILE_TO_USE=%AUDIO_FILE%
                        set size=-1
echo                    iff "%@UNQUOTE["%opt%"]" != "" .and. exist "%@UNQUOTE["%opt%"]" then
                        iff "%@UNQUOTE["%opt%"]" != "" .and. exist "%@UNQUOTE["%opt%"]" then
                                set FILE_TO_USE=%@UNQUOTE["%opt%"]
                        else
                                call warning "couldn’t make sense of opt=“%opt%” in %0 on line 2785ish .. pbatchname=“%_PBATCHNAME”"
                        endiff
                        set size=%@FILESIZE["%FILE_TO_USE%"] 
                        if %size% lt 1000 call warning "This file is %size% bytes!!!!!!!!!!!!!!!!!!!!!!"
                        echo %ANSI_COLOR_IMPORTANT%%EMOJI_PLAY_BUTTON% Playing file: “%@UNQUOTE["%FILE_TO_USE%"]” %ansi_color_normal%
                        set player_command_to_use=%PLAYER_COMMAND% "%@UNQUOTE["%FILE_TO_USE%"]" %player_command_extra_options%
                        rem goat
                        echo %ansi_color_debug%- DEBUG: Player command: %faint_on%%player_command_to_use%%faint_off%
                        set LAST_PLAYER_COMMAND_USED=%player_command_to_use%                 
                        %player_command_to_use%                 
                endiff
        return

        :check_for_answer_of_R [opt]
                if "R" != "%ANSWER%" return
                call  rn "%@UNQUOTE["%audio_file%"]"
                echo %ansi_color_debug%- DEBUG; after rn at 2625, last_renamed_to=“%LAST_RENAMED_TO%” so maybe set tmpFileForXAnswer=%LAST_RENAMED_TO% if we’re calling this from something that use that?%ansi_color_normal%goat
                iff "" != "%LAST_RENAMED_TO%" then
                        set AUDIO_FILE=%LAST_RENAMED_TO%
                        set LYRIC_FILE=%@NAME["%AUDIO_FILE%"].txt
                        set   SRT_FILE=%@NAME["%AUDIO_FILE%"].srt
                        set   LRC_FILE=%@NAME["%AUDIO_FILE%"].lrc
                endiff
                call warning "Renaming may break future operations...You may want to hit Ctrl-C now...." %+ pause
        return

        :debug [msg]
                echo %ANSI_COLOR_DEBUG%- DEBUG: %msg% %ansi_color_normal%
        return

        :DisplayAudioFileName []
                echo %star% Audio file: %faint_on%%AUDIO_FILE%%faint_off%%conceal_on%%0%%conceal_off%
        return
        :DisplayAudioDirectory [opt]
                 rem  %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio directory: %ansi_color_bright_red%“%italics_on%%blink_off%%ansi_color_green%%@PATH[%AUDIO_FILE%]%blink_off%%italics_off%%ansi_color_prompt%%ansi_color_bright_red%”%ansi_color_normal%                        
                 echo %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio directory: %ansi_color_bright_red%“%italics_on%%blink_off%%ansi_color_green%%ansi_color_pink%%@IF["" != "%@UNQUOTE[%@PATH[%AUDIO_FILE%]]",%@PATH[%AUDIO_FILE%],%_CWP]%blink_off%%italics_off%%ansi_color_prompt%%ansi_color_bright_red%”%ansi_color_normal%
                 rem echo %ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP%%ARROW_UP% TESTING 🐐
                if "%opt%" == "nofilename" goto :nofilename
                if "%PREVIOUS_GENIUS_FILENAME%" !=  "" (
                        set dspauddir_spacer= ``
                ) else (
                        unset /q dspauddir_spacer
                )
                echos %ansi_color_prompt%%star% %ansi_color_bright_yellow%Audio %dspauddir_spacer%filename%ansi_color_yellow%:%ansi_color_prompt%  %dspauddir_spacer%“%italics_on%%blink_off%%ansi_color_green%%AUDIO_FILE_TO_DISPLAY_NAME%%blink_off%%italics_off%%ansi_color_prompt%”
                :nofilename
        return

        return
        :divider [divider_param]
                iff "1" == "%suppress_next_divider%" then
                        set  suppress_next_divider=0
                        return
                endiff

                rem Determine divider file to use:
                        set wd=%@EVAL[%_columns - 1]
                        set nm=%bat%\dividers\rainbow-%wd%.txt

                rem Type divider file if it exists:
                        iff exist %nm% then
                                *type %nm%
                                set last_divider_method=type
                                set last_divider_param=%divider_param%
                rem Otherwise, manually draw the divider:
                        else
                                echo %@char[27][93m%@REPEAT[%@CHAR[9552],%wd%]%@char[27][0m
                                set last_divider_method=echo
                        endiff

                rem Our divider files do not include newlines. Do we add one ourself?
                        rem debug: *pause>nul
                        iff "%divider_param%" == "NoNewline"  then
                                set last_divider_newline=False
                        else 
                                set last_divider_newline=True

                                rem Go to the next line:
                                        rem we COULD do the newline character:
                                        rem echos %NEWLINE%%@ANSI_MOVE_TO_COL[1] 
                                        rem but it’s easier to just do a few spaces so that we end up on the new line anyway, then move to col 1:
                                        rem echos     %@ANSI_MOVE_TO_COL[1] 
                                        rem But that didn’t work great either, let’s try echo. instead of echo’ing %newline%:
                                        rem echos. 
                                        rem For some reason, echos. just isn’t going to the next line! Possible bug!
                                        rem Just do it with ansi? No. wtf.
                                        rem echos %@ANSI_MOVE_DOWN[2]
                                        rem why isn’t this working? There’s no reason these methods shoudln’t work. Try the original again?!?!
                                        echos %NEWLINE%

                                rem Then move to column 0/1 [which are the same column]:
                                        echos %@ANSI_MOVE_TO_COL[0] 

                        endiff

                rem Debug:
                        echo wtf last_divider_newline=%last_divider_newline% should we do one? >nul
        return

        :eset_fileartist_and_filesong []
                rem 🧹 make sure the variables are clean and ready for modification 🧹
                        if not defined FILE_ARTIST (set FILE_ARTIST=?)
                        if not defined FILE_SONG   (SET   FILE_SONG=?)

                rem Pre-set it to the last thing we changed it to, in case the situation is happening multiple times:
                        if "" !=  "%FILE_ARTIST_LAST_CHANGED_TO%" set FILE_ARTIST=%FILE_ARTIST_LAST_CHANGED_TO%
                        rem   !=    "%FILE_SONG_LAST_CHANGED_TO%" set   FILE_SONG=%FILE_SONG_LAST_CHANGED_TO%    ━━━ it doesn’t make sense to do it for the song; only for the artist

                rem keep track of original values:
                        set FILE_ARTIST_BEFORE_CHANGE=%FILE_ARTIST%
                        set   FILE_SONG_BEFORE_CHANGE=%FILE_SONG%

                rem Display filename in case its scrolled off the screen and we can’t ascertain it:                        
                rem ✍🏻 hand-editing artist/song name: ✍🏻 
                        set   FILE_ARTIST_PRE_ESET=%FILE_ARTIST%
                        set   FILE_SONG_PRE_ESET=%FILE_SONG%
                        gosub DisplayAudioDirectory nofilename

                        gosub DisplayAudioFilename
                        call eset-alias FILE_ARTIST quick

                        gosub DisplayAudioFilename
                        call eset-alias FILE_SONG quick
                        rem  FILE_ALBUM

                rem Massage ’ into ' because ’ doesn’t match ' in genius searches:
                        set   FILE_SONG=%@Replace[’,',%FILE_SONG%]
                        set FILE_ARTIST=%@Replace[’,',%FILE_ARTIST%]

                rem Update flag:
                        if "%FILE_ARTIST_PRE_ESET%" != "%FILE_ARTIST%" .or. "%FILE_SONG_PRE_ESET%" != "%FILE_SONG%"   set debanded=0

                rem Store values for future runs:
                        iff "%FILE_ARTIST%" != "%FILE_ARTIST_BEFORE_CHANGE%" then
                                rem echo setting FILE_ARTIST_LAST_CHANGED_TO=%FILE_ARTIST% 🐺
                                set FILE_ARTIST_LAST_CHANGED_TO=%FILE_ARTIST%
                        endiff
                        iff "%FILE_SONG%"   !=   "%FILE_SONG_BEFORE_CHANGE%" then
                                rem echo setting FILE_SONG_LAST_CHANGED_TO=%FILE_SONG% 🐺
                                set   FILE_SONG_LAST_CHANGED_TO=%FILE_SONG%
                        endiff
                        

                rem Update related/alias values based on new values:
                        set        FILE_SONG_TO_USE=%FILE_SONG%
                        set       FILE_TITLE_TO_USE=%FILE_SONG%
                        set      FILE_ARTIST_TO_USE=%FILE_ARTIST%
                        set FILE_ORIG_ARTIST_TO_USE=%FILE_ORIG_ARTIST%
                        set       FILE_ALBUM_TO_USE=%FILE_ALBUM%
                        rem gosub debug "🎨🎨🎨[30] FILE_ARTIST_TO_USE=“%FILE_ARTIST_TO_USE%, FILE_ARTIST=“%FILE_ARTIST%””"
        return

        :edit_lyrics_now_if_we_answered_H [subarg force]
                rem This gets called excessively, so we have to make sure it only happens once...

                rem echo 🐐 called: edit_lyrics_now_if_we_answered_H [subarg=%subarg% force=%force%] ALREADY_HAND_EDITED=“%ALREADY_HAND_EDITED%”, answer=“%answer%”
                iff  "1" == "%ALREADY_HAND_EDITED%" then
                        rem Confirm:
                                set hold_hand_answer=%answer%
                                rem call askyn "We already hand-edited this, are you sure you want to again" no 300
                                echo %ansi_color_unimportant%%star3% We already hand-edited this, so we’re not doing it again%ansi_color_normal%
                                set already_answer=%answer%
                                set answer=%hold_hand_answer%
                        rem Exit if that’s what we want:
                                if "N" == "%already_answer%" return
                endiff
                set do_next_block=0
                rem echo %ansi_color_orange%🐐 mid1:   edit_lyrics_now_if_we_answered_H [subarg=%subarg% force=%force%] ALREADY_HAND_EDITED=“%ALREADY_HAND_EDITED%”, answer=“%answer%”, do_next_block=“%do_next_block%”, subarg=“%subarg%”, force=“%force%”%ansi_color_normal%
                if "H" == "%ANSWER%" .or. "%force%" == "force" .or. ("%ANSWER%" == "%subarg%" .and. "" !=  "%subarg") set do_next_block=1                
                rem echo %ansi_color_orange%🐐 mid2:   edit_lyrics_now_if_we_answered_H [subarg=%subarg% force=%force%] ALREADY_HAND_EDITED=“%ALREADY_HAND_EDITED%”, answer=“%answer%”, do_next_block=“%do_next_block%”%ansi_color_normal%
                if "0" == "%do_next_block%" goto :else_from_2712
                if "1" == "%do_next_block%" goto :edit_it_already_2751
                        :edit_it_already_2751
                        echos %ANSI_POSITION_SAVE%
                        set EDIT_CALL=%EDITOR% "%LYRIC_FILE%"
                        echo editing lyric file because answer=“%answer%”  ... google_now=“%google_now%”.... call = “%blink_on%%edit_call%%blink_off%” 💩
                        %EDIT_CALL%
                        rem   2025/01/23: Not sure if this is necessary anymore: echos %ANSI_POSITION_RESTORE%
                        rem   pause "%ansi_color_warning_soft%%blink_on%Press any key when done hand-editing the lyrics...%blink_off%%ansi_color_normal%"
                        rem   pause-for-x-seconds %LONGEST_POSSIBLE_HAND_EDIT_TIME_IN_SECONDS% "%ansi_color_bright_yellow%%pencil% Hit a key when done editing lyrics... %faint_on%(leave blank if none found or if done by mistake)%faint_off% %pencil% %ansi_color_normal%"
                              pause "%ansi_color_warning_soft%%blink_on%Press any key when done hand-editing the lyrics...%blink_off%%ansi_color_normal%"

                        set   ALREADY_HAND_EDITED=1
                        rem echo 🐐 checking[bb] if filesize["%LYRIC_FILE%"] of “%@FILESIZE["%LYRIC_FILE%"]” lt 5 then 
                        if %@FILESIZE["%LYRIC_FILE%"] gt 5 goto /i endiff_filesize_is_fine
                                set LYRICS_ACCEPTABLE=0
                                *del /Ns /q "%LYRIC_FILE%" >nul
                                gosub ask_if_want_mark_lyriclessness
                        :endiff_filesize_is_fine

                        goto we_dont_need_this_prompt_afterall_2787
                                                        rem Ask if the new ones are acceptable or not
                                                                call askyn "Acceptable BETA PROMPT" no %GOOGLE_FOR_LYRICS_PROMPT_WAIT_TIME%

                                                        iff "N" == "%ANSWER%" then
                                                                set     LYRICS_ACCEPTABLE=0
                                                                set  JUST_APPROVED_LYRICS=0
                                                        endiff
                                                        if "Y" != "%ANSWER%" goto :endiff_not_y_from_2702
                                                                set     LYRICS_ACCEPTABLE=1
                                                                set  JUST_APPROVED_LYRICS=1
                                                                goto recheck_post_hand_edited_lyrics
                                                        :endiff_not_y_from_2702
                                                        rem echo LYRICS_ACCEPTABLE=%LYRICS_ACCEPTABLE%, JUST_APPROVED_LYRICS=%JUST_APPROVED_LYRICS%
                        :we_dont_need_this_prompt_afterall_2787
                goto :endiff_from_2740
                :else_from_2712
                        set  DO_NOT_ASK_TO_HAND_EDIT=1
                        echo FORCE_HAND_EDIT trace ZZZ >nul 
                        set  FORCE_HAND_EDIT=0
                :endiff_from_2740
        return
        goto :END
              
        :mark_as_lyricless [use_this_file_instead]
                rem Ensure our filename is set correctly:
                                                                        set FILE_TO_MARK_AS_LL=%AUDIO_FILE%
                        if "" != "%@UNQUOTE["%use_this_file_instead%"]" set FILE_TO_MARK_AS_LL=%use_this_file_instead%      

                rem Let user know we called this:
                        echo %ansi_color_debug%-DEBUG: Called: mark_as_lyricless [%use_this_file_instead%] with FILE_TO_MARK_AS_LL==“%FILE_TO_MARK_AS_LL%” goat %ansi_color_normal% 
                        echo %star% Audio filename: %faint_on%“%FILE_TO_MARK_AS_LL%”%faint_off%%conceal_on%XX%conceal_off%


                rem Delete TXT file if we’ve marked it as lyricless, because that would mean the TXT isn’t our lyrics:
                        rem echo 🐐 checking if exist: SIDECAR_LYRICS==“%SIDECAR_LYRICS%”
                        set SIDECAR_LYRICS=%@NAME[%@UNQUOTE["%FILE_TO_MARK_AS_LL%"]].txt
                        set   SIDECAR_JSON=%@NAME[%@UNQUOTE["%FILE_TO_MARK_AS_LL%"]].json
                        set    SIDECAR_LRC=%@NAME[%@UNQUOTE["%FILE_TO_MARK_AS_LL%"]].lrc
                        set    SIDECAR_SRT=%@NAME[%@UNQUOTE["%FILE_TO_MARK_AS_LL%"]].srt
                        iff exist "%SIDECAR_LYRICS%" then
                                rem echo %EMOJI_AXE% %ansi_color_warning_soft%Possibly deleting lyric file of%faint_on%:%faint_off% %ansi_color_pink%“%ansi_color_green%%SIDECAR_LYRICS%%ansi_color_pink%”%ansi_color_normal% %emoji_axe%%ansi_color_removal%
                                set hold_our_answer_for_now=%answer%
                                echo sidecar_lyrics/json=%newline%%tab%“%sidecar_lyrics%”%newline%%tab%“%sidecar_json%”
                                unset /q ANSWER
                                call AskYn "Delete lyrics & json" yes %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME%
                                if "Y" != "%answer"  goto /i :endiff_do_not_delete_2754
                                        if exist "%SIDECAR_LYRICS%" (echos %AXE%%AXE%%AXE% %+ *del /Ns /a: /f  "%SIDECAR_LYRICS%")
                                        if exist "%SIDECAR_JSON%"   (echos %AXE%%AXE%%AXE% %+ *del /Ns /a: /f  "%SIDECAR_JSON%"  )
                                :endiff_do_not_delete_2754
                                unset /q ANSWER
                                call AskYn "Delete lrc & srt" yes %LYRIC_ACCEPTABILITY_REVIEW_WAIT_TIME%
                                if "Y" != "%answer"  goto /i :endiff_do_not_delete_2850
                                        if exist "%SIDECAR_LRC%"    (echos %AXE%%AXE%%AXE% %+ *del /Ns /a: /f  "%SIDECAR_LRC%"   )
                                        if exist "%SIDECAR_SRT%"    (echos %AXE%%AXE%%AXE% %+ *del /Ns /a: /f  "%SIDECAR_SRT%"   )
                                :endiff_do_not_delete_2850
                                %color_normal%
                                echos %ansi_color_normal%

                        endiff

                rem Is it already marked?
                        if "%LYRICLESSNESS_STATUS%" == "APPROVED" (
                                echo %ansi_color_warning%Already marked this as lyricless!%ansi_color_normal%
                                return
                        )

                rem Store our answer:
                        rem echo %faint_on%🐱 CALLED: mark_as_lyricless [Q1X1] in get-lyrics-for-file with use_this_file_instead=“%use_this_file_instead%”%faint_off%, answer=“%ANSWER%”
                        set HOLD_ANSWER=%ANSWER%

                rem If it’s not explicitly marked as “[instrumental]” then we need to ask if it is, and add an ADS stating such and/or rename it:
                        rem moved from below, for speedup:
                        set HOLD_AUDIO_FILE=%AUDIO_FILE%
                        set AUDIO_FILE="%@UNQUOTE["%FILE_TO_MARK_AS_LL%"]"
                        rem echo : about to gosub ask_about_instrumental ...  answer=%ANSWER%
                        gosub ask_about_instrumental 
                        rem ^ todo consider if we need to pass the filename?

                rem Don’t do it if we’ve already done it:
                        if "%LYRICLESSNESS_STATUS%" == "APPROVED" goto :already_approved_from_2790

                rem Let user know we’re doing the thing:
                        rem echo %faint_on%🐱 CALLED: mark_as_lyricless [Q1X2] FILE_TO_MARK_AS_LL is “%FILE_TO_MARK_AS_LL%”.... INPUT_FILE=“%INPUT_FILE%”%faint_off% 
                        call bigecho "%ansi_color_blue%%STAR2% Marking as lyricless and approving lyric%underline_on%%italics_on%less%italics_off%%underline_off%ness..."

                rem Update our internal flags/values for lyric/lyriclessness/etc:
                        set  ABANDONED_SEARCH=1
                        set  JUST_APPROVED_LYRICS=0
                        set  JUST_APPROVED_LYRICLESSNESS=1
                        set  LYRICLESSNESS_STATUS=APPROVED
                        set  LYRICS_STATUS=NOT SET

                rem Call our approva utility to mark it properly with the proper validations:
                        call approve-lyriclessness-for-file.bat "%@UNQUOTE["%FILE_TO_MARK_AS_LL%"]"

                rem Logging:
                        rem echo 😈😈😈😈😈BEFORE   if "1" == "%[logged_lyriclessness_%file_to_mark_as_ll%]" goto skip_logfile_logging_this_time
                       if "1" == "%[logged_lyriclessness_%file_to_mark_as_ll%]" goto skip_logfile_logging_this_time

                                echo %@REPEAT[%newline%,2]%EMOJI_DESKTOP_COMPUTER% %_DATETIME: %no% Approved: Lyriclessness: “%@UNQUOTE["%@FULL["%file_to_mark_as_ll%"]"]”>>:u8"%AUDIOFILE_TRANSCRIPTION_LOG_FILE%"
                                set          logged_lyriclessness_%file_to_mark_as_ll%=1

                        :skip_logfile_logging_this_time
                        rem echo 😈😈😈😈😈AFTER     if "1" == "%[logged_lyriclessness_%file_to_mark_as_ll%]" goto skip_logfile_logging_this_time
                        rem echo 🐐 LYRICLESSNESS_STATUS Trace 1 - status is “%LYRICLESSNESS_STATUS%” >nul

                rem If it’s not explicitly marked as “[instrumental]” then we need to ask if it is, and add an ADS stating such and/or rename it:
                        rem MOVED ABOVE: gosub ask_about_instrumental

                rem Account for “Z” to rename *EVERY* file in the folder as an instrumental:
                        set ANSWER=%HOLD_ANSWER%
                        if "Z" != "%ANSWER%" goto /i END

                :already_approved_from_2790

                rem Be done!
                        rem echo            🐐 returning from %italics%mark_as_lyricless%italics_off% [55B]
                        set  goto_END=1
                        goto /i END
                        return 666
        return                

        :rename_audio_file_as_instr_if_answer_was_I []
                if "I" == "%ANSWER%" gosub rename_audio_file_as_instrumental
        return

        :check_for_answer_of_I [opt1 opt2 opt3]                        
                iff "%answer%" == "X" then
                        echo dry run:
                        for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) echo gosub rename_audio_file_as_instrumental "%@UNQUOTE["%tmpFileForXAnswer%"]"
                        pause
                        echo real run:
                        pause
                        echo was doing this: for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) gosub rename_audio_file_as_instrumental "%@UNQUOTE["%tmpFileForXAnswer%"]"
                        echo but now testing a gosub, so
                        pause
                        gosub actually_rename_every_file_as_an_instrumental_or_whatever %opt1% %opt2% %opt3%
                        set goto_END=1
                        goto /i END
                else
                        gosub rename_audio_file_as_instr_if_answer_was_I 
                endiff       
                 if "1" == "%GOTO_END%" (goto :END)
        return

        :unmark_every_file_as_an_instrumental_ADS_tag_only [opt1 opt2 opt3]
                unset /q answer
                set ask=0
                set force_unmark_every_file_as_instrumental=1
                for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) do gosub arefaiowsub "%@UNQUOTE["%tmpFileForXAnswer%"]" "%@unquote["%opt1%"]" "%@unquote["%opt2%"]" "%@unquote["%opt3%"]" 
                set force_unmark_every_file_as_instrumental=0
                unset /q ask
        return
        :mark_every_file_as_an_instrumental_ADS_tag_only [opt1 opt2 opt3]
                unset /q answer
                set ask=0
                set force_mark_every_file_as_instrumental=1
                for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) do gosub arefaiowsub "%@UNQUOTE["%tmpFileForXAnswer%"]" "%@unquote["%opt1%"]" "%@unquote["%opt2%"]" "%@unquote["%opt3%"]" 
                set force_mark_every_file_as_instrumental=0
                unset /q ask
        return
        :mark_every_file_as_NOT_an_instrumental_ADS_tag_only [opt1 opt2 opt3]
                unset /q answer
                set ask=0
                set force_mark_every_file_as_NOT_an_instrumental=1
                for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) do gosub arefaiowsub "%@UNQUOTE["%tmpFileForXAnswer%"]" "%@unquote["%opt1%"]" "%@unquote["%opt2%"]" "%@unquote["%opt3%"]" 
                set force_mark_every_file_as_NOT_an_instrumental=0
                unset /q ask
        return
        :actually_rename_every_file_as_an_instrumental_or_whatever [opt1 opt2 opt3]
                set ask=0
                if "%1" == "%ask" .or. "%@UNQUOTE["%opt1%"]" == "ask" set ask=1
                for %%tmpFileForXAnswer in (%FILEMASK_AUDIO%) do gosub arefaiowsub "%@UNQUOTE["%tmpFileForXAnswer%"]" "%@unquote["%opt1%"]" "%@unquote["%opt2%"]" "%@unquote["%opt3%"]" 
        return
                :arefaiowsub [tmpFileForXAnswer_copy opt2 opt3]
                        rem echo %ANSI_COLOR_DEBUG%- DEBUG: called :arefaiowsub [%tmpFileForXAnswer_copy% opt2 opt3] ... ask=“%ask%”... force_mark_every_file_as_instrumental=“%force_mark_every_file_as_instrumental%” ... force_mark_every_file_as_NOT_an_instrumental=“%force_mark_every_file_as_NOT_an_instrumental%” ... answer=“%answer%”%ANSI_COLOR_NORMAL%
                        :begin_loop_arefaaiow
                        repeat 2 echo.
                        echos %ansi_color_important%%star% Filename: 
                        echos  %@Randfg_soft[]
                        echo    “%@UNQUOTE["%tmpFileForXAnswer_copy%"]”
                        rem 2025/03/29 after "P" kept playing a different file from wayyy before
                        set             audio_file=%@UNQUOTE["%tmpFileForXAnswer_copy%"]
                        set  potential_lrc=%@NAME["%@UNQUOTE["%tmpFileForXAnswer_copy%"]"].lrc
                        set  potential_srt=%@NAME["%@UNQUOTE["%tmpFileForXAnswer_copy%"]"].srt
                        set  potential_txt=%@NAME["%@UNQUOTE["%tmpFileForXAnswer_copy%"]"].txt
                        set potential_json=%@NAME["%@UNQUOTE["%tmpFileForXAnswer_copy%"]"].json
                        set  our_extension=%@EXT["%tmpFileForXAnswer_copy%"]
                        set  our_full_path=%@FULL["%tmpFileForXAnswer_copy%"]
                        :begin_loop_arefaaiow_for_real
                        unset /q ANSWER potential_is_instrumental 
                        set IS_INSTRUMENTAL_ADS_FILENAME=%@name[%@UNQUOTE["%tmpFileForXAnswer_copy%"]].%@EXT[%@UNQUOTE["%tmpFileForXAnswer_copy%"]]:is_instrumental


                        rem MIDI files can’t have vocals, so should automatically be excluded from this.
                        rem other trackers files through——such as MOD, STM, S3M——could still have *samples* of vocals, so they could still be transcribeable, except WhisperAI would not handle them.
                        rem echo     %glitch_star%  our_extension=“%our_extension%” ... is this valid?
                                iff "%our_extension%" == "mid" .or. "%our_extension%" == "mod" .or. "%our_extension%" == "stm" .or. "%our_extension%" == "s3m" .or. "%our_extension%" == "rol" .or. "%our_extension%" == "cmf"  then
                                        echo     %ansi_color_warning_soft%%star4% “%italics_on%%our_extension%%italics_off%” is %italics_on%not%italics_off% a transcribeable file type!
                                        echo     %ansi_color_warning_soft%%star5% Tagging “%italics_on%is_instrumental%italics_off%” ADS as “%italics_on%True%italics_off%”
                                        echo True>"%IS_INSTRUMENTAL_ADS_FILENAME%"
                                        return
                                endiff

                        rem Skip sound effects:
                                rem works in the wild: %@regex[SOUND EFFECT,%@upper[%@full["blast_01.mp3"]]]
rem                             iff "1" eq "`%`@RegEx[SOUND EFFECT,`%`@UPPER["`%`our_full_path`%`"]]" then
rem                             iff "1" eq "`%`@RegEx[SOUND EFFECT,%@UPPER["%our_full_path%"]]" then
rem                             iff "1" eq "%@RegEx[SOUND EFFECT,%@UPPER["%our_full_path%"]]" then
rem                             iff "1" eq "%@RegEx[SOUND EFFECT,%@UPPER["%our_full_path%"]]" then
rem                             iff "1" eq "%@REGEX[SOUND EFFECT,%@UPPER[%@full["%tmpFileForXAnswer_copy%"]]]" then
                                iff "1" eq "%@REGEX[SOUND EFFECT,%@UPPER[%@full["%tmpFileForXAnswer_copy%"]]]" then
                                        set value=True
                                        echo     %ansi_color_warning_soft%%star4% “%italics_on%%@UNQUOTE["%tmpFileForXAnswer_copy%"]%italics_off%” is a %italics_on%sound effect%italics_off% and thus not transcribeable!
                                        echo     %ansi_color_warning_soft%%star5% Tagging “%italics_on%is_instrumental%italics_off%” ADS as “%italics_on%%value%%italics_off%” since sound effects don’t have words
                                        echo %value%>"%IS_INSTRUMENTAL_ADS_FILENAME%"
                                        return
                                endiff
                        

                        if "%2" == "force" .or. "1" == "%force_unmark_every_file_as_instrumental%" .or. "1" == "%force_mark_every_file_as_instrumental%" .or. "1" == "%force_mark_every_file_as_NOT_an_instrumental%" goto :endiff_skip_checks_becase_forcing_it_2865
                                set potential_is_instrumental=%@EXECSTR[type "%@UNQUOTE["%tmpFileForXAnswer_copy%"]:is_instrumental" >>&>nul] 
                                if      "1" == "%@Regex[[\[\(]instrumental[\]\)],"%tmpFileForXAnswer_copy%"]" (echo %STAR3% Already named an instrumental! %+ return) 

                                rem Check if it’s already marked via ADS tag:
                                        rem echo potential_is_instrumental == "%potential_is_instrumental%" 
                                        if "NOT_SET" == "%potential_is_instrumental%" goto not_yet_marked_2850
                                        if   "False" == "%potential_is_instrumental%" goto already_marked_2875
                                        if    "True" == "%potential_is_instrumental%" goto already_marked_2875
                                        if        "" == "%potential_is_instrumental%" goto not_yet_marked_2850
                                        goto not_yet_marked_2850
                                                :already_marked_2875
                                                        echo %STAR% instrumental status already marked as: “%potential_is_instrumental%”
                                                        return
                                        :not_yet_marked_2850
                
                                rem Preview sidecar files if applicable:
                                        if "1" == "%ask%" goto show_previews
                                        if "1" != "%currently_getting_lyrics%" goto :endiff_endpoint_because_currently_getting_lyrics
                                                :show_previews
                                                if  exist  "%potential_txt%" call review-files "%potential_txt%"
                                                if  exist  "%potential_lrc%" call review-files "%potential_lrc%"
                                                if  exist  "%potential_srt%" call review-files "%potential_srt%"
                                        :endiff_endpoint_because_currently_getting_lyrics
                        :endiff_skip_checks_becase_forcing_it_2865

                        :about_to_askyn_2890
                        set IS_INSTRUMENTAL_ADS_FILENAME=%@name[%@UNQUOTE["%tmpFileForXAnswer_copy%"]].%@EXT[%@UNQUOTE["%tmpFileForXAnswer_copy%"]]:is_instrumental %+ rem update this so our ads tagging doesn’t mark the old filename
                        rem pause hmmmm[1] ask=“%ask%”, answer=“%answer%”
                        if "1" == "%ask%" call  AskYN "Mark as instrumental?? [%ansi_color_bright_green%P%ansi_color_prompt%lay/%ansi_color_bright_green%R%ansi_color_prompt%ename/%ansi_color_bright_green%D%ansi_color_prompt%elete sidecars/mark %ansi_color_bright_green%s%ansi_color_prompt%ound effect/s%ansi_color_bright_green%K%ansi_color_prompt%ip]"  no     0      DIKPRS    P:play_it,I:yup_it_is_instrumental,R:rename_it!,D:delete_some_of_the_sidecar_files,S:mark_as_sound_effect,K:sKip_answering
                        if "S" != "%ANSWER" goto :not_S_2915
                                gosub rename_audio_file_as_sound_effect "%@UNQUOTE["%tmpFileForXAnswer_copy%"]"  tmpFileForXAnswer_copy
                                echo -DEBUG: LAST_RENAMED_TO=%lq%%LAST_RENAMED_TO%%rq% 🐈
                                if "" == "%LAST_RENAMED_TO%" goto :do_not__update_3032
                                        set tmpFileForXAnswer_copy=%LAST_RENAMED_TO% 
                                        set IS_INSTRUMENTAL_ADS_FILENAME=%@name[%@UNQUOTE["%tmpFileForXAnswer_copy%"]].%@EXT[%@UNQUOTE["%tmpFileForXAnswer_copy%"]]:is_instrumental
                                :do_not__update_3032
                                echo -DEBUG: tmpFileForXAnswer_copy now == %lq%%tmpFileForXAnswer_copy%%rq% .. LAST_RENAMED_TO was %lq%%LAST_RENAMED_TO%%rq% 
                                goto about_to_askyn_2890
                        :not_S_2915
                        if "1" == "%force_unmark_every_file_as_instrumental%" .or. "1" == "%force_mark_every_file_as_instrumental%" .or. "1" == "%force_mark_every_file_as_NOT_an_instrumental%" (
                                echo %ansi_color_important% %star2% Removing %lq%as_instrumental%rq% ADS tag
                                unset /q ANSWER
                                                                                           set TMP_VALUE=NOT_SET
                                if "1" == "%force_mark_every_file_as_instrumental%"        set TMP_VALUE=True
                                if "1" == "%force_mark_every_file_as_NOT_an_instrumental%" set TMP_VALUE=False
                                echo echo %TMP_VALUE%`>`"%IS_INSTRUMENTAL_ADS_FILENAME%"%newline%
                                     echo %TMP_VALUE%  >"%IS_INSTRUMENTAL_ADS_FILENAME%"
                        )

                        if  "P" == "%ANSWER%"  gosub check_for_answer_of_P  "%@UNQUOTE["%tmpFileForXAnswer_copy%"]"
                        rem pause hmmmm[2] ask=“%ask%”, answer=“%answer%” %+ echo off
                        if "R" != "%ANSWER%" goto :endiff_3062
                                unset /q LAST_RENAMED_TO
                                call rn "%@UNQUOTE["%tmpFileForXAnswer_copy%"]"
                                echo %ansi_color_blue%- DEBUG:after rn at 3020, last_renamed_to=“%LAST_RENAMED_TO%” so maybe set tmpFileForXAnswer_copy=%LAST_RENAMED_TO%%newline%- DEBUG: tmpFileForXAnswer_copy is now “%tmpFileForXAnswer_copy%” and IS_INSTRUMENTAL_ADS_FILENAME is now “%IS_INSTRUMENTAL_ADS_FILENAME%”%ansi_color_normal%
                                if "" == "%LAST_RENAMED_TO%" goto :endiff_3058
echo                   %ansi_color_pink%set  tmpFileForXAnswer_copy=%LAST_RENAMED_TO% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%ansi_color_normal% GOAT
                                        set  tmpFileForXAnswer_copy=%LAST_RENAMED_TO%
                                        echo tmpFileForXAnswer_copy is [A] now “%tmpFileForXAnswer_copy%”
echo                   %ansi_color_pink%set  IS_INSTRUMENTAL_ADS_FILENAME=%@name[%@UNQUOTE["%tmpFileForXAnswer_copy%"]].%@EXT[%@UNQUOTE["%tmpFileForXAnswer_copy%"]]:is_instrumental`%+`%ansi_color_purple%rem update this so our ads tagging doesn’t %ansi_color_normal%
                                        set  IS_INSTRUMENTAL_ADS_FILENAME=%@name[%@UNQUOTE["%tmpFileForXAnswer_copy%"]].%@EXT[%@UNQUOTE["%tmpFileForXAnswer_copy%"]]:is_instrumental %+ rem update this so our ads tagging doesn’t 
                                        echo IS_INSTRUMENTAL_ADS_FILENAME is [A] now ‘%IS_INSTRUMENTAL_ADS_FILENAME%’
                                :endiff_3058
                                echo %ansi_color_debug%- DEBUG:after rn at 3024, last_renamed_to=“%LAST_RENAMED_TO%” so maybe set tmpFileForXAnswer_copy=%LAST_RENAMED_TO%
                                echo %ansi_color_debug%- DEBUG: tmpFileForXAnswer_copy is now “%tmpFileForXAnswer%” and IS_INSTRUMENTAL_ADS_FILENAME is now “%IS_INSTRUMENTAL_ADS_FILENAME%”%ansi_color_normal%
                        :endiff_3062
                        rem "P" == "%ANSWER%"  .or. "R" == "%ANSWER%" goto  begin_loop_arefaaiow
                        rem "P" == "%ANSWER%"  .or. "R" == "%ANSWER%" goto  begin_loop_arefaaiow_for_real
                        if  "P" == "%ANSWER%"  .or. "R" == "%ANSWER%" goto  about_to_askyn_2890
                        if  "N" == "%ANSWER%"  echo False>"%IS_INSTRUMENTAL_ADS_FILENAME%"

                        rem pause hmmm[3] if  "1" == "%force_unmark_every_file_as_instrumental%" 
                        if  "1" == "%force_unmark_every_file_as_instrumental%" .or. "1" == "%force_mark_every_file_as_NOT_an_instrumental%" (
                                echo %ansi_color_unimportant% %star2% We%smart_apostrophe%re not doing renaming in this mode
                                return 
                        ) else (
                                if "%1" != "ask"       set   answer=y
                        )
                        if  "D" == "%ANSWER%"  goto :delete_some_of_the_sidecar_files_2880
                        if  "Y" != "%ANSWER%" .and. "I" != "%ANSWER%" goto :endiff_not_y_2856

                                rem Let’s not use the ADS tag, since we will be renaming the file:
                                rem *echo True>"%IS_INSTRUMENTAL_ADS_FILENAME%"
                                rem ...instead let’s mostly use the ADS tag to mark False, but never True

                                %color_removal%
                                :delete_some_of_the_sidecar_files_2880
                                set HELD_ANSWER_2876=%ANSWER%
                                        echo -DEBUG: delete some sidecar files??? potential_srt=“%potential_srt%” / potential_txt=“%potential_txt%” / potential_lrc=“%potential_lrc%”
                                        if not exist     "%potential_srt%"  goto :endiff_not_exist_potential_srt 
                                                call review-file "%potential_srt%"
                                                call AskYN  "Delete SRT file" yes 0
                                                if "Y" != "%ANSWER%"       goto :endiff_not_exist_potential_srt 
                                                echos %ansi_color_removal%
                                                *del /Ns "%potential_srt%"
                                        :endiff_not_exist_potential_srt 

                                        if not exist     "%potential_lrc%"  goto :endiff_not_exist_potential_lrc 
                                                call review-file "%potential_lrc%"
                                                call AskYN  "Delete LRC file" yes 0
                                                if "Y" != "%ANSWER%"       goto :endiff_not_exist_potential_lrc 
                                                echos %ansi_color_removal%
                                                *del /Ns "%potential_lrc%"
                                        :endiff_not_exist_potential_lrc 

                                        if not exist     "%potential_txt%"  goto :endiff_not_exist_potential_txt
                                                call review-file "%potential_txt%"
                                                call AskYN  "Delete TXT file" yes 0
                                                if "Y" != "%ANSWER%"       goto :endiff_not_exist_potential_txt 
                                                echos %ansi_color_removal%
                                                *del /Ns "%potential_txt%"
                                        :endiff_not_exist_potential_txt

                                        if not exist     "%potential_json%" goto :endiff_not_exist_potential_json
                                                echos %ansi_color_removal%
                                                *del /Ns "%potential_json%"
                                        :endiff_not_exist_potential_json
                                        echos %ansi_color_normal%
                                                   %color_normal%
                                set ANSWER=%HELD_ANSWER_2876%

                                rem If we are here because we hit “D” instead of “I”, then we just wanted to [D]elete the sidecar files, 
                                rem not [M]ark it as an instrumental, so we need to skip over that part and not mark it as an instrumental:
                                        if  "D" == "%ANSWER%"  goto :endiff_not_y_2856

                                rem If we are here, time to ACTUALLY mark it as an instrumental, as well as time
                                rem to and update the %tmpFileForXAnswer_copy% filename if the rename was successful:
                                        gosub rename_audio_file_as_instrumental "%@UNQUOTE["%tmpFileForXAnswer_copy%"]" %opt1% %opt2% %opt3%
                                        echo DEBUG: after rename, LAST_RENAMED_TO=“%LAST_RENAMED_TO%”
                                        iff "%LAST_RENAMED_TO%" != "" then
                                                set tmpFileForXAnswer_copy=%LAST_RENAMED_TO%
                                                set IS_INSTRUMENTAL_ADS_FILENAME=%@name[%@UNQUOTE["%tmpFileForXAnswer_copy%"]].%@EXT[%@UNQUOTE["%tmpFileForXAnswer_copy%"]]:is_instrumental
                                        endiff
                        :endiff_not_y_2856
                return


        rem :oops_made_a_duplicate_rename_audio_file_as_instrumental [opt opt2 opt3] 
        rem         :rafai_ask_again
        rem         unset /q ANSWER                       
        rem         if "%1" == "ask"                             call         AskYN                    "Mark as instrumental? [P=%ansi_color_bright_green%P%ansi_color_prompt%lay,D=%ansi_color_bright_green%d%ansi_color_prompt%elete some sidecars]" no 500 D D:delete_sidecars
        rem         if  "Y" == "%ANSWER%" .or. "%opt2%" != "ask" gosub "%BAT%\get-lyrics-for-file.btm"  rename_audio_file_as_instrumental                                           %opt%
        rem         if  "P" == "%ANSWER%" .                      goto        :rafai_ask_again                
        rem return


        :check_for_answer_of_X
                if "X" == "%ANSWER%" for %%tmpCFAXfile in (%filemask_audio%) do gosub rename_audio_file_as_instrumental "%@UNQUOTE["%%tmpCFAXfile"]"
        return

        :rename_audio_file_as_sound_effect [a_different_filename_than_usual optional_name_of_env_var_to_set_to_new_filename]                        
                gosub rename_audio_file_as_instrumental %a_different_filename_than_usual% "sound effect"
                if "%optional_name_of_env_var_to_set_to_new_filename%" != "" .and. "%LAST_RENAMED_TO%" != "" set %[%optional_name_of_env_var_to_set_to_new_filename%]=%LAST_RENAMED_TO%                                                                                                                                                                                      
        return
        :rename_audio_file_as_instrumental [different_filename_than_usual as_what]                        
                rem renaming as instrumental or as what else?
                        set nature=instrumental
                        if "" != "%@UNQUOTE["%as_what%"]" .and. "ask" != "%@UNQUOTE["%as_what%"]" set nature=%@UNQUOTE[%as_what%]
                        set   last_as_what=%as_what%
                        unset /q   as_what

                rem debug
                        echo %ansi_color_debug%- DEBUG: rename_audio_file_as_instrumental [%different_filename_than_usual% %last_as_what%]     as_what=%as_what% nature=%nature%%ansi_color_normal%

                rem Process filename parameter:
                        iff "" == "%different_filename_than_usual%" then
                                set filename_to_rename_as_instrumental_or_whatever=%audio_file%
                        else
                                set filename_to_rename_as_instrumental_or_whatever=%different_filename_than_usual%
                        endiff

                rem Skip if the file has already been marked as an instrumental:
                        rem 20250327: added brackets around %nature% in regex
                        iff "%@Regex[\[%nature%\],"%filename_to_rename_as_instrumental_or_whatever%"]" == "1" then
                                echo %ansi_color_warning_soft%%star2% %italics_on%Already marked%italics_off% as %nature%: “%faint_on%%filename_to_rename_as_instrumental_or_whatever%%faint_off%”
                                set already_marked_as=1
                        else
                                set already_marked_as=0
                        endiff
                        iff "%@Regex[sound effect,"%filename_to_rename_as_instrumental_or_whatever%"]" == "1" then
                                echo %ansi_color_warning_soft%%star2% %italics_on%Already marked%italics_off% as a sound effect: “%faint_on%%filename_to_rename_as_instrumental_or_whatever%%faint_off%”
                                set already_marked_as=1
                        endiff
                        if "1" == "%already_marked_as%" goto :skip_it_2700

                rem Delete the existing lyric file, since if it’s an instrumental, there shoudln’t be one:
                        set LYRIC_SIDECAR=%@NAME["%filename_to_rename_as_instrumental_or_whatever%"].txt
                        set  JSON_SIDECAR=%@NAME["%filename_to_rename_as_instrumental_or_whatever%"].json
                        set   LRC_SIDECAR=%@NAME["%filename_to_rename_as_instrumental_or_whatever%"].lrc
                        set   SRT_SIDECAR=%@NAME["%filename_to_rename_as_instrumental_or_whatever%"].srt
                        rem echo %ansi_color_removal%LYRIC_SIDECAR is “%LYRIC_SIDECAR%”
                        if not exist "%LYRIC_SIDECAR%" goto :no_delete_20934
                                if exist  "%JSON_SIDECAR%" *del    /Ns  "%JSON_SIDECAR%"

                                rem if not exist    "%SRT_SIDECAR%"  goto :endiff_not_exist_SRT_SIDECAR 
                                rem         call review-file "%SRT_SIDECAR%"
                                rem         call AskYN  "Delete SRT file" yes 0
                                rem         if "Y" != "%ANSWER%"       goto :endiff_not_exist_SRT_SIDECAR 
                                rem         echos %ansi_color_removal%
                                rem         *del    "%SRT_SIDECAR%"
                                rem :endiff_not_exist_SRT_SIDECAR 
                                rem 
                                rem if not exist    "%LRC_SIDECAR%"  goto :endiff_not_exist_LRC_SIDECAR 
                                rem         call review-file "%LRC_SIDECAR%"
                                rem         call AskYN  "Delete LRC file" yes 0
                                rem         if "Y" != "%ANSWER%"       goto :endiff_not_exist_LRC_SIDECAR 
                                rem         echos %ansi_color_removal%
                                rem         *del    "%LRC_SIDECAR%"
                                rem :endiff_not_exist_LRC_SIDECAR 
                                rem 
                                rem if not exist    "%LYRIC_SIDECAR%"  goto :endiff_not_exist_LYRIC_SIDECAR
                                rem         call review-file "%LYRIC_SIDECAR%"
                                rem         call AskYN  "Delete TXT file" yes 0
                                rem         if "Y" != "%ANSWER%"       goto :endiff_not_exist_LYRIC_SIDECAR 
                                rem         echos %ansi_color_removal%
                                rem         *del    "%LYRIC_SIDECAR%"
                                rem :endiff_not_exist_LYRIC_SIDECAR

                                rem old way as a fallback:
                                        rem echos %ansi_color_bright_yellow% %EMOJI_AXE%%EMOJI_AXE%%EMOJI_AXE% ``   
                                        set AXER=%EMOJI_AXE%%EMOJI_AXE%%EMOJI_AXE% ``
                                        if exist "%LYRIC_SIDECAR%" (call askyn "%AXER%Delete lyric sidecar"      yes 0 %+ if "Y" == "%ANSWER%" (*del /Ns "%LYRIC_SIDECAR%"                            ))
                                        if exist   "%SRT_SIDECAR%" (call askyn "%AXER%Delete srt & lrc sidecars" yes 0 %+ if "Y" == "%ANSWER%" (*del /Ns   "%SRT_SIDECAR%" %+ *del /Ns "%LRC_SIDECAR%"))

                                echos %ansi_color_normal%
                        :no_delete_20934

                rem Unset status bar if it’s set:
                        call status-bar unlock
                        rem echo 🐐 rename_audio_file_as_instrumental called with filename_to_rename_as_instrumental_or_whatever == “%filename_to_rename_as_instrumental_or_whatever%”

                rem Rename the file:
                        echos %ANSI_ERASE_TO_END_OF_SCREEN%
                        rem echo %ansi_color_unimportant%call rn "%@UNQUOTE[%filename_to_rename_as_instrumental_or_whatever%]" "%@NAME["%filename_to_rename_as_instrumental_or_whatever%"] [%nature%].%@EXT["%filename_to_rename_as_instrumental_or_whatever%"]"%ansi_color_normal% 🐐🐐
                                                         call rn "%@UNQUOTE[%filename_to_rename_as_instrumental_or_whatever%]" "%@NAME["%filename_to_rename_as_instrumental_or_whatever%"] [%nature%].%@EXT["%filename_to_rename_as_instrumental_or_whatever%"]"
                                                         echo after rn at 3125, last_renamed_to=“%LAST_RENAMED_TO%” so maybe set tmpFileForXAnswer_copy=%LAST_RENAMED_TO%
                                                         if "" != "%LAST_RENAMED_TO%" set tmpFileForXAnswer_copy=%LAST_RENAMED_TO%
        

                rem Validate that the renaming happened:              
                        rem echo BUG MONITOR for bug of: Marking instrumental doesn’t end when it should. Checking iff "" != "`%`LAST_RENAMED_TO`%`" which is “%LAST_RENAMED_TO%”... 🐐
                        iff "" != "%LAST_RENAMED_TO%" then
                                rem let’s not do this anymore: (20250221): set AUDIO_FILE=%@UNQUOTE[%LAST_RENAMED_TO%]
                                set JUST_RENAMED_TO_INSTRUMENTAL=1
                                rem Not anymore because we may be calling this for every file in the folder: quit
                                rem Instead:
                                set GOTO_END=1
                                goto /i end
                                rem echo BUG MONITOR for bug of: Marking instrumental doesn’t end when it should. GOTO_END is now “%GOTO_END%” and JUST_RENAMED_TO_INSTRUMENTAL is now “%JUST_RENAMED_TO_INSTRUMENTAL%” 🐐
                        endiff

                :skip_it_2700
        return


        :refresh_lyric_status [opt]
                rem echo 🐐 called refresh_lyric_status [%opt%]
                set FILE_TO_GET_LYRIC_STATUS_OF=%LYRIC_FILE%
                if exist %opt% set FILE_TO_GET_LYRIC_STATUS_OF="%@UNQUOTE["%opt%"]"
                rem echo 🐐 %blink_on% %ansi_color_orange% getting lyric status of “%FILE_TO_GET_LYRIC_STATUS_OF%” %blink_off% 
                if exist "%FILE_TO_GET_LYRIC_STATUS_OF%" goto :we_good
                        echo %ansi_color_warning_soft%%star2% Lyric file doesn’t exist to get status of in the first place: “%FILE_TO_GET_LYRIC_STATUS_OF%”
                        set LYRIC_STATUS=DOES_NOT_EXIST
                        return
                :we_good
                set REFRESH_COMMAND=call get-lyric-status "%@UNQUOTE["%FILE_TO_GET_LYRIC_STATUS_OF%"]"                
                rem echo %blink_on% %ansi_color_orange% lyric status refresh command will be: %REFRESH_COMMAND% %blink_off% 
                iff exist "%FILE_TO_GET_LYRIC_STATUS_OF%" .or. "%opt%" == "force" then
                        %REFRESH_COMMAND% >nul
                        if ""=="%last_file_to_get_lyric_status_of%" set last_file_to_get_lyric_status_of="%@UNQUOTE["%FILE_TO_GET_LYRIC_STATUS_OF%"]"
                endiff
                rem echo %blink_on% %ansi_color_orange% got lyric status of “%lyric_status%” %blink_off% 
        return

        :refresh_lyriclessness_status [opt]
                gosub "%BAT%\create-srt-from-file.bat" refresh_lyriclessness_status %opt%
        return

        :set_postprocessed_lyrics [opt]
                rem Debug:
                        echo %ansi_color_green%%%EMOJI_PHONE% CALLED: gosub set_postprocessed_lyrics "%lyric_file%"%ansi_color_normal%

                rem Process “opt” parameter to potentially override %lyric_file% with a different file:
                        set                  file_to_use=%@UNQUOTE["%LYRIC_FILE%"]
                        if "" != "%opt%" set file_to_use=%@UNQUOTE["%opt%"]

                rem Create a %tmpfile%:
                        call set-tmp-file "postprocessed lyrics"

                rem Run the post-processor on our input file, outputting to our tmpfile:
                        rem  type "%@UNQUOTE["%LYRIC_FILE%"]" |:u8  lyric-postprocessor.pl -A -L -S)                 >    %tmpfile%
                        rem (type            "%FILE_TO_USE%"  |:u8  lyric-postprocessor.pl -A -L -S)                 >    %tmpfile%
                                                                    lyric-postprocessor.pl -A -L -S  "%FILE_TO_USE%" >:u8 %tmpfile%

                rem Save the filename of our post-processed lyrics, so we can grab them later:
                        iff defined postprocessed_lyrics .and. exist %postprocessed_lyrics% .and. "%last_file_used_for_lyric_processing%" == "%file_to_use%" then
                                rem do nothing because it’s already set to an existing postprocessed file
                        else
                                set postprocessed_lyrics=%tmpfile% 
                        endiff

                rem Save the filename of our last input file, just in case we need it for something (aka “auditing”):
                        set last_file_used_for_lyric_processing=%file_to_use%
        return                        


rem ━━━━━━━━━━━━━━ SUBROUTINES: END ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

:END

rem Debug stuffs:
        rem echo 🦴 this is the end! %+ rem call pause-for-x-seconds 9
        rem echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 end 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 >nul
        echo This is the end of get-lyrics-for-file! pbatchname=%_PBATCHNAME>nul

:SetVarsOnly_skip_to_2
:The_VERY_End
        echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 end 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 >nul
        rem echo 🦴 this is the very end! %+ rem call pause-for-x-seconds 9

        rem Fix command separator:        
                if "%username%" != "claire" goto :fcs_end
                        @setdos /x0
                        @*setdos /x-5
                        @*setdos /c%DEFAULT_COMMAND_SEPARATOR_CHARACTER%
                        @setdos /x0
                :fcs_end

        rem Clean our temporary file (do we want to do this in SetVarsOnly mode?):
                if exist "__" (*del /q "__">nul)

:Pop_D
        echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 end 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 >nul
        rem echo 🦴 this is the popd section of the very end! %+ rem call pause-for-x-seconds 9
        rem Bring us back one folder level from the folder stack:
                setdos /x0
                REM this got me in trouble: whatever it was fixing needs to be fixed some other way:
                rem if %@DirStack[] gt 0 popd                                    %+ rem If we pushd’ed to another folder, popd back
                rem But unlike in create-srt, we will only do this once, so we won’t do this part: if %@DirStack[] gt 0 goto :Pop_D

                
        echo 🧹🧹🧹🧹🧹🧹 unsetting 🧹🧹🧹🧹🧹🧹🧹 GOTO_END=“%GOTO_END%” >nul
        rem echo 🦴 this is the unsetting of the very end! %+ rem call pause-for-x-seconds 9
        rem Unset various environment variables that we realllllllly want unset:        
                @echo off
                unset /q DO_NOT_ASK_TO_HAND_EDIT WE_GOOGLED TRY_SELECTION_AGAIN COVER_ORIGINAL_ATTEMPT LD1_MASSAGED_ATTEMPT_1 ONLY_ONE_FILE_AND_IT_WAS_TRIED DO_NOT_ASK_TO_HAND_EDIT JUST_APPROVED_LYRICS LYRICS_JUST_DISAPPROVED JUST_GENERATED_LYRICS FORCE_HAND_EDIT GENIUS_ONLY GOOGLE_NOW FORCE_ASK_TO_APPROVE_LYRICLESSNESS
            rem unset /q ALREADY_HAND_EDITED

                rem for LYRIC/LYRICLESSNESS status we want to retain the values if being called to create karaoke——so the karaoke creation process knows they are done
                rem     But otherwise, if we’re just looking for lyrics, then we can unset this value as we don’t need it later and it can mess up multilpe lyric search:
                rem echo 🦴 parent_bat = “%PARENT_BAT%” .. making_karaoke=“%making_karaoke%” %+ rem call pause-for-x-seconds 9
                iff "%PARENT_BAT%" != "create-srt-from-file" then
                    unset /q LYRICLESSNESS_STATUS LYRIC_STATUS                                                  
                endiff
                unset /q ANSWER ABANDONED_SEARCH
            rem unset /q LYRIC_SEARCH_FAILED            //leave this one for auditing
            rem unset /q LYRIC_RETRIEVAL_1_FAILED       //leave this one for auditing
                unset /q LYRICS_SHOULD_BE_CONSIDERED_ACCEPTIBLE  found_broad_lyrics_branch_1 LYRIC_SUCCESS_CELEBRATION_DISPLAYED already_tried_potential_lyrics_* did_not_go_to_end_169 goto_download_with_lyric_downloader_1 FIRST_SEARCH_COMPLETE goto_download_with_lyric* lyric_downloader_initialized JUST_RENAMED_TO_INSTRUMENTAL debanded FORCE_REGEN LAST_ALIGNMENT_TEMP_INDEX PREV_GENIUS_FNAME_2_USE
                        rem GOTO_END

                rem TODO i think maybe this should not be added: JUST_CONVERTED_LRC_TO_TEXT=0 JUST_CONVERTED_SRT_TO_TEXT=0


:final_ending
        @setdos /x0
        rem call status-bar unlock
        rem echo 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 END GET-LYRICS %* !!!! 🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁🏁 (pbatchname=%_PBATCHNAME)  {LYRIC_STATUS=“%LYRIC_STATUS”,LYRICLESSNESS_STATUS=“%LYRICLESSNESS_STATUS%”} >nul
        rem echo 🔚 end of %0 ... pbatchname=%_PBATCHNAME
        rem pause
        unset /q logged_lyricapproval_* player_command_to_use currently_getting_lyrics


echo [END GET-LYRICS]
